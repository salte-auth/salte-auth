{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///salte-auth.min.js","webpack:///webpack/bootstrap 629ad6e3a854c8bcfa42","webpack:///external {\"root\":\"_\",\"commonjs\":\"lodash\",\"commonjs2\":\"lodash\",\"amd\":\"lodash\"}","webpack:///../node_modules/uuid/lib/rng-browser.js","webpack:///../node_modules/uuid/lib/bytesToUuid.js","webpack:///./salte-auth.js","webpack:///../node_modules/uuid/index.js","webpack:///../node_modules/uuid/v1.js","webpack:///../node_modules/webpack/buildin/global.js","webpack:///../node_modules/uuid/v4.js","webpack:///./salte-auth.providers.js","webpack:///./providers/auth0.js","webpack:///./providers/azure.js","webpack:///./providers/cognito.js","webpack:///./providers/wso2.js","webpack:///./salte-auth.profile.js","webpack:///./salte-auth.utilities.js"],"names":["root","factory","exports","module","require","define","amd","self","this","__WEBPACK_EXTERNAL_MODULE_0__","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","global","rng","crypto","msCrypto","getRandomValues","rnds8","Uint8Array","rnds","Array","r","Math","random","bytesToUuid","buf","offset","bth","byteToHex","toString","substr","_classCallCheck","instance","Constructor","TypeError","value","SalteAuth","undefined","_createClass","defineProperties","target","props","length","descriptor","writable","key","protoProps","staticProps","_lodash","_uuid","_uuid2","obj","default","_salteAuthProviders","_salteAuthProfile","_salteAuthUtilities","config","_this","window","salte","auth","ReferenceError","$providers","Providers","$promises","$config","defaultsDeep","$provider","defaultConfig","$utilities","SalteAuthUtilities","profile","SalteAuthProfile","$iframe","parent","document","body","removeChild","$popup","storageType","$$transfer","setTimeout","close","$redirectUrl","location","href","error","$validate","$clear","redirectLoginCallback","addXHRInterceptor","request","data","checkForMatchingUrl","$url","endpoints","retrieveAccessToken","then","accessToken","setRequestHeader","addFetchInterceptor","input","options","headers","Authorization","addEventListener","$$onRouteChanged","bind","_this2","login","createIframe","$loginUrl","Promise","reject","catch","_this3","openPopup","_this4","logout","$deauthorizeUrl","_this5","_this6","token","resolve","idTokenExpired","loginType","loginWithPopup","indexOf","loginWithIframe","$clearErrors","accessTokenExpired","$accessTokenUrl","$accessToken","isRouteSecure","routes","provider","$localState","v4","$nonce","authorizeEndpoint","providerUrl","createUrl","assign","state","nonce","response_type","redirect_uri","redirectUrl","client_id","clientId","scope","prompt","queryParams","responseType","deauthorizeUrl","set","v1","uuid","b","clockseq","_clockseq","msecs","Date","getTime","nsecs","_lastNSecs","dt","_lastMSecs","Error","tl","tmh","node","_nodeId","_seedBytes","g","Function","eval","e","ii","_interopRequireDefault","_auth","_auth2","_azure","_azure2","_cognito","_cognito2","_wso","_wso2","SalteAuthAuth0Provider","returnTo","SalteAuthAzureProvider","post_logout_redirect_uri","SalteAuthCognitoProvider","logout_uri","validation","SalteAuthWSO2Provider","commonAuthLogout","type","commonAuthCallerPath","relyingParty","_slicedToArray","sliceIterator","arr","_arr","_n","_d","_e","_s","_i","Symbol","iterator","next","done","push","err","isArray","$instance","$$config","azp","aud","hash","params","replace","split","param","_param$split","_param$split2","$parse","decodeURIComponent","$tokenType","$expiration","now","$idToken","$state","$error","$errorDescription","accessTokenRequest","code","description","userInfo","find","audience","$storage","removeItem","setItem","localStorage","sessionStorage","source","destination","sourceStorage","$$getStorage","destinationStorage","getItem","match","$saveItem","exp","tokenType","expiration","idToken","localState","errorDescription","separatedToken","JSON","parse","atob","$interceptors","fetch","xhr","open","XMLHttpRequest","method","url","send","promises","interceptor","all","event","createEvent","initEvent","detail","dispatchEvent","arguments","baseUrl","keys","forEach","encodeURIComponent","path","$$urlDocument","implementation","createHTMLDocument","$$urlBase","createElement","$$urlAnchor","head","appendChild","protocol","host","tests","resolvedUrl","resolveUrl","test","RegExp","route","securedRoutes","height","width","top","innerHeight","screenTop","left","innerWidth","screenLeft","popupWindow","focus","checker","setInterval","closed","clearInterval","show","iframe","setAttribute","style","position","bottom","right","zIndex","border","opacity","transition","display","src","querySelector","opener"],"mappings":"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","file":"salte-auth.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"lodash\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"salte.auth\", [\"lodash\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"salte.auth\"] = factory(require(\"lodash\"));\n\telse\n\t\troot[\"salte.auth\"] = factory(root[\"_\"]);\n})(typeof self !== 'undefined' ? self : this, function(__WEBPACK_EXTERNAL_MODULE_0__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","/**\n * @salte-io/salte-auth JavaScript Library v2.0.2\n *\n * @license MIT (https://github.com/salte-io/salte-auth/blob/master/LICENSE)\n *\n * Made with ♥ by Ceci <admin@cecilias.me>, Dave Woodward <dave@salte.io>\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"lodash\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"salte.auth\", [\"lodash\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"salte.auth\"] = factory(require(\"lodash\"));\n\telse\n\t\troot[\"salte.auth\"] = factory(root[\"_\"]);\n})(typeof self !== 'undefined' ? self : this, function(__WEBPACK_EXTERNAL_MODULE_0__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 3);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_0__;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {// Unique ID creation requires a high quality random # generator.  In the\n// browser this is a little complicated due to unknown quality of Math.random()\n// and inconsistent support for the `crypto` API.  We do the best we can via\n// feature-detection\nvar rng;\n\nvar crypto = global.crypto || global.msCrypto; // for IE 11\nif (crypto && crypto.getRandomValues) {\n  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef\n  rng = function whatwgRNG() {\n    crypto.getRandomValues(rnds8);\n    return rnds8;\n  };\n}\n\nif (!rng) {\n  // Math.random()-based (RNG)\n  //\n  // If all else fails, use Math.random().  It's fast, but is of unspecified\n  // quality.\n  var rnds = new Array(16);\n  rng = function() {\n    for (var i = 0, r; i < 16; i++) {\n      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return rnds;\n  };\n}\n\nmodule.exports = rng;\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports) {\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex;\n  return bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]];\n}\n\nmodule.exports = bytesToUuid;\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(4);\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SalteAuth = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _lodash = __webpack_require__(0);\n\nvar _uuid = __webpack_require__(5);\n\nvar _uuid2 = _interopRequireDefault(_uuid);\n\nvar _salteAuthProviders = __webpack_require__(9);\n\nvar _salteAuthProfile = __webpack_require__(14);\n\nvar _salteAuthUtilities = __webpack_require__(15);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Disable certain security validations if your provider doesn't support them.\n * @typedef {Object} Validation\n * @property {Boolean} [nonce=true] Passing false will disable nonce validation, leaving you vulnerable to replay attacks.\n * @property {Boolean} [state=true] Passing false will disable state validation, leaving you vulnerable to XSRF attacks.\n * @property {Boolean} [azp=true] Passing false will disable azp validation.\n * @property {Boolean} [aud=true] Passing false will disable aud validation.\n */\n\n/**\n * The configuration for salte auth\n * @typedef {Object} Config\n * @property {String} providerUrl The base url of your identity provider.\n * @property {('id_token'|'id_token token')} responseType The response type to authenticate with.\n * @property {String} redirectUrl The redirect url specified in your identity provider.\n * @property {String} clientId The client id of your identity provider\n * @property {String} scope A list of space-delimited claims used to determine what user information is provided and what access is given. Most providers require 'openid'.\n * @property {Boolean|Array<String>} routes A list of secured routes. If true is provided then all routes are secured.\n * @property {Array<String|RegExp>} endpoints A list of secured endpoints.\n * @property {('auth0'|'azure'|'cognito'|'wso2')} provider The identity provider you're using.\n * @property {Function} [redirectLoginCallback] A callback that is invoked when a redirect login fails or succeeds.\n * @property {('session'|'local')} [storageType='session'] The Storage api to keep authenticate information stored in.\n * @property {Boolean|Validation} [validation] Used to disable certain security validations if your provider doesn't support them.\n */\n\n/**\n * Authentication Controller\n */\nvar SalteAuth = function () {\n  /**\n   * Sets up Salte Auth\n   * @param {Config} config configuration for salte auth\n   */\n  function SalteAuth(config) {\n    var _this = this;\n\n    _classCallCheck(this, SalteAuth);\n\n    if (window.salte.auth) {\n      return window.salte.auth;\n    }\n\n    if (!config) {\n      throw new ReferenceError('A config must be provided.');\n    }\n\n    /**\n     * The supported identity providers\n     * @type {Providers}\n     * @private\n     */\n    this.$providers = _salteAuthProviders.Providers;\n    /**\n     * The active authentication promises\n     * @private\n     */\n    this.$promises = {};\n    /**\n     * The configuration for salte auth\n     * @private\n     */\n    this.$config = config;\n    this.$config = (0, _lodash.defaultsDeep)(config, this.$provider.defaultConfig);\n    /**\n     * Various utility functions for salte auth\n     * @type {SalteAuthUtilities}\n     * @private\n     */\n    this.$utilities = new _salteAuthUtilities.SalteAuthUtilities();\n\n    /**\n     * The user profile for salte auth\n     * @type {SalteAuthProfile}\n     */\n    this.profile = new _salteAuthProfile.SalteAuthProfile(this.$config);\n\n    if (this.$utilities.$iframe) {\n      parent.document.body.removeChild(this.$utilities.$iframe);\n    } else if (this.$utilities.$popup) {\n      // We need to utilize local storage to retain our parsed values\n      if (this.$config.storageType === 'session') {\n        this.profile.$$transfer('session', 'local');\n      }\n      setTimeout(this.$utilities.$popup.close);\n    } else if (this.profile.$redirectUrl && location.href !== this.profile.$redirectUrl) {\n      var error = this.profile.$validate();\n      if (error) {\n        this.profile.$clear();\n      } else {\n        location.href = this.profile.$redirectUrl;\n        this.profile.$redirectUrl = undefined;\n      }\n      this.$config.redirectLoginCallback(error);\n    } else {\n      this.$utilities.addXHRInterceptor(function (request, data) {\n        if (_this.$utilities.checkForMatchingUrl(request.$url, _this.$config.endpoints)) {\n          return _this.retrieveAccessToken().then(function (accessToken) {\n            request.setRequestHeader('Authorization', 'Bearer ' + accessToken);\n          });\n        }\n      });\n\n      this.$utilities.addFetchInterceptor(function (input, options) {\n        if (_this.$utilities.checkForMatchingUrl(input, _this.$config.endpoints)) {\n          return _this.retrieveAccessToken().then(function (accessToken) {\n            options.headers = options.headers || {};\n            options.headers.Authorization = 'Bearer ' + accessToken;\n          });\n        }\n      });\n\n      window.addEventListener('popstate', this.$$onRouteChanged.bind(this));\n      document.addEventListener('click', this.$$onRouteChanged.bind(this));\n      setTimeout(this.$$onRouteChanged.bind(this));\n    }\n    window.salte.auth = this;\n  }\n\n  /**\n   * Returns the configured provider\n   * @type {Class|Object}\n   * @private\n   */\n\n\n  _createClass(SalteAuth, [{\n    key: 'loginWithIframe',\n\n\n    /**\n     * Authenticates using the iframe-based OAuth flow.\n     * @return {Promise} a promise that resolves when we finish authenticating\n     */\n    value: function loginWithIframe() {\n      var _this2 = this;\n\n      if (this.$promises.login) {\n        return this.$promises.login;\n      }\n\n      this.profile.$clear();\n      this.$promises.login = this.$utilities.createIframe(this.$loginUrl, true).then(function () {\n        _this2.$promises.login = null;\n        var error = _this2.profile.$validate();\n\n        if (error) {\n          _this2.profile.$clear();\n          return Promise.reject(error);\n        }\n      }).catch(function (error) {\n        _this2.$promises.login = null;\n        return Promise.reject(error);\n      });\n\n      return this.$promises.login;\n    }\n\n    /**\n     * Authenticates using the popup-based OAuth flow.\n     * @return {Promise} a promise that resolves when we finish authenticating\n     */\n\n  }, {\n    key: 'loginWithPopup',\n    value: function loginWithPopup() {\n      var _this3 = this;\n\n      if (this.$promises.login) {\n        return this.$promises.login;\n      }\n\n      this.profile.$clear();\n      this.$promises.login = this.$utilities.openPopup(this.$loginUrl).then(function () {\n        _this3.$promises.login = null;\n        // We need to utilize local storage to retain our parsed values\n        if (_this3.$config.storageType === 'session') {\n          _this3.profile.$$transfer('local', 'session');\n        }\n        var error = _this3.profile.$validate();\n\n        if (error) {\n          _this3.profile.$clear();\n          return Promise.reject(error);\n        }\n      }).catch(function (error) {\n        _this3.$promises.login = null;\n        return Promise.reject(error);\n      });\n\n      return this.$promises.login;\n    }\n\n    /**\n     * Authenticates using the redirect-based OAuth flow.\n     */\n\n  }, {\n    key: 'loginWithRedirect',\n    value: function loginWithRedirect() {\n      if (!this.$config.redirectLoginCallback) {\n        throw new ReferenceError('A redirectLoginCallback is required to invoke \"loginWithRedirect\"!');\n      }\n\n      this.profile.$clear();\n      this.profile.$redirectUrl = this.profile.$redirectUrl || location.href;\n      location.href = this.$loginUrl;\n    }\n\n    /**\n     * Unauthenticates using the iframe-based OAuth flow.\n     * @return {Promise} a promise that resolves when we finish deauthenticating\n     */\n\n  }, {\n    key: 'logoutWithIframe',\n    value: function logoutWithIframe() {\n      var _this4 = this;\n\n      if (this.$promises.logout) {\n        return this.$promises.logout;\n      }\n\n      this.profile.$clear();\n      this.$promises.logout = this.$utilities.createIframe(this.$deauthorizeUrl).then(function () {\n        _this4.$promises.logout = null;\n      });\n      return this.$promises.logout;\n    }\n\n    /**\n     * Unauthenticates using the popup-based OAuth flow.\n     * @return {Promise} a promise that resolves when we finish deauthenticating\n     */\n\n  }, {\n    key: 'logoutWithPopup',\n    value: function logoutWithPopup() {\n      var _this5 = this;\n\n      if (this.$promises.logout) {\n        return this.$promises.logout;\n      }\n\n      this.profile.$clear();\n      this.$promises.logout = this.$utilities.openPopup(this.$deauthorizeUrl).then(function () {\n        _this5.$promises.logout = null;\n      });\n\n      return this.$promises.logout;\n    }\n\n    /**\n     * Logs the user out of their configured identity provider.\n     */\n\n  }, {\n    key: 'logoutWithRedirect',\n    value: function logoutWithRedirect() {\n      this.profile.$clear();\n      location.href = this.$deauthorizeUrl;\n    }\n\n    /**\n     * Authenticates, requests the access token, and returns it if necessary.\n     * @return {Promise<string>} a promise that resolves when we retrieve the access token\n     */\n\n  }, {\n    key: 'retrieveAccessToken',\n    value: function retrieveAccessToken() {\n      var _this6 = this;\n\n      if (this.$promises.token) {\n        return this.$promises.token;\n      }\n\n      this.$promises.token = Promise.resolve();\n      if (this.profile.idTokenExpired) {\n        if (this.$config.loginType === 'popup') {\n          this.$promises.token = this.loginWithPopup();\n        } else if ([undefined, null, 'iframe'].indexOf(this.$config.loginType) !== -1) {\n          this.$promises.token = this.loginWithIframe();\n        } else {\n          this.$promises.token = null;\n          return Promise.reject(new ReferenceError('Invaid Login Type (' + this.$config.loginType + ')'));\n        }\n      }\n\n      this.$promises.token = this.$promises.token.then(function () {\n        _this6.profile.$clearErrors();\n        if (_this6.profile.accessTokenExpired) {\n          return _this6.$utilities.createIframe(_this6.$accessTokenUrl).then(function () {\n            _this6.$promises.token = null;\n            var error = _this6.profile.$validate(true);\n\n            if (error) {\n              return Promise.reject(error);\n            }\n            return _this6.profile.$accessToken;\n          });\n        }\n        _this6.$promises.token = null;\n        return _this6.profile.$accessToken;\n      }).catch(function (error) {\n        _this6.$promises.token = null;\n        return Promise.reject(error);\n      });\n\n      return this.$promises.token;\n    }\n\n    /**\n     * Checks if the current route is secured and authenticates the user if necessary\n     * @ignore\n     */\n\n  }, {\n    key: '$$onRouteChanged',\n    value: function $$onRouteChanged() {\n      if (!this.$utilities.isRouteSecure(location.href, this.$config.routes)) return;\n\n      this.retrieveAccessToken();\n    }\n  }, {\n    key: '$provider',\n    get: function get() {\n      if (!this.$config.provider) {\n        throw new ReferenceError('A provider must be specified');\n      }\n\n      if (typeof this.$config.provider === 'string') {\n        var provider = this.$providers[this.$config.provider];\n        if (!provider) {\n          throw new ReferenceError('Unknown Provider (' + this.$config.provider + ')');\n        }\n        return provider;\n      }\n\n      return this.$config.provider;\n    }\n\n    /**\n     * The authentication url to retrieve the access token\n     * @type {String}\n     * @private\n     */\n\n  }, {\n    key: '$accessTokenUrl',\n    get: function get() {\n      this.profile.$localState = _uuid2.default.v4();\n      this.profile.$nonce = _uuid2.default.v4();\n\n      var authorizeEndpoint = this.$config.providerUrl + '/authorize';\n      if (this.$provider.authorizeEndpoint) {\n        authorizeEndpoint = this.$provider.authorizeEndpoint.call(this, this.$config);\n      }\n\n      return this.$utilities.createUrl(authorizeEndpoint, (0, _lodash.assign)({\n        'state': this.profile.$localState,\n        'nonce': this.profile.$nonce,\n        'response_type': 'token',\n        'redirect_uri': this.$config.redirectUrl,\n        'client_id': this.$config.clientId,\n        'scope': this.$config.scope,\n        'prompt': 'none'\n      }, this.$config.queryParams));\n    }\n\n    /**\n     * The authentication url to retrieve the id token\n     * @type {String}\n     * @private\n     */\n\n  }, {\n    key: '$loginUrl',\n    get: function get() {\n      this.profile.$localState = _uuid2.default.v4();\n      this.profile.$nonce = _uuid2.default.v4();\n\n      var authorizeEndpoint = this.$config.providerUrl + '/authorize';\n      if (this.$provider.authorizeEndpoint) {\n        authorizeEndpoint = this.$provider.authorizeEndpoint.call(this, this.$config);\n      }\n\n      return this.$utilities.createUrl(authorizeEndpoint, (0, _lodash.assign)({\n        'state': this.profile.$localState,\n        'nonce': this.profile.$nonce,\n        'response_type': this.$config.responseType,\n        'redirect_uri': this.$config.redirectUrl,\n        'client_id': this.$config.clientId,\n        'scope': this.$config.scope\n      }, this.$config.queryParams));\n    }\n\n    /**\n     * The url to logout of the configured provider\n     * @type {String}\n     * @private\n     */\n\n  }, {\n    key: '$deauthorizeUrl',\n    get: function get() {\n      return this.$provider.deauthorizeUrl.call(this, this.$config);\n    }\n  }]);\n\n  return SalteAuth;\n}();\n\n(0, _lodash.set)(window, 'salte.SalteAuth', (0, _lodash.get)(window, 'salte.SalteAuth', SalteAuth));\nexports.SalteAuth = SalteAuth;\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar v1 = __webpack_require__(6);\nvar v4 = __webpack_require__(8);\n\nvar uuid = v4;\nuuid.v1 = v1;\nuuid.v4 = v4;\n\nmodule.exports = uuid;\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar rng = __webpack_require__(1);\nvar bytesToUuid = __webpack_require__(2);\n\n// **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\n// random #'s we need to init node and clockseq\nvar _seedBytes = rng();\n\n// Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\nvar _nodeId = [\n  _seedBytes[0] | 0x01,\n  _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]\n];\n\n// Per 4.2.2, randomize (14 bit) clockseq\nvar _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;\n\n// Previous uuid creation time\nvar _lastMSecs = 0, _lastNSecs = 0;\n\n// See https://github.com/broofa/node-uuid for API details\nfunction v1(options, buf, offset) {\n  var i = buf && offset || 0;\n  var b = buf || [];\n\n  options = options || {};\n\n  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;\n\n  // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();\n\n  // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;\n\n  // Time since last uuid creation (in msecs)\n  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;\n\n  // Per 4.2.1.2, Bump clockseq on clock regression\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  }\n\n  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  }\n\n  // Per 4.2.1.2 Throw error if too many uuids are requested\n  if (nsecs >= 10000) {\n    throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq;\n\n  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n  msecs += 12219292800000;\n\n  // `time_low`\n  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff;\n\n  // `time_mid`\n  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff;\n\n  // `time_high_and_version`\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n  b[i++] = tmh >>> 16 & 0xff;\n\n  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n  b[i++] = clockseq >>> 8 | 0x80;\n\n  // `clock_seq_low`\n  b[i++] = clockseq & 0xff;\n\n  // `node`\n  var node = options.node || _nodeId;\n  for (var n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf ? buf : bytesToUuid(b);\n}\n\nmodule.exports = v1;\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports) {\n\nvar g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar rng = __webpack_require__(1);\nvar bytesToUuid = __webpack_require__(2);\n\nfunction v4(options, buf, offset) {\n  var i = buf && offset || 0;\n\n  if (typeof(options) == 'string') {\n    buf = options == 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || bytesToUuid(rnds);\n}\n\nmodule.exports = v4;\n\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Providers = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _auth = __webpack_require__(10);\n\nvar _auth2 = _interopRequireDefault(_auth);\n\nvar _azure = __webpack_require__(11);\n\nvar _azure2 = _interopRequireDefault(_azure);\n\nvar _cognito = __webpack_require__(12);\n\nvar _cognito2 = _interopRequireDefault(_cognito);\n\nvar _wso = __webpack_require__(13);\n\nvar _wso2 = _interopRequireDefault(_wso);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * A collection of overrides for specific Identity Providers\n */\nvar Providers = function () {\n  function Providers() {\n    _classCallCheck(this, Providers);\n  }\n\n  _createClass(Providers, null, [{\n    key: 'auth0',\n\n    /**\n     * Provider for Auth0\n     * @type {SalteAuthAuth0Provider}\n     */\n    get: function get() {\n      return _auth2.default;\n    }\n\n    /**\n     * Provider for Azure's Active Directory\n     * @type {SalteAuthAzureProvider}\n     */\n\n  }, {\n    key: 'azure',\n    get: function get() {\n      return _azure2.default;\n    }\n\n    /**\n     * Provider for Amazon's Cognito\n     * @type {SalteAuthCognitoProvider}\n     */\n\n  }, {\n    key: 'cognito',\n    get: function get() {\n      return _cognito2.default;\n    }\n\n    /**\n     * Provider for WSO2's API Gateway\n     * @type {SalteAuthWSO2Provider}\n     */\n\n  }, {\n    key: 'wso2',\n    get: function get() {\n      return _wso2.default;\n    }\n  }]);\n\n  return Providers;\n}();\n\n;\n\nexports.Providers = Providers;\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Provider for Auth0\n * @see https://auth0.com\n */\nvar SalteAuthAuth0Provider = function () {\n  function SalteAuthAuth0Provider() {\n    _classCallCheck(this, SalteAuthAuth0Provider);\n  }\n\n  _createClass(SalteAuthAuth0Provider, null, [{\n    key: \"deauthorizeUrl\",\n\n    /**\n     * Computes the deauthorization url\n     * @param {Config} config configuration for salte auth\n     * @return {String} the deauthorization url\n     */\n    value: function deauthorizeUrl(config) {\n      return this.$utilities.createUrl(config.providerUrl + \"/v2/logout\", {\n        returnTo: config.redirectUrl,\n        client_id: config.clientId\n      });\n    }\n  }]);\n\n  return SalteAuthAuth0Provider;\n}();\n\nexports.default = SalteAuthAuth0Provider;\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/** Provider for Azure's Active Directory */\nvar SalteAuthAzureProvider = function () {\n  function SalteAuthAzureProvider() {\n    _classCallCheck(this, SalteAuthAzureProvider);\n  }\n\n  _createClass(SalteAuthAzureProvider, null, [{\n    key: \"authorizeEndpoint\",\n\n    /**\n     * Computes the authorization endpoint\n     * @param {Config} config configuration for salte auth\n     * @return {String} the authorization endpoint\n     */\n    value: function authorizeEndpoint(config) {\n      return config.providerUrl + \"/oauth2/authorize\";\n    }\n\n    /**\n     * Computes the deauthorization url\n     * @param {Config} config configuration for salte auth\n     * @return {String} the deauthorization url\n     */\n\n  }, {\n    key: \"deauthorizeUrl\",\n    value: function deauthorizeUrl(config) {\n      return this.$utilities.createUrl(config.providerUrl + \"/oauth2/logout\", {\n        post_logout_redirect_uri: config.redirectUrl\n      });\n    }\n  }]);\n\n  return SalteAuthAzureProvider;\n}();\n\nexports.default = SalteAuthAzureProvider;\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/** Provider for Amazon's Cognito */\nvar SalteAuthCognitoProvider = function () {\n  function SalteAuthCognitoProvider() {\n    _classCallCheck(this, SalteAuthCognitoProvider);\n  }\n\n  _createClass(SalteAuthCognitoProvider, null, [{\n    key: \"authorizeEndpoint\",\n\n    /**\n     * Computes the authorization endpoint\n     * @param {Config} config configuration for salte auth\n     * @return {String} the authorization endpoint\n     */\n    value: function authorizeEndpoint(config) {\n      return config.providerUrl + \"/oauth2/authorize\";\n    }\n\n    /**\n     * Computes the deauthorization url\n     * @param {Config} config configuration for salte auth\n     * @return {String} the deauthorization url\n     */\n\n  }, {\n    key: \"deauthorizeUrl\",\n    value: function deauthorizeUrl(config) {\n      return this.$utilities.createUrl(config.providerUrl + \"/logout\", {\n        logout_uri: config.redirectUrl,\n        client_id: config.clientId\n      });\n    }\n\n    /**\n     * Provides a set of default config options required for cognito\n     */\n\n  }, {\n    key: \"defaultConfig\",\n    get: function get() {\n      return {\n        validation: {\n          // Amazon Cognito doesn't support nonce validation\n          nonce: false\n        }\n      };\n    }\n  }]);\n\n  return SalteAuthCognitoProvider;\n}();\n\nexports.default = SalteAuthCognitoProvider;\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/** Provider for WSO2's API Gateway */\nvar SalteAuthWSO2Provider = function () {\n  function SalteAuthWSO2Provider() {\n    _classCallCheck(this, SalteAuthWSO2Provider);\n  }\n\n  _createClass(SalteAuthWSO2Provider, null, [{\n    key: 'deauthorizeUrl',\n\n    /**\n     * Computes the deauthorization url\n     * @param {Config} config configuration for salte auth\n     * @return {String} the deauthorization url\n     */\n    value: function deauthorizeUrl(config) {\n      return this.$utilities.createUrl(config.providerUrl + '/commonauth', {\n        commonAuthLogout: true,\n        type: 'oidc',\n        commonAuthCallerPath: config.redirectUrl,\n        relyingParty: config.relyingParty\n      });\n    }\n  }]);\n\n  return SalteAuthWSO2Provider;\n}();\n\nexports.default = SalteAuthWSO2Provider;\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SalteAuthProfile = undefined;\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _lodash = __webpack_require__(0);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * All the profile information associated with the current authentication session\n */\nvar SalteAuthProfile = function () {\n  /**\n   * Parses the current url for the authentication values\n   * @param {Config} config configuration for salte auth\n   */\n  function SalteAuthProfile(config) {\n    _classCallCheck(this, SalteAuthProfile);\n\n    if (window.salte.SalteAuthProfile.$instance) {\n      return window.salte.SalteAuthProfile.$instance;\n    }\n    /** @ignore */\n    this.$$config = (0, _lodash.defaultsDeep)(config, {\n      validation: {\n        nonce: true,\n        state: true,\n        azp: true,\n        aud: true\n      },\n      storageType: 'session'\n    });\n    if (location.hash) {\n      var params = location.hash.replace(/(#!?[^#]+)?#/, '').split('&');\n      for (var i = 0; i < params.length; i++) {\n        var param = params[i];\n\n        var _param$split = param.split('='),\n            _param$split2 = _slicedToArray(_param$split, 2),\n            key = _param$split2[0],\n            value = _param$split2[1];\n\n        this.$parse(key, decodeURIComponent(value));\n      }\n    }\n    window.salte.SalteAuthProfile.$instance = this;\n  }\n\n  /**\n   * Parse a key-value pair\n   * @param {String} key the key to parse\n   * @param {Object} value the matching value to parse\n   * @private\n   */\n\n\n  _createClass(SalteAuthProfile, [{\n    key: '$parse',\n    value: function $parse(key, value) {\n      switch (key) {\n        case 'token_type':\n          this.$tokenType = value;\n          break;\n        case 'expires_in':\n          this.$expiration = Date.now() + value;\n          break;\n        case 'access_token':\n          this.$accessToken = value;\n          break;\n        case 'id_token':\n          this.$idToken = value;\n          break;\n        case 'state':\n          this.$state = value;\n          break;\n        case 'error':\n          this.$error = value;\n          break;\n        case 'error_description':\n          this.$errorDescription = value;\n          break;\n      }\n    }\n\n    /**\n     * Whether the ID Token has expired\n     * @return {Boolean} true if the \"id_token\" has expired\n     */\n\n  }, {\n    key: '$validate',\n\n\n    /**\n     * Verifies that we were logged in successfully and that all security checks pass\n     * @param {Boolean} accessTokenRequest if the request we're validating was an access token request\n     * @return {Object} the error message\n     * @private\n     */\n    value: function $validate(accessTokenRequest) {\n      var _this = this;\n\n      if (!this.$$config.validation) {\n        return;\n      }\n\n      if (this.$error) {\n        return {\n          code: this.$error,\n          description: this.$errorDescription\n        };\n      }\n\n      if (!this.$idToken) {\n        return {\n          code: 'login_canceled',\n          description: 'User likely canceled the login or something unexpected occurred.'\n        };\n      }\n\n      if (this.$$config.validation.state && this.$localState !== this.$state) {\n        return {\n          code: 'invalid_state',\n          description: 'State provided by identity provider did not match local state.'\n        };\n      }\n\n      if (accessTokenRequest) return;\n\n      if (this.$$config.validation.nonce && this.$nonce !== this.userInfo.nonce) {\n        return {\n          code: 'invalid_nonce',\n          description: 'Nonce provided by identity provider did not match local nonce.'\n        };\n      }\n\n      if (Array.isArray(this.userInfo.aud)) {\n        if (this.$$config.validation.azp) {\n          if (!this.userInfo.azp) {\n            return {\n              code: 'invalid_azp',\n              description: 'Audience was returned as an array and AZP was not present on the ID Token.'\n            };\n          }\n\n          if (this.userInfo.azp !== this.$$config.clientId) {\n            return {\n              code: 'invalid_azp',\n              description: 'AZP does not match the Client ID.'\n            };\n          }\n        }\n\n        if (this.$$config.validation.aud) {\n          var aud = (0, _lodash.find)(this.userInfo.aud, function (audience) {\n            return audience === _this.$$config.clientId;\n          });\n\n          if (!aud) {\n            return {\n              code: 'invalid_aud',\n              description: 'None of the audience values matched the Client ID.'\n            };\n          }\n        }\n      } else if (this.$$config.validation.aud && this.userInfo.aud !== this.$$config.clientId) {\n        return {\n          code: 'invalid_aud',\n          description: 'The audience did not match the Client ID.'\n        };\n      }\n    }\n\n    /**\n     * Saves a value to the Web Storage API\n     * @param {String} key The key to save to\n     * @param {*} value The value to save, if this is undefined or null it will delete the key\n     * @private\n     */\n\n  }, {\n    key: '$saveItem',\n    value: function $saveItem(key, value) {\n      if ([undefined, null].indexOf(value) !== -1) {\n        this.$storage.removeItem(key);\n      } else {\n        this.$storage.setItem(key, value);\n      }\n    }\n\n    /**\n     * Return the active Web Storage API\n     * @return {Storage} the storage api to save and pull values from\n     * @private\n     */\n\n  }, {\n    key: '$$getStorage',\n\n\n    /**\n     * Determines which Web Storage API to return using the name provided\n     * @param {String} storageType the name of the storageType to use\n     * @return {Storage} the web storage api that matches the given string\n     * @ignore\n     */\n    value: function $$getStorage(storageType) {\n      if (storageType === 'local') {\n        return localStorage;\n      } else if (storageType === 'session') {\n        return sessionStorage;\n      } else {\n        throw new ReferenceError('Unknown Storage Type (' + storageType + ')');\n      }\n    }\n\n    /**\n     * Transfers values from one storage type to the other\n     * @param {String} source the name of the storage type to pull from\n     * @param {String} destination the name of the storage type to push to\n     * @ignore\n     */\n\n  }, {\n    key: '$$transfer',\n    value: function $$transfer(source, destination) {\n      var sourceStorage = this.$$getStorage(source);\n      var destinationStorage = this.$$getStorage(destination);\n\n      for (var key in sourceStorage) {\n        if (key.indexOf('salte.auth.') !== 0) continue;\n\n        destinationStorage.setItem(key, sourceStorage.getItem(key));\n        sourceStorage.removeItem(key);\n      }\n    }\n\n    /**\n     * Clears all `salte.auth` values from localStorage\n     * @private\n     */\n\n  }, {\n    key: '$clear',\n    value: function $clear() {\n      for (var key in this.$storage) {\n        if (key.match(/^salte\\.auth\\.[^$]/)) {\n          this.$saveItem(key, undefined);\n        }\n      }\n    }\n\n    /**\n     * Clears all `salte.auth` error values from localStorage\n     * @private\n     */\n\n  }, {\n    key: '$clearErrors',\n    value: function $clearErrors() {\n      this.$error = undefined;\n      this.$errorDescription = undefined;\n    }\n  }, {\n    key: 'idTokenExpired',\n    get: function get() {\n      return !this.$idToken || Date.now() >= this.userInfo.exp * 1000;\n    }\n\n    /**\n     * Whether the Access Token has expired\n     * @return {Boolean} true if the \"access_token\" has expired\n     */\n\n  }, {\n    key: 'accessTokenExpired',\n    get: function get() {\n      return !this.$accessToken || Date.now() >= this.$expiration;\n    }\n\n    /**\n     * The type of Access Token that was returned by the identity provider\n     * @return {String} the type of access token\n     * @private\n     */\n\n  }, {\n    key: '$tokenType',\n    get: function get() {\n      return this.$storage.getItem('salte.auth.token-type');\n    },\n    set: function set(tokenType) {\n      this.$saveItem('salte.auth.token-type', tokenType);\n    }\n\n    /**\n     * The date and time that the access token will expire\n     * @return {String} the expiration time as unix timestamp\n     * @private\n     */\n\n  }, {\n    key: '$expiration',\n    get: function get() {\n      return this.$storage.getItem('salte.auth.expiration');\n    },\n    set: function set(expiration) {\n      this.$saveItem('salte.auth.expiration', expiration);\n    }\n\n    /**\n     * The Access Token returned by the identity provider\n     * @return {String} the access token\n     * @private\n     */\n\n  }, {\n    key: '$accessToken',\n    get: function get() {\n      return this.$storage.getItem('salte.auth.access-token');\n    },\n    set: function set(accessToken) {\n      this.$saveItem('salte.auth.access-token', accessToken);\n    }\n\n    /**\n     * The ID Token returned by the identity provider\n     * @return {String} the id token\n     * @private\n     */\n\n  }, {\n    key: '$idToken',\n    get: function get() {\n      return this.$storage.getItem('salte.auth.id-token');\n    },\n    set: function set(idToken) {\n      this.$saveItem('salte.auth.id-token', idToken);\n    }\n\n    /**\n     * The authentication state returned by the identity provider\n     * @return {String} the state value\n     * @private\n     *\n     * @see https://tools.ietf.org/html/rfc6749#section-4.1.1\n     */\n\n  }, {\n    key: '$state',\n    get: function get() {\n      return this.$storage.getItem('salte.auth.state');\n    },\n    set: function set(state) {\n      this.$saveItem('salte.auth.state', state);\n    }\n\n    /**\n     * The locally generate authentication state\n     * @return {String} the local state value\n     * @private\n     *\n     * @see https://tools.ietf.org/html/rfc6749#section-4.1.1\n     */\n\n  }, {\n    key: '$localState',\n    get: function get() {\n      return this.$storage.getItem('salte.auth.local-state');\n    },\n    set: function set(localState) {\n      this.$saveItem('salte.auth.local-state', localState);\n    }\n\n    /**\n     * The error returned by the identity provider\n     * @return {String} the state value\n     * @private\n     */\n\n  }, {\n    key: '$error',\n    get: function get() {\n      return this.$storage.getItem('salte.auth.error');\n    },\n    set: function set(error) {\n      this.$saveItem('salte.auth.error', error);\n    }\n\n    /**\n     * The error description returned by the identity provider\n     * @return {String} a string that describes the error that occurred\n     * @private\n     */\n\n  }, {\n    key: '$errorDescription',\n    get: function get() {\n      return this.$storage.getItem('salte.auth.error-description');\n    },\n    set: function set(errorDescription) {\n      this.$saveItem('salte.auth.error-description', errorDescription);\n    }\n\n    /**\n     * The url the user originated from before authentication occurred\n     * @return {String} The url the user originated from before authentication occurred\n     * @private\n     */\n\n  }, {\n    key: '$redirectUrl',\n    get: function get() {\n      return this.$storage.getItem('salte.auth.$redirect-url');\n    },\n    set: function set(redirectUrl) {\n      this.$saveItem('salte.auth.$redirect-url', redirectUrl);\n    }\n\n    /**\n     * Parses the User Info from the ID Token\n     * @return {String} The User Info from the ID Token\n     * @private\n     */\n\n  }, {\n    key: '$nonce',\n    get: function get() {\n      return this.$storage.getItem('salte.auth.nonce');\n    },\n    set: function set(nonce) {\n      this.$saveItem('salte.auth.nonce', nonce);\n    }\n\n    /**\n     * Parses the User Info from the ID Token\n     * @return {Object} The User Info from the ID Token\n     */\n\n  }, {\n    key: 'userInfo',\n    get: function get() {\n      if (this.$idToken) {\n        var separatedToken = this.$idToken.split('.');\n        if (separatedToken.length === 3) {\n          return JSON.parse(atob(separatedToken[1]));\n        }\n      }\n      return null;\n    }\n  }, {\n    key: '$storage',\n    get: function get() {\n      return this.$$getStorage(this.$$config.storageType);\n    }\n  }]);\n\n  return SalteAuthProfile;\n}();\n\n(0, _lodash.set)(window, 'salte.SalteAuthProfile', (0, _lodash.get)(window, 'salte.SalteAuthProfile', SalteAuthProfile));\nexports.SalteAuthProfile = SalteAuthProfile;\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SalteAuthUtilities = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _lodash = __webpack_require__(0);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Basic utilities to support the authentication flow\n */\nvar SalteAuthUtilities = function () {\n  /**\n   * Wraps all XHR and Fetch (if available) requests to allow promise interceptors\n   */\n  function SalteAuthUtilities() {\n    _classCallCheck(this, SalteAuthUtilities);\n\n    if (window.salte.SalteAuthUtilities.$instance) {\n      return window.salte.SalteAuthUtilities.$instance;\n    }\n\n    /** @ignore */\n    this.$interceptors = {\n      fetch: [],\n      xhr: []\n    };\n\n    (function (open) {\n      XMLHttpRequest.prototype.open = function (method, url) {\n        /** @ignore */\n        this.$url = url;\n        return open.call(this, method, url);\n      };\n    })(XMLHttpRequest.prototype.open);\n\n    var self = this;\n    (function (send) {\n      XMLHttpRequest.prototype.send = function (data) {\n        var _this = this;\n\n        var promises = [];\n        for (var i = 0; i < self.$interceptors.xhr.length; i++) {\n          var interceptor = self.$interceptors.xhr[i];\n          promises.push(interceptor(this, data));\n        }\n        Promise.all(promises).then(function () {\n          send.call(_this, data);\n        }).catch(function (error) {\n          var event = document.createEvent('Event');\n          event.initEvent('error', false, true);\n          event.detail = error;\n          _this.dispatchEvent(event);\n        });\n      };\n    })(XMLHttpRequest.prototype.send);\n\n    if (window.fetch) {\n      (function (fetch) {\n        window.fetch = function (input) {\n          var _this2 = this;\n\n          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n          var promises = [];\n          for (var i = 0; i < self.$interceptors.fetch.length; i++) {\n            var interceptor = self.$interceptors.fetch[i];\n            promises.push(interceptor(input, options));\n          }\n          return Promise.all(promises).then(function () {\n            return fetch.call(_this2, input, options);\n          });\n        };\n      })(fetch);\n    }\n    window.salte.SalteAuthUtilities.$instance = this;\n  }\n\n  /**\n   * Creates a URL using a base url and a queryParams object\n   * @param {String} baseUrl the base url to attach the queryParams to\n   * @param {Object} queryParams the queryParams to attach to the baseUrl\n   * @return {String} the url with the request queryParams\n   */\n\n\n  _createClass(SalteAuthUtilities, [{\n    key: 'createUrl',\n    value: function createUrl(baseUrl) {\n      var queryParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      var url = baseUrl;\n\n      Object.keys(queryParams).forEach(function (key) {\n        var value = queryParams[key];\n        if ([undefined, null, ''].indexOf(value) === -1) {\n          url += '' + (url.indexOf('?') === -1 ? '?' : '&') + key + '=' + encodeURIComponent(value);\n        }\n      });\n\n      return url;\n    }\n\n    /**\n     * Converts a url to an absolute url\n     * @param {String} path the url path to resolve to an absolute url\n     * @return {String} the absolutely resolved url\n     */\n\n  }, {\n    key: 'resolveUrl',\n    value: function resolveUrl(path) {\n      if (!this.$$urlDocument) {\n        /** @ignore */\n        this.$$urlDocument = document.implementation.createHTMLDocument('url');\n        /** @ignore */\n        this.$$urlBase = this.$$urlDocument.createElement('base');\n        /** @ignore */\n        this.$$urlAnchor = this.$$urlDocument.createElement('a');\n        this.$$urlDocument.head.appendChild(this.$$urlBase);\n      }\n      this.$$urlBase.href = window.location.protocol + '//' + window.location.host;\n      this.$$urlAnchor.href = path.replace(/ /g, '%20');\n      return this.$$urlAnchor.href;\n    }\n\n    /**\n     * Checks if the given url matches any of the test urls\n     * @param {String} url The url to test\n     * @param {Array<String|RegExp>} tests The urls to match the test url against\n     * @return {Boolean} true if the url matches one of the tests\n     */\n\n  }, {\n    key: 'checkForMatchingUrl',\n    value: function checkForMatchingUrl(url) {\n      var tests = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n      var resolvedUrl = this.resolveUrl(url);\n      for (var i = 0; i < tests.length; i++) {\n        var test = tests[i];\n        if (test instanceof RegExp) {\n          return !!resolvedUrl.match(test);\n        } else {\n          return resolvedUrl.indexOf(this.resolveUrl(test)) === 0;\n        }\n      }\n\n      return false;\n    }\n\n    /**\n     * Determines if the given route is a secured route\n     * @param {String} route the route to verify\n     * @param {Boolean|Array<String>} securedRoutes a list of routes that require authentication\n     * @return {Boolean} true if the route provided is a secured route\n     */\n\n  }, {\n    key: 'isRouteSecure',\n    value: function isRouteSecure(route, securedRoutes) {\n      if (securedRoutes === true) {\n        return true;\n      } else if (securedRoutes instanceof Array) {\n        return this.checkForMatchingUrl(route, securedRoutes);\n      }\n      return false;\n    }\n\n    /**\n     * Opens a popup window in the middle of the viewport\n     * @param {String} url the url to be loaded\n     * @param {String} name the name of the window\n     * @param {Number} height the height of the window\n     * @param {Number} width the width of the window\n     * @return {Promise} resolves when the popup is closed\n     */\n\n  }, {\n    key: 'openPopup',\n    value: function openPopup(url) {\n      var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'salte-auth';\n      var height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 600;\n      var width = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 400;\n\n      var top = window.innerHeight / 2 - height / 2 + window.screenTop;\n      var left = window.innerWidth / 2 - width / 2 + window.screenLeft;\n      var popupWindow = window.open(url, name, 'height=' + height + ', width=' + width + ', status=yes, toolbar=no, menubar=no, location=no, top=' + top + ', left=' + left);\n      if (!popupWindow) {\n        return Promise.reject(new ReferenceError('We were unable to open the popup window, its likely that the request was blocked.'));\n      }\n\n      popupWindow.focus();\n      // TODO: Find a better way of tracking when a Popup Window closes.\n      return new Promise(function (resolve) {\n        var checker = setInterval(function () {\n          if (!popupWindow.closed) return;\n          clearInterval(checker);\n          setTimeout(resolve);\n        }, 100);\n      });\n    }\n\n    /**\n     * Opens an iframe in the background\n     * @param {String} url the url to be loaded\n     * @param {Boolean} show whether the iframe should be visible\n     * @return {Promise} resolves when the iframe is closed\n     */\n\n  }, {\n    key: 'createIframe',\n    value: function createIframe(url, show) {\n      var iframe = document.createElement('iframe');\n      iframe.setAttribute('owner', 'salte-auth');\n      if (show) {\n        (0, _lodash.assign)(iframe.style, {\n          position: 'fixed',\n          top: 0,\n          bottom: 0,\n          left: 0,\n          right: 0,\n          height: '100%',\n          width: '100%',\n          zIndex: 9999,\n          border: 'none',\n\n          opacity: 0,\n          transition: '0.5s opacity'\n        });\n\n        setTimeout(function () {\n          iframe.style.opacity = 1;\n        });\n      } else {\n        iframe.style.display = 'none';\n      }\n      iframe.src = url;\n      document.body.appendChild(iframe);\n      return new Promise(function (resolve) {\n        iframe.addEventListener('DOMNodeRemoved', function () {\n          setTimeout(resolve);\n        });\n      });\n    }\n\n    /**\n     * Adds a XMLHttpRequest interceptor\n     * @param {Function} interceptor the interceptor function\n     */\n\n  }, {\n    key: 'addXHRInterceptor',\n    value: function addXHRInterceptor(interceptor) {\n      this.$interceptors.xhr.push(interceptor);\n    }\n\n    /**\n     * Adds a fetch interceptor\n     * @param {Function} interceptor the interceptor function\n     */\n\n  }, {\n    key: 'addFetchInterceptor',\n    value: function addFetchInterceptor(interceptor) {\n      this.$interceptors.fetch.push(interceptor);\n    }\n\n    /**\n     * Checks if the current window is an iframe\n     * @return {HTMLIFrameElement} true if the current window is an iframe.\n     * @private\n     */\n\n  }, {\n    key: '$iframe',\n    get: function get() {\n      if (window.self === window.top) {\n        return null;\n      }\n      return parent.document.querySelector('body > iframe[owner=\"salte-auth\"]');\n    }\n\n    /**\n     * Determines if the current window is a popup window opened by salte auth\n     * @return {Window} the window object\n     * @private\n     */\n\n  }, {\n    key: '$popup',\n    get: function get() {\n      if (window.opener && window.name === 'salte-auth') {\n        return window;\n      }\n      return null;\n    }\n  }]);\n\n  return SalteAuthUtilities;\n}();\n\n(0, _lodash.set)(window, 'salte.SalteAuthUtilities', (0, _lodash.get)(window, 'salte.SalteAuthUtilities', SalteAuthUtilities));\nexports.SalteAuthUtilities = SalteAuthUtilities;\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// salte-auth.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 629ad6e3a854c8bcfa42","module.exports = __WEBPACK_EXTERNAL_MODULE_0__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"root\":\"_\",\"commonjs\":\"lodash\",\"commonjs2\":\"lodash\",\"amd\":\"lodash\"}\n// module id = 0\n// module chunks = 0","// Unique ID creation requires a high quality random # generator.  In the\n// browser this is a little complicated due to unknown quality of Math.random()\n// and inconsistent support for the `crypto` API.  We do the best we can via\n// feature-detection\nvar rng;\n\nvar crypto = global.crypto || global.msCrypto; // for IE 11\nif (crypto && crypto.getRandomValues) {\n  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef\n  rng = function whatwgRNG() {\n    crypto.getRandomValues(rnds8);\n    return rnds8;\n  };\n}\n\nif (!rng) {\n  // Math.random()-based (RNG)\n  //\n  // If all else fails, use Math.random().  It's fast, but is of unspecified\n  // quality.\n  var rnds = new Array(16);\n  rng = function() {\n    for (var i = 0, r; i < 16; i++) {\n      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return rnds;\n  };\n}\n\nmodule.exports = rng;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../node_modules/uuid/lib/rng-browser.js\n// module id = 1\n// module chunks = 0","/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex;\n  return bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]];\n}\n\nmodule.exports = bytesToUuid;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../node_modules/uuid/lib/bytesToUuid.js\n// module id = 2\n// module chunks = 0","import { assign, defaultsDeep, get, set } from 'lodash';\nimport uuid from 'uuid';\n\nimport { Providers } from './salte-auth.providers.js';\nimport { SalteAuthProfile } from './salte-auth.profile.js';\nimport { SalteAuthUtilities } from './salte-auth.utilities.js';\n\n/**\n * Disable certain security validations if your provider doesn't support them.\n * @typedef {Object} Validation\n * @property {Boolean} [nonce=true] Passing false will disable nonce validation, leaving you vulnerable to replay attacks.\n * @property {Boolean} [state=true] Passing false will disable state validation, leaving you vulnerable to XSRF attacks.\n * @property {Boolean} [azp=true] Passing false will disable azp validation.\n * @property {Boolean} [aud=true] Passing false will disable aud validation.\n */\n\n/**\n * The configuration for salte auth\n * @typedef {Object} Config\n * @property {String} providerUrl The base url of your identity provider.\n * @property {('id_token'|'id_token token')} responseType The response type to authenticate with.\n * @property {String} redirectUrl The redirect url specified in your identity provider.\n * @property {String} clientId The client id of your identity provider\n * @property {String} scope A list of space-delimited claims used to determine what user information is provided and what access is given. Most providers require 'openid'.\n * @property {Boolean|Array<String>} routes A list of secured routes. If true is provided then all routes are secured.\n * @property {Array<String|RegExp>} endpoints A list of secured endpoints.\n * @property {('auth0'|'azure'|'cognito'|'wso2')} provider The identity provider you're using.\n * @property {Function} [redirectLoginCallback] A callback that is invoked when a redirect login fails or succeeds.\n * @property {('session'|'local')} [storageType='session'] The Storage api to keep authenticate information stored in.\n * @property {Boolean|Validation} [validation] Used to disable certain security validations if your provider doesn't support them.\n */\n\n/**\n * Authentication Controller\n */\nclass SalteAuth {\n  /**\n   * Sets up Salte Auth\n   * @param {Config} config configuration for salte auth\n   */\n  constructor(config) {\n    if (window.salte.auth) {\n      return window.salte.auth;\n    }\n\n    if (!config) {\n      throw new ReferenceError('A config must be provided.');\n    }\n\n    /**\n     * The supported identity providers\n     * @type {Providers}\n     * @private\n     */\n    this.$providers = Providers;\n    /**\n     * The active authentication promises\n     * @private\n     */\n    this.$promises = {};\n    /**\n     * The configuration for salte auth\n     * @private\n     */\n    this.$config = config;\n    this.$config = defaultsDeep(config, this.$provider.defaultConfig);\n    /**\n     * Various utility functions for salte auth\n     * @type {SalteAuthUtilities}\n     * @private\n     */\n    this.$utilities = new SalteAuthUtilities();\n\n    /**\n     * The user profile for salte auth\n     * @type {SalteAuthProfile}\n     */\n    this.profile = new SalteAuthProfile(this.$config);\n\n    if (this.$utilities.$iframe) {\n      parent.document.body.removeChild(this.$utilities.$iframe);\n    } else if (this.$utilities.$popup) {\n      // We need to utilize local storage to retain our parsed values\n      if (this.$config.storageType === 'session') {\n        this.profile.$$transfer('session', 'local');\n      }\n      setTimeout(this.$utilities.$popup.close);\n    } else if (this.profile.$redirectUrl && location.href !== this.profile.$redirectUrl) {\n      const error = this.profile.$validate();\n      if (error) {\n        this.profile.$clear();\n      } else {\n        location.href = this.profile.$redirectUrl;\n        this.profile.$redirectUrl = undefined;\n      }\n      this.$config.redirectLoginCallback(error);\n    } else {\n      this.$utilities.addXHRInterceptor((request, data) => {\n        if (this.$utilities.checkForMatchingUrl(request.$url, this.$config.endpoints)) {\n          return this.retrieveAccessToken().then((accessToken) => {\n            request.setRequestHeader('Authorization', `Bearer ${accessToken}`);\n          });\n        }\n      });\n\n      this.$utilities.addFetchInterceptor((input, options) => {\n        if (this.$utilities.checkForMatchingUrl(input, this.$config.endpoints)) {\n          return this.retrieveAccessToken().then((accessToken) => {\n            options.headers = options.headers || {};\n            options.headers.Authorization = `Bearer ${accessToken}`;\n          });\n        }\n      });\n\n      window.addEventListener('popstate', this.$$onRouteChanged.bind(this));\n      document.addEventListener('click', this.$$onRouteChanged.bind(this));\n      setTimeout(this.$$onRouteChanged.bind(this));\n    }\n    window.salte.auth = this;\n  }\n\n  /**\n   * Returns the configured provider\n   * @type {Class|Object}\n   * @private\n   */\n  get $provider() {\n    if (!this.$config.provider) {\n      throw new ReferenceError('A provider must be specified');\n    }\n\n    if (typeof this.$config.provider === 'string') {\n      const provider = this.$providers[this.$config.provider];\n      if (!provider) {\n        throw new ReferenceError(`Unknown Provider (${this.$config.provider})`);\n      }\n      return provider;\n    }\n\n    return this.$config.provider;\n  }\n\n  /**\n   * The authentication url to retrieve the access token\n   * @type {String}\n   * @private\n   */\n  get $accessTokenUrl() {\n    this.profile.$localState = uuid.v4();\n    this.profile.$nonce = uuid.v4();\n\n    let authorizeEndpoint = `${this.$config.providerUrl}/authorize`;\n    if (this.$provider.authorizeEndpoint) {\n      authorizeEndpoint = this.$provider.authorizeEndpoint.call(this, this.$config);\n    }\n\n    return this.$utilities.createUrl(authorizeEndpoint, assign({\n      'state': this.profile.$localState,\n      'nonce': this.profile.$nonce,\n      'response_type': 'token',\n      'redirect_uri': this.$config.redirectUrl,\n      'client_id': this.$config.clientId,\n      'scope': this.$config.scope,\n      'prompt': 'none'\n    }, this.$config.queryParams));\n  }\n\n  /**\n   * The authentication url to retrieve the id token\n   * @type {String}\n   * @private\n   */\n  get $loginUrl() {\n    this.profile.$localState = uuid.v4();\n    this.profile.$nonce = uuid.v4();\n\n    let authorizeEndpoint = `${this.$config.providerUrl}/authorize`;\n    if (this.$provider.authorizeEndpoint) {\n      authorizeEndpoint = this.$provider.authorizeEndpoint.call(this, this.$config);\n    }\n\n    return this.$utilities.createUrl(authorizeEndpoint, assign({\n      'state': this.profile.$localState,\n      'nonce': this.profile.$nonce,\n      'response_type': this.$config.responseType,\n      'redirect_uri': this.$config.redirectUrl,\n      'client_id': this.$config.clientId,\n      'scope': this.$config.scope\n    }, this.$config.queryParams));\n  }\n\n  /**\n   * The url to logout of the configured provider\n   * @type {String}\n   * @private\n   */\n  get $deauthorizeUrl() {\n    return this.$provider.deauthorizeUrl.call(this, this.$config);\n  }\n\n  /**\n   * Authenticates using the iframe-based OAuth flow.\n   * @return {Promise} a promise that resolves when we finish authenticating\n   */\n  loginWithIframe() {\n    if (this.$promises.login) {\n      return this.$promises.login;\n    }\n\n    this.profile.$clear();\n    this.$promises.login = this.$utilities.createIframe(this.$loginUrl, true).then(() => {\n      this.$promises.login = null;\n      const error = this.profile.$validate();\n\n      if (error) {\n        this.profile.$clear();\n        return Promise.reject(error);\n      }\n    }).catch((error) => {\n      this.$promises.login = null;\n      return Promise.reject(error);\n    });\n\n    return this.$promises.login;\n  }\n\n  /**\n   * Authenticates using the popup-based OAuth flow.\n   * @return {Promise} a promise that resolves when we finish authenticating\n   */\n  loginWithPopup() {\n    if (this.$promises.login) {\n      return this.$promises.login;\n    }\n\n    this.profile.$clear();\n    this.$promises.login = this.$utilities.openPopup(this.$loginUrl).then(() => {\n      this.$promises.login = null;\n      // We need to utilize local storage to retain our parsed values\n      if (this.$config.storageType === 'session') {\n        this.profile.$$transfer('local', 'session');\n      }\n      const error = this.profile.$validate();\n\n      if (error) {\n        this.profile.$clear();\n        return Promise.reject(error);\n      }\n    }).catch((error) => {\n      this.$promises.login = null;\n      return Promise.reject(error);\n    });\n\n    return this.$promises.login;\n  }\n\n  /**\n   * Authenticates using the redirect-based OAuth flow.\n   */\n  loginWithRedirect() {\n    if (!this.$config.redirectLoginCallback) {\n      throw new ReferenceError('A redirectLoginCallback is required to invoke \"loginWithRedirect\"!');\n    }\n\n    this.profile.$clear();\n    this.profile.$redirectUrl = this.profile.$redirectUrl || location.href;\n    location.href = this.$loginUrl;\n  }\n\n  /**\n   * Unauthenticates using the iframe-based OAuth flow.\n   * @return {Promise} a promise that resolves when we finish deauthenticating\n   */\n  logoutWithIframe() {\n    if (this.$promises.logout) {\n      return this.$promises.logout;\n    }\n\n    this.profile.$clear();\n    this.$promises.logout = this.$utilities.createIframe(this.$deauthorizeUrl).then(() => {\n      this.$promises.logout = null;\n    });\n    return this.$promises.logout;\n  }\n\n  /**\n   * Unauthenticates using the popup-based OAuth flow.\n   * @return {Promise} a promise that resolves when we finish deauthenticating\n   */\n  logoutWithPopup() {\n    if (this.$promises.logout) {\n      return this.$promises.logout;\n    }\n\n    this.profile.$clear();\n    this.$promises.logout = this.$utilities.openPopup(this.$deauthorizeUrl).then(() => {\n      this.$promises.logout = null;\n    });\n\n    return this.$promises.logout;\n  }\n\n  /**\n   * Logs the user out of their configured identity provider.\n   */\n  logoutWithRedirect() {\n    this.profile.$clear();\n    location.href = this.$deauthorizeUrl;\n  }\n\n  /**\n   * Authenticates, requests the access token, and returns it if necessary.\n   * @return {Promise<string>} a promise that resolves when we retrieve the access token\n   */\n  retrieveAccessToken() {\n    if (this.$promises.token) {\n      return this.$promises.token;\n    }\n\n    this.$promises.token = Promise.resolve();\n    if (this.profile.idTokenExpired) {\n      if (this.$config.loginType === 'popup') {\n        this.$promises.token = this.loginWithPopup();\n      } else if ([undefined, null, 'iframe'].indexOf(this.$config.loginType) !== -1) {\n        this.$promises.token = this.loginWithIframe();\n      } else {\n        this.$promises.token = null;\n        return Promise.reject(new ReferenceError(`Invaid Login Type (${this.$config.loginType})`));\n      }\n    }\n\n    this.$promises.token = this.$promises.token.then(() => {\n      this.profile.$clearErrors();\n      if (this.profile.accessTokenExpired) {\n        return this.$utilities.createIframe(this.$accessTokenUrl).then(() => {\n          this.$promises.token = null;\n          const error = this.profile.$validate(true);\n\n          if (error) {\n            return Promise.reject(error);\n          }\n          return this.profile.$accessToken;\n        });\n      }\n      this.$promises.token = null;\n      return this.profile.$accessToken;\n    }).catch((error) => {\n      this.$promises.token = null;\n      return Promise.reject(error);\n    });\n\n    return this.$promises.token;\n  }\n\n  /**\n   * Checks if the current route is secured and authenticates the user if necessary\n   * @ignore\n   */\n  $$onRouteChanged() {\n    if (!this.$utilities.isRouteSecure(location.href, this.$config.routes)) return;\n\n    this.retrieveAccessToken();\n  }\n}\n\nset(window, 'salte.SalteAuth', get(window, 'salte.SalteAuth', SalteAuth));\nexport { SalteAuth };\n\n\n\n// WEBPACK FOOTER //\n// ./salte-auth.js","var v1 = require('./v1');\nvar v4 = require('./v4');\n\nvar uuid = v4;\nuuid.v1 = v1;\nuuid.v4 = v4;\n\nmodule.exports = uuid;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../node_modules/uuid/index.js\n// module id = 5\n// module chunks = 0","var rng = require('./lib/rng');\nvar bytesToUuid = require('./lib/bytesToUuid');\n\n// **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\n// random #'s we need to init node and clockseq\nvar _seedBytes = rng();\n\n// Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\nvar _nodeId = [\n  _seedBytes[0] | 0x01,\n  _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]\n];\n\n// Per 4.2.2, randomize (14 bit) clockseq\nvar _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;\n\n// Previous uuid creation time\nvar _lastMSecs = 0, _lastNSecs = 0;\n\n// See https://github.com/broofa/node-uuid for API details\nfunction v1(options, buf, offset) {\n  var i = buf && offset || 0;\n  var b = buf || [];\n\n  options = options || {};\n\n  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;\n\n  // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();\n\n  // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;\n\n  // Time since last uuid creation (in msecs)\n  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;\n\n  // Per 4.2.1.2, Bump clockseq on clock regression\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  }\n\n  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  }\n\n  // Per 4.2.1.2 Throw error if too many uuids are requested\n  if (nsecs >= 10000) {\n    throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq;\n\n  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n  msecs += 12219292800000;\n\n  // `time_low`\n  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff;\n\n  // `time_mid`\n  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff;\n\n  // `time_high_and_version`\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n  b[i++] = tmh >>> 16 & 0xff;\n\n  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n  b[i++] = clockseq >>> 8 | 0x80;\n\n  // `clock_seq_low`\n  b[i++] = clockseq & 0xff;\n\n  // `node`\n  var node = options.node || _nodeId;\n  for (var n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf ? buf : bytesToUuid(b);\n}\n\nmodule.exports = v1;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../node_modules/uuid/v1.js\n// module id = 6\n// module chunks = 0","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../node_modules/webpack/buildin/global.js\n// module id = 7\n// module chunks = 0","var rng = require('./lib/rng');\nvar bytesToUuid = require('./lib/bytesToUuid');\n\nfunction v4(options, buf, offset) {\n  var i = buf && offset || 0;\n\n  if (typeof(options) == 'string') {\n    buf = options == 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || bytesToUuid(rnds);\n}\n\nmodule.exports = v4;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../node_modules/uuid/v4.js\n// module id = 8\n// module chunks = 0","import auth0 from './providers/auth0.js';\nimport azure from './providers/azure.js';\nimport cognito from './providers/cognito.js';\nimport wso2 from './providers/wso2.js';\n\n/**\n * A collection of overrides for specific Identity Providers\n */\nclass Providers {\n  /**\n   * Provider for Auth0\n   * @type {SalteAuthAuth0Provider}\n   */\n  static get auth0() {\n    return auth0;\n  }\n\n  /**\n   * Provider for Azure's Active Directory\n   * @type {SalteAuthAzureProvider}\n   */\n  static get azure() {\n    return azure;\n  }\n\n  /**\n   * Provider for Amazon's Cognito\n   * @type {SalteAuthCognitoProvider}\n   */\n  static get cognito() {\n    return cognito;\n  }\n\n  /**\n   * Provider for WSO2's API Gateway\n   * @type {SalteAuthWSO2Provider}\n   */\n  static get wso2() {\n    return wso2;\n  }\n};\n\nexport { Providers };\n\n\n\n// WEBPACK FOOTER //\n// ./salte-auth.providers.js","/**\n * Provider for Auth0\n * @see https://auth0.com\n */\nclass SalteAuthAuth0Provider {\n  /**\n   * Computes the deauthorization url\n   * @param {Config} config configuration for salte auth\n   * @return {String} the deauthorization url\n   */\n  static deauthorizeUrl(config) {\n    return this.$utilities.createUrl(`${config.providerUrl}/v2/logout`, {\n      returnTo: config.redirectUrl,\n      client_id: config.clientId\n    });\n  }\n}\n\nexport default SalteAuthAuth0Provider;\n\n\n\n// WEBPACK FOOTER //\n// ./providers/auth0.js","/** Provider for Azure's Active Directory */\nclass SalteAuthAzureProvider {\n  /**\n   * Computes the authorization endpoint\n   * @param {Config} config configuration for salte auth\n   * @return {String} the authorization endpoint\n   */\n  static authorizeEndpoint(config) {\n    return `${config.providerUrl}/oauth2/authorize`;\n  }\n\n  /**\n   * Computes the deauthorization url\n   * @param {Config} config configuration for salte auth\n   * @return {String} the deauthorization url\n   */\n  static deauthorizeUrl(config) {\n    return this.$utilities.createUrl(`${config.providerUrl}/oauth2/logout`, {\n      post_logout_redirect_uri: config.redirectUrl\n    });\n  }\n}\n\nexport default SalteAuthAzureProvider;\n\n\n\n// WEBPACK FOOTER //\n// ./providers/azure.js","/** Provider for Amazon's Cognito */\nclass SalteAuthCognitoProvider {\n  /**\n   * Computes the authorization endpoint\n   * @param {Config} config configuration for salte auth\n   * @return {String} the authorization endpoint\n   */\n  static authorizeEndpoint(config) {\n    return `${config.providerUrl}/oauth2/authorize`;\n  }\n\n  /**\n   * Computes the deauthorization url\n   * @param {Config} config configuration for salte auth\n   * @return {String} the deauthorization url\n   */\n  static deauthorizeUrl(config) {\n    return this.$utilities.createUrl(`${config.providerUrl}/logout`, {\n      logout_uri: config.redirectUrl,\n      client_id: config.clientId\n    });\n  }\n\n  /**\n   * Provides a set of default config options required for cognito\n   */\n  static get defaultConfig() {\n    return {\n      validation: {\n        // Amazon Cognito doesn't support nonce validation\n        nonce: false\n      }\n    };\n  }\n}\n\nexport default SalteAuthCognitoProvider;\n\n\n\n// WEBPACK FOOTER //\n// ./providers/cognito.js","/** Provider for WSO2's API Gateway */\nclass SalteAuthWSO2Provider {\n  /**\n   * Computes the deauthorization url\n   * @param {Config} config configuration for salte auth\n   * @return {String} the deauthorization url\n   */\n  static deauthorizeUrl(config) {\n    return this.$utilities.createUrl(`${config.providerUrl}/commonauth`, {\n      commonAuthLogout: true,\n      type: 'oidc',\n      commonAuthCallerPath: config.redirectUrl,\n      relyingParty: config.relyingParty\n    });\n  }\n}\n\nexport default SalteAuthWSO2Provider;\n\n\n\n// WEBPACK FOOTER //\n// ./providers/wso2.js","import { defaultsDeep, find, get, set } from 'lodash';\n\n/**\n * All the profile information associated with the current authentication session\n */\nclass SalteAuthProfile {\n  /**\n   * Parses the current url for the authentication values\n   * @param {Config} config configuration for salte auth\n   */\n  constructor(config) {\n    if (window.salte.SalteAuthProfile.$instance) {\n      return window.salte.SalteAuthProfile.$instance;\n    }\n    /** @ignore */\n    this.$$config = defaultsDeep(config, {\n      validation: {\n        nonce: true,\n        state: true,\n        azp: true,\n        aud: true\n      },\n      storageType: 'session'\n    });\n    if (location.hash) {\n      const params = location.hash.replace(/(#!?[^#]+)?#/, '').split('&');\n      for (let i = 0; i < params.length; i++) {\n        const param = params[i];\n        const [key, value] = param.split('=');\n        this.$parse(key, decodeURIComponent(value));\n      }\n    }\n    window.salte.SalteAuthProfile.$instance = this;\n  }\n\n  /**\n   * Parse a key-value pair\n   * @param {String} key the key to parse\n   * @param {Object} value the matching value to parse\n   * @private\n   */\n  $parse(key, value) {\n    switch (key) {\n      case 'token_type':\n        this.$tokenType = value;\n        break;\n      case 'expires_in':\n        this.$expiration = Date.now() + value;\n        break;\n      case 'access_token':\n        this.$accessToken = value;\n        break;\n      case 'id_token':\n        this.$idToken = value;\n        break;\n      case 'state':\n        this.$state = value;\n        break;\n      case 'error':\n        this.$error = value;\n        break;\n      case 'error_description':\n        this.$errorDescription = value;\n        break;\n    }\n  }\n\n  /**\n   * Whether the ID Token has expired\n   * @return {Boolean} true if the \"id_token\" has expired\n   */\n  get idTokenExpired() {\n    return !this.$idToken || Date.now() >= (this.userInfo.exp * 1000);\n  }\n\n  /**\n   * Whether the Access Token has expired\n   * @return {Boolean} true if the \"access_token\" has expired\n   */\n  get accessTokenExpired() {\n    return !this.$accessToken || Date.now() >= this.$expiration;\n  }\n\n  /**\n   * The type of Access Token that was returned by the identity provider\n   * @return {String} the type of access token\n   * @private\n   */\n  get $tokenType() {\n    return this.$storage.getItem('salte.auth.token-type');\n  }\n\n  set $tokenType(tokenType) {\n    this.$saveItem('salte.auth.token-type', tokenType);\n  }\n\n  /**\n   * The date and time that the access token will expire\n   * @return {String} the expiration time as unix timestamp\n   * @private\n   */\n  get $expiration() {\n    return this.$storage.getItem('salte.auth.expiration');\n  }\n\n  set $expiration(expiration) {\n    this.$saveItem('salte.auth.expiration', expiration);\n  }\n\n  /**\n   * The Access Token returned by the identity provider\n   * @return {String} the access token\n   * @private\n   */\n  get $accessToken() {\n    return this.$storage.getItem('salte.auth.access-token');\n  }\n\n  set $accessToken(accessToken) {\n    this.$saveItem('salte.auth.access-token', accessToken);\n  }\n\n  /**\n   * The ID Token returned by the identity provider\n   * @return {String} the id token\n   * @private\n   */\n  get $idToken() {\n    return this.$storage.getItem('salte.auth.id-token');\n  }\n\n  set $idToken(idToken) {\n    this.$saveItem('salte.auth.id-token', idToken);\n  }\n\n  /**\n   * The authentication state returned by the identity provider\n   * @return {String} the state value\n   * @private\n   *\n   * @see https://tools.ietf.org/html/rfc6749#section-4.1.1\n   */\n  get $state() {\n    return this.$storage.getItem('salte.auth.state');\n  }\n\n  set $state(state) {\n    this.$saveItem('salte.auth.state', state);\n  }\n\n  /**\n   * The locally generate authentication state\n   * @return {String} the local state value\n   * @private\n   *\n   * @see https://tools.ietf.org/html/rfc6749#section-4.1.1\n   */\n  get $localState() {\n    return this.$storage.getItem('salte.auth.local-state');\n  }\n\n  set $localState(localState) {\n    this.$saveItem('salte.auth.local-state', localState);\n  }\n\n  /**\n   * The error returned by the identity provider\n   * @return {String} the state value\n   * @private\n   */\n  get $error() {\n    return this.$storage.getItem('salte.auth.error');\n  }\n\n  set $error(error) {\n    this.$saveItem('salte.auth.error', error);\n  }\n\n  /**\n   * The error description returned by the identity provider\n   * @return {String} a string that describes the error that occurred\n   * @private\n   */\n  get $errorDescription() {\n    return this.$storage.getItem('salte.auth.error-description');\n  }\n\n  set $errorDescription(errorDescription) {\n    this.$saveItem('salte.auth.error-description', errorDescription);\n  }\n\n  /**\n   * The url the user originated from before authentication occurred\n   * @return {String} The url the user originated from before authentication occurred\n   * @private\n   */\n  get $redirectUrl() {\n    return this.$storage.getItem('salte.auth.$redirect-url');\n  }\n\n  set $redirectUrl(redirectUrl) {\n    this.$saveItem('salte.auth.$redirect-url', redirectUrl);\n  }\n\n  /**\n   * Parses the User Info from the ID Token\n   * @return {String} The User Info from the ID Token\n   * @private\n   */\n  get $nonce() {\n    return this.$storage.getItem('salte.auth.nonce');\n  }\n\n  set $nonce(nonce) {\n    this.$saveItem('salte.auth.nonce', nonce);\n  }\n\n  /**\n   * Parses the User Info from the ID Token\n   * @return {Object} The User Info from the ID Token\n   */\n  get userInfo() {\n    if (this.$idToken) {\n      const separatedToken = this.$idToken.split('.');\n      if (separatedToken.length === 3) {\n        return JSON.parse(atob(separatedToken[1]));\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Verifies that we were logged in successfully and that all security checks pass\n   * @param {Boolean} accessTokenRequest if the request we're validating was an access token request\n   * @return {Object} the error message\n   * @private\n   */\n  $validate(accessTokenRequest) {\n    if (!this.$$config.validation) {\n      return;\n    }\n\n    if (this.$error) {\n      return {\n        code: this.$error,\n        description: this.$errorDescription\n      };\n    }\n\n    if (!this.$idToken) {\n      return {\n        code: 'login_canceled',\n        description: 'User likely canceled the login or something unexpected occurred.'\n      };\n    }\n\n    if (this.$$config.validation.state && this.$localState !== this.$state) {\n      return {\n        code: 'invalid_state',\n        description: 'State provided by identity provider did not match local state.'\n      };\n    }\n\n    if (accessTokenRequest) return;\n\n    if (this.$$config.validation.nonce && this.$nonce !== this.userInfo.nonce) {\n      return {\n        code: 'invalid_nonce',\n        description: 'Nonce provided by identity provider did not match local nonce.'\n      };\n    }\n\n    if (Array.isArray(this.userInfo.aud)) {\n      if (this.$$config.validation.azp) {\n        if (!this.userInfo.azp) {\n          return {\n            code: 'invalid_azp',\n            description: 'Audience was returned as an array and AZP was not present on the ID Token.'\n          };\n        }\n\n        if (this.userInfo.azp !== this.$$config.clientId) {\n          return {\n            code: 'invalid_azp',\n            description: 'AZP does not match the Client ID.'\n          };\n        }\n      }\n\n\n      if (this.$$config.validation.aud) {\n        const aud = find(this.userInfo.aud, (audience) => {\n          return audience === this.$$config.clientId;\n        });\n\n        if (!aud) {\n          return {\n            code: 'invalid_aud',\n            description: 'None of the audience values matched the Client ID.'\n          };\n        }\n      }\n    } else if (this.$$config.validation.aud && this.userInfo.aud !== this.$$config.clientId) {\n      return {\n        code: 'invalid_aud',\n        description: 'The audience did not match the Client ID.'\n      };\n    }\n  }\n\n  /**\n   * Saves a value to the Web Storage API\n   * @param {String} key The key to save to\n   * @param {*} value The value to save, if this is undefined or null it will delete the key\n   * @private\n   */\n  $saveItem(key, value) {\n    if ([undefined, null].indexOf(value) !== -1) {\n      this.$storage.removeItem(key);\n    } else {\n      this.$storage.setItem(key, value);\n    }\n  }\n\n  /**\n   * Return the active Web Storage API\n   * @return {Storage} the storage api to save and pull values from\n   * @private\n   */\n  get $storage() {\n    return this.$$getStorage(this.$$config.storageType);\n  }\n\n  /**\n   * Determines which Web Storage API to return using the name provided\n   * @param {String} storageType the name of the storageType to use\n   * @return {Storage} the web storage api that matches the given string\n   * @ignore\n   */\n  $$getStorage(storageType) {\n    if (storageType === 'local') {\n      return localStorage;\n    } else if (storageType === 'session') {\n      return sessionStorage;\n    } else {\n      throw new ReferenceError(`Unknown Storage Type (${storageType})`);\n    }\n  }\n\n  /**\n   * Transfers values from one storage type to the other\n   * @param {String} source the name of the storage type to pull from\n   * @param {String} destination the name of the storage type to push to\n   * @ignore\n   */\n  $$transfer(source, destination) {\n    const sourceStorage = this.$$getStorage(source);\n    const destinationStorage = this.$$getStorage(destination);\n\n    for (const key in sourceStorage) {\n      if (key.indexOf('salte.auth.') !== 0) continue;\n\n      destinationStorage.setItem(key, sourceStorage.getItem(key));\n      sourceStorage.removeItem(key);\n    }\n  }\n\n  /**\n   * Clears all `salte.auth` values from localStorage\n   * @private\n   */\n  $clear() {\n    for (const key in this.$storage) {\n      if (key.match(/^salte\\.auth\\.[^$]/)) {\n        this.$saveItem(key, undefined);\n      }\n    }\n  }\n\n  /**\n   * Clears all `salte.auth` error values from localStorage\n   * @private\n   */\n  $clearErrors() {\n    this.$error = undefined;\n    this.$errorDescription = undefined;\n  }\n}\n\nset(window, 'salte.SalteAuthProfile', get(window, 'salte.SalteAuthProfile', SalteAuthProfile));\nexport { SalteAuthProfile };\n\n\n\n// WEBPACK FOOTER //\n// ./salte-auth.profile.js","import { assign, get, set } from 'lodash';\n\n/**\n * Basic utilities to support the authentication flow\n */\nclass SalteAuthUtilities {\n  /**\n   * Wraps all XHR and Fetch (if available) requests to allow promise interceptors\n   */\n  constructor() {\n    if (window.salte.SalteAuthUtilities.$instance) {\n      return window.salte.SalteAuthUtilities.$instance;\n    }\n\n    /** @ignore */\n    this.$interceptors = {\n      fetch: [],\n      xhr: []\n    };\n\n    (function(open) {\n      XMLHttpRequest.prototype.open = function(method, url) {\n        /** @ignore */\n        this.$url = url;\n        return open.call(this, method, url);\n      };\n    })(XMLHttpRequest.prototype.open);\n\n    const self = this;\n    (function(send) {\n      XMLHttpRequest.prototype.send = function(data) {\n        const promises = [];\n        for (let i = 0; i < self.$interceptors.xhr.length; i++) {\n          const interceptor = self.$interceptors.xhr[i];\n          promises.push(interceptor(this, data));\n        }\n        Promise.all(promises).then(() => {\n          send.call(this, data);\n        }).catch((error) => {\n          const event = document.createEvent('Event');\n          event.initEvent('error', false, true);\n          event.detail = error;\n          this.dispatchEvent(event);\n        });\n      };\n    })(XMLHttpRequest.prototype.send);\n\n    if (window.fetch) {\n      (function(fetch) {\n        window.fetch = function(input, options = {}) {\n          const promises = [];\n          for (let i = 0; i < self.$interceptors.fetch.length; i++) {\n            const interceptor = self.$interceptors.fetch[i];\n            promises.push(interceptor(input, options));\n          }\n          return Promise.all(promises).then(() => {\n            return fetch.call(this, input, options);\n          });\n        };\n      })(fetch);\n    }\n    window.salte.SalteAuthUtilities.$instance = this;\n  }\n\n  /**\n   * Creates a URL using a base url and a queryParams object\n   * @param {String} baseUrl the base url to attach the queryParams to\n   * @param {Object} queryParams the queryParams to attach to the baseUrl\n   * @return {String} the url with the request queryParams\n   */\n  createUrl(baseUrl, queryParams = {}) {\n    let url = baseUrl;\n\n    Object.keys(queryParams).forEach((key) => {\n      const value = queryParams[key];\n      if ([undefined, null, ''].indexOf(value) === -1) {\n        url += `${url.indexOf('?') === -1 ? '?' : '&'}${key}=${encodeURIComponent(value)}`;\n      }\n    });\n\n    return url;\n  }\n\n  /**\n   * Converts a url to an absolute url\n   * @param {String} path the url path to resolve to an absolute url\n   * @return {String} the absolutely resolved url\n   */\n  resolveUrl(path) {\n    if (!this.$$urlDocument) {\n      /** @ignore */\n      this.$$urlDocument = document.implementation.createHTMLDocument('url');\n      /** @ignore */\n      this.$$urlBase = this.$$urlDocument.createElement('base');\n      /** @ignore */\n      this.$$urlAnchor = this.$$urlDocument.createElement('a');\n      this.$$urlDocument.head.appendChild(this.$$urlBase);\n    }\n    this.$$urlBase.href = window.location.protocol + '//' + window.location.host;\n    this.$$urlAnchor.href = path.replace(/ /g, '%20');\n    return this.$$urlAnchor.href;\n  }\n\n  /**\n   * Checks if the given url matches any of the test urls\n   * @param {String} url The url to test\n   * @param {Array<String|RegExp>} tests The urls to match the test url against\n   * @return {Boolean} true if the url matches one of the tests\n   */\n  checkForMatchingUrl(url, tests = []) {\n    const resolvedUrl = this.resolveUrl(url);\n    for (let i = 0; i < tests.length; i++) {\n      const test = tests[i];\n      if (test instanceof RegExp) {\n        return !!resolvedUrl.match(test);\n      } else {\n        return resolvedUrl.indexOf(this.resolveUrl(test)) === 0;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Determines if the given route is a secured route\n   * @param {String} route the route to verify\n   * @param {Boolean|Array<String>} securedRoutes a list of routes that require authentication\n   * @return {Boolean} true if the route provided is a secured route\n   */\n  isRouteSecure(route, securedRoutes) {\n    if (securedRoutes === true) {\n      return true;\n    } else if (securedRoutes instanceof Array) {\n      return this.checkForMatchingUrl(route, securedRoutes);\n    }\n    return false;\n  }\n\n  /**\n   * Opens a popup window in the middle of the viewport\n   * @param {String} url the url to be loaded\n   * @param {String} name the name of the window\n   * @param {Number} height the height of the window\n   * @param {Number} width the width of the window\n   * @return {Promise} resolves when the popup is closed\n   */\n  openPopup(url, name = 'salte-auth', height = 600, width = 400) {\n    const top = ((window.innerHeight / 2) - (height / 2)) + window.screenTop;\n    const left = ((window.innerWidth / 2) - (width / 2)) + window.screenLeft;\n    const popupWindow = window.open(url, name, `height=${height}, width=${width}, status=yes, toolbar=no, menubar=no, location=no, top=${top}, left=${left}`);\n    if (!popupWindow) {\n      return Promise.reject(new ReferenceError('We were unable to open the popup window, its likely that the request was blocked.'));\n    }\n\n    popupWindow.focus();\n    // TODO: Find a better way of tracking when a Popup Window closes.\n    return new Promise((resolve) => {\n      const checker = setInterval(() => {\n        if (!popupWindow.closed) return;\n        clearInterval(checker);\n        setTimeout(resolve);\n      }, 100);\n    });\n  }\n\n  /**\n   * Opens an iframe in the background\n   * @param {String} url the url to be loaded\n   * @param {Boolean} show whether the iframe should be visible\n   * @return {Promise} resolves when the iframe is closed\n   */\n  createIframe(url, show) {\n    const iframe = document.createElement('iframe');\n    iframe.setAttribute('owner', 'salte-auth');\n    if (show) {\n      assign(iframe.style, {\n        position: 'fixed',\n        top: 0,\n        bottom: 0,\n        left: 0,\n        right: 0,\n        height: '100%',\n        width: '100%',\n        zIndex: 9999,\n        border: 'none',\n\n        opacity: 0,\n        transition: '0.5s opacity'\n      });\n\n      setTimeout(() => {\n        iframe.style.opacity = 1;\n      });\n    } else {\n      iframe.style.display = 'none';\n    }\n    iframe.src = url;\n    document.body.appendChild(iframe);\n    return new Promise((resolve) => {\n      iframe.addEventListener('DOMNodeRemoved', () => {\n        setTimeout(resolve);\n      });\n    });\n  }\n\n  /**\n   * Adds a XMLHttpRequest interceptor\n   * @param {Function} interceptor the interceptor function\n   */\n  addXHRInterceptor(interceptor) {\n    this.$interceptors.xhr.push(interceptor);\n  }\n\n  /**\n   * Adds a fetch interceptor\n   * @param {Function} interceptor the interceptor function\n   */\n  addFetchInterceptor(interceptor) {\n    this.$interceptors.fetch.push(interceptor);\n  }\n\n  /**\n   * Checks if the current window is an iframe\n   * @return {HTMLIFrameElement} true if the current window is an iframe.\n   * @private\n   */\n  get $iframe() {\n    if (window.self === window.top) {\n      return null;\n    }\n    return parent.document.querySelector('body > iframe[owner=\"salte-auth\"]');\n  }\n\n  /**\n   * Determines if the current window is a popup window opened by salte auth\n   * @return {Window} the window object\n   * @private\n   */\n  get $popup() {\n    if (window.opener && window.name === 'salte-auth') {\n      return window;\n    }\n    return null;\n  }\n}\n\nset(window, 'salte.SalteAuthUtilities', get(window, 'salte.SalteAuthUtilities', SalteAuthUtilities));\nexport { SalteAuthUtilities };\n\n\n\n// WEBPACK FOOTER //\n// ./salte-auth.utilities.js"],"sourceRoot":""}