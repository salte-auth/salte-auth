{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///salte-auth.min.js","webpack:///webpack/bootstrap 9630a714b1c1ef4c4013","webpack:///external {\"root\":\"_\",\"commonjs\":\"lodash\",\"commonjs2\":\"lodash\",\"amd\":\"lodash\"}","webpack:///../node_modules/uuid/lib/rng-browser.js","webpack:///../node_modules/uuid/lib/bytesToUuid.js","webpack:///./salte-auth.js","webpack:///../node_modules/uuid/index.js","webpack:///../node_modules/uuid/v1.js","webpack:///../node_modules/uuid/v4.js","webpack:///./salte-auth.providers.js","webpack:///./providers/auth0.js","webpack:///./providers/azure.js","webpack:///./providers/cognito.js","webpack:///./providers/wso2.js","webpack:///./salte-auth.profile.js","webpack:///./salte-auth.utilities.js"],"names":["root","factory","exports","module","require","define","amd","self","this","__WEBPACK_EXTERNAL_MODULE_0__","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","getRandomValues","crypto","bind","msCrypto","rnds8","Uint8Array","rnds","Array","r","Math","random","bytesToUuid","buf","offset","bth","byteToHex","toString","substr","_classCallCheck","instance","Constructor","TypeError","value","SalteAuth","undefined","_createClass","defineProperties","target","props","length","descriptor","writable","key","protoProps","staticProps","_lodash","_uuid","_uuid2","obj","default","_salteAuthProviders","_salteAuthProfile","_salteAuthUtilities","config","_this","window","salte","auth","ReferenceError","$providers","Providers","$promises","$config","defaultsDeep","$provider","defaultConfig","$utilities","SalteAuthUtilities","profile","SalteAuthProfile","$iframe","parent","document","body","removeChild","$popup","storageType","$$transfer","setTimeout","close","$redirectUrl","location","href","error","$validate","$clear","redirectLoginCallback","addXHRInterceptor","request","data","checkForMatchingUrl","$url","endpoints","retrieveAccessToken","then","accessToken","setRequestHeader","addFetchInterceptor","input","options","headers","Authorization","addEventListener","$$onRouteChanged","_this2","login","createIframe","$loginUrl","Promise","reject","catch","_this3","openPopup","_this4","logout","$deauthorizeUrl","_this5","_this6","token","resolve","idTokenExpired","loginType","loginWithPopup","indexOf","loginWithIframe","$clearErrors","accessTokenExpired","$accessTokenUrl","$accessToken","isRouteSecure","routes","provider","$localState","v4","$nonce","authorizeEndpoint","providerUrl","createUrl","assign","state","nonce","response_type","redirect_uri","redirectUrl","client_id","clientId","scope","prompt","queryParams","responseType","deauthorizeUrl","set","v1","uuid","b","node","_nodeId","clockseq","_clockseq","seedBytes","rng","msecs","Date","getTime","nsecs","_lastNSecs","dt","_lastMSecs","Error","tl","tmh","ii","_interopRequireDefault","_auth","_auth2","_azure","_azure2","_cognito","_cognito2","_wso","_wso2","SalteAuthAuth0Provider","returnTo","SalteAuthAzureProvider","post_logout_redirect_uri","SalteAuthCognitoProvider","logout_uri","validation","SalteAuthWSO2Provider","commonAuthLogout","type","commonAuthCallerPath","relyingParty","_slicedToArray","sliceIterator","arr","_arr","_n","_d","_e","_s","_i","Symbol","iterator","next","done","push","err","isArray","$instance","$$config","azp","aud","hash","params","replace","split","param","_param$split","_param$split2","$parse","decodeURIComponent","$tokenType","$expiration","now","$idToken","$state","$error","$errorDescription","accessTokenRequest","code","description","userInfo","find","audience","$storage","removeItem","setItem","localStorage","sessionStorage","source","destination","sourceStorage","$$getStorage","destinationStorage","getItem","match","$saveItem","exp","tokenType","expiration","idToken","localState","errorDescription","separatedToken","JSON","parse","atob","$interceptors","fetch","xhr","open","XMLHttpRequest","method","url","send","promises","interceptor","all","event","createEvent","initEvent","detail","dispatchEvent","arguments","baseUrl","keys","forEach","encodeURIComponent","path","$$urlDocument","implementation","createHTMLDocument","$$urlBase","createElement","$$urlAnchor","head","appendChild","protocol","host","tests","resolvedUrl","resolveUrl","test","RegExp","route","securedRoutes","height","width","top","innerHeight","screenTop","left","innerWidth","screenLeft","popupWindow","focus","checker","setInterval","closed","clearInterval","show","iframe","setAttribute","style","position","bottom","right","zIndex","border","opacity","transition","display","src","querySelector","opener"],"mappings":"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","file":"salte-auth.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"lodash\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"salte.auth\", [\"lodash\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"salte.auth\"] = factory(require(\"lodash\"));\n\telse\n\t\troot[\"salte.auth\"] = factory(root[\"_\"]);\n})(typeof self !== 'undefined' ? self : this, function(__WEBPACK_EXTERNAL_MODULE_0__) {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","/**\n * @salte-io/salte-auth JavaScript Library v2.0.3\n *\n * @license MIT (https://github.com/salte-io/salte-auth/blob/master/LICENSE)\n *\n * Made with â™¥ by Nick Woodward <nick@salte.io>, Dave Woodward <dave@salte.io>\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"lodash\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"salte.auth\", [\"lodash\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"salte.auth\"] = factory(require(\"lodash\"));\n\telse\n\t\troot[\"salte.auth\"] = factory(root[\"_\"]);\n})(typeof self !== 'undefined' ? self : this, function(__WEBPACK_EXTERNAL_MODULE_0__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 3);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports) {\n\nmodule.exports = __WEBPACK_EXTERNAL_MODULE_0__;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\n// Unique ID creation requires a high quality random # generator.  In the\n// browser this is a little complicated due to unknown quality of Math.random()\n// and inconsistent support for the `crypto` API.  We do the best we can via\n// feature-detection\n\n// getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation.\nvar getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues.bind(crypto)) ||\n                      (typeof(msCrypto) != 'undefined' && msCrypto.getRandomValues.bind(msCrypto));\nif (getRandomValues) {\n  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef\n\n  module.exports = function whatwgRNG() {\n    getRandomValues(rnds8);\n    return rnds8;\n  };\n} else {\n  // Math.random()-based (RNG)\n  //\n  // If all else fails, use Math.random().  It's fast, but is of unspecified\n  // quality.\n  var rnds = new Array(16);\n\n  module.exports = function mathRNG() {\n    for (var i = 0, r; i < 16; i++) {\n      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return rnds;\n  };\n}\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports) {\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex;\n  return bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]];\n}\n\nmodule.exports = bytesToUuid;\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(4);\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SalteAuth = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _lodash = __webpack_require__(0);\n\nvar _uuid = __webpack_require__(5);\n\nvar _uuid2 = _interopRequireDefault(_uuid);\n\nvar _salteAuthProviders = __webpack_require__(8);\n\nvar _salteAuthProfile = __webpack_require__(13);\n\nvar _salteAuthUtilities = __webpack_require__(14);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Disable certain security validations if your provider doesn't support them.\n * @typedef {Object} Validation\n * @property {Boolean} [nonce=true] Passing false will disable nonce validation, leaving you vulnerable to replay attacks.\n * @property {Boolean} [state=true] Passing false will disable state validation, leaving you vulnerable to XSRF attacks.\n * @property {Boolean} [azp=true] Passing false will disable azp validation.\n * @property {Boolean} [aud=true] Passing false will disable aud validation.\n */\n\n/**\n * The configuration for salte auth\n * @typedef {Object} Config\n * @property {String} providerUrl The base url of your identity provider.\n * @property {('id_token'|'id_token token')} responseType The response type to authenticate with.\n * @property {String} redirectUrl The redirect url specified in your identity provider.\n * @property {String} clientId The client id of your identity provider\n * @property {String} scope A list of space-delimited claims used to determine what user information is provided and what access is given. Most providers require 'openid'.\n * @property {Boolean|Array<String>} routes A list of secured routes. If true is provided then all routes are secured.\n * @property {Array<String|RegExp>} endpoints A list of secured endpoints.\n * @property {('auth0'|'azure'|'cognito'|'wso2')} provider The identity provider you're using.\n * @property {Function} [redirectLoginCallback] A callback that is invoked when a redirect login fails or succeeds.\n * @property {('session'|'local')} [storageType='session'] The Storage api to keep authenticate information stored in.\n * @property {Boolean|Validation} [validation] Used to disable certain security validations if your provider doesn't support them.\n */\n\n/**\n * Authentication Controller\n */\nvar SalteAuth = function () {\n  /**\n   * Sets up Salte Auth\n   * @param {Config} config configuration for salte auth\n   */\n  function SalteAuth(config) {\n    var _this = this;\n\n    _classCallCheck(this, SalteAuth);\n\n    if (window.salte.auth) {\n      return window.salte.auth;\n    }\n\n    if (!config) {\n      throw new ReferenceError('A config must be provided.');\n    }\n\n    /**\n     * The supported identity providers\n     * @type {Providers}\n     * @private\n     */\n    this.$providers = _salteAuthProviders.Providers;\n    /**\n     * The active authentication promises\n     * @private\n     */\n    this.$promises = {};\n    /**\n     * The configuration for salte auth\n     * @private\n     */\n    this.$config = config;\n    this.$config = (0, _lodash.defaultsDeep)(config, this.$provider.defaultConfig);\n    /**\n     * Various utility functions for salte auth\n     * @type {SalteAuthUtilities}\n     * @private\n     */\n    this.$utilities = new _salteAuthUtilities.SalteAuthUtilities();\n\n    /**\n     * The user profile for salte auth\n     * @type {SalteAuthProfile}\n     */\n    this.profile = new _salteAuthProfile.SalteAuthProfile(this.$config);\n\n    if (this.$utilities.$iframe) {\n      parent.document.body.removeChild(this.$utilities.$iframe);\n    } else if (this.$utilities.$popup) {\n      // We need to utilize local storage to retain our parsed values\n      if (this.$config.storageType === 'session') {\n        this.profile.$$transfer('session', 'local');\n      }\n      setTimeout(this.$utilities.$popup.close);\n    } else if (this.profile.$redirectUrl && location.href !== this.profile.$redirectUrl) {\n      var error = this.profile.$validate();\n      if (error) {\n        this.profile.$clear();\n      } else {\n        location.href = this.profile.$redirectUrl;\n        this.profile.$redirectUrl = undefined;\n      }\n      this.$config.redirectLoginCallback(error);\n    } else {\n      this.$utilities.addXHRInterceptor(function (request, data) {\n        if (_this.$utilities.checkForMatchingUrl(request.$url, _this.$config.endpoints)) {\n          return _this.retrieveAccessToken().then(function (accessToken) {\n            request.setRequestHeader('Authorization', 'Bearer ' + accessToken);\n          });\n        }\n      });\n\n      this.$utilities.addFetchInterceptor(function (input, options) {\n        if (_this.$utilities.checkForMatchingUrl(input, _this.$config.endpoints)) {\n          return _this.retrieveAccessToken().then(function (accessToken) {\n            options.headers = options.headers || {};\n            options.headers.Authorization = 'Bearer ' + accessToken;\n          });\n        }\n      });\n\n      window.addEventListener('popstate', this.$$onRouteChanged.bind(this));\n      document.addEventListener('click', this.$$onRouteChanged.bind(this));\n      setTimeout(this.$$onRouteChanged.bind(this));\n    }\n    window.salte.auth = this;\n  }\n\n  /**\n   * Returns the configured provider\n   * @type {Class|Object}\n   * @private\n   */\n\n\n  _createClass(SalteAuth, [{\n    key: 'loginWithIframe',\n\n\n    /**\n     * Authenticates using the iframe-based OAuth flow.\n     * @return {Promise} a promise that resolves when we finish authenticating\n     */\n    value: function loginWithIframe() {\n      var _this2 = this;\n\n      if (this.$promises.login) {\n        return this.$promises.login;\n      }\n\n      this.profile.$clear();\n      this.$promises.login = this.$utilities.createIframe(this.$loginUrl, true).then(function () {\n        _this2.$promises.login = null;\n        var error = _this2.profile.$validate();\n\n        if (error) {\n          _this2.profile.$clear();\n          return Promise.reject(error);\n        }\n      }).catch(function (error) {\n        _this2.$promises.login = null;\n        return Promise.reject(error);\n      });\n\n      return this.$promises.login;\n    }\n\n    /**\n     * Authenticates using the popup-based OAuth flow.\n     * @return {Promise} a promise that resolves when we finish authenticating\n     */\n\n  }, {\n    key: 'loginWithPopup',\n    value: function loginWithPopup() {\n      var _this3 = this;\n\n      if (this.$promises.login) {\n        return this.$promises.login;\n      }\n\n      this.profile.$clear();\n      this.$promises.login = this.$utilities.openPopup(this.$loginUrl).then(function () {\n        _this3.$promises.login = null;\n        // We need to utilize local storage to retain our parsed values\n        if (_this3.$config.storageType === 'session') {\n          _this3.profile.$$transfer('local', 'session');\n        }\n        var error = _this3.profile.$validate();\n\n        if (error) {\n          _this3.profile.$clear();\n          return Promise.reject(error);\n        }\n      }).catch(function (error) {\n        _this3.$promises.login = null;\n        return Promise.reject(error);\n      });\n\n      return this.$promises.login;\n    }\n\n    /**\n     * Authenticates using the redirect-based OAuth flow.\n     */\n\n  }, {\n    key: 'loginWithRedirect',\n    value: function loginWithRedirect() {\n      if (!this.$config.redirectLoginCallback) {\n        throw new ReferenceError('A redirectLoginCallback is required to invoke \"loginWithRedirect\"!');\n      }\n\n      this.profile.$clear();\n      this.profile.$redirectUrl = this.profile.$redirectUrl || location.href;\n      location.href = this.$loginUrl;\n    }\n\n    /**\n     * Unauthenticates using the iframe-based OAuth flow.\n     * @return {Promise} a promise that resolves when we finish deauthenticating\n     */\n\n  }, {\n    key: 'logoutWithIframe',\n    value: function logoutWithIframe() {\n      var _this4 = this;\n\n      if (this.$promises.logout) {\n        return this.$promises.logout;\n      }\n\n      this.profile.$clear();\n      this.$promises.logout = this.$utilities.createIframe(this.$deauthorizeUrl).then(function () {\n        _this4.$promises.logout = null;\n      });\n      return this.$promises.logout;\n    }\n\n    /**\n     * Unauthenticates using the popup-based OAuth flow.\n     * @return {Promise} a promise that resolves when we finish deauthenticating\n     */\n\n  }, {\n    key: 'logoutWithPopup',\n    value: function logoutWithPopup() {\n      var _this5 = this;\n\n      if (this.$promises.logout) {\n        return this.$promises.logout;\n      }\n\n      this.profile.$clear();\n      this.$promises.logout = this.$utilities.openPopup(this.$deauthorizeUrl).then(function () {\n        _this5.$promises.logout = null;\n      });\n\n      return this.$promises.logout;\n    }\n\n    /**\n     * Logs the user out of their configured identity provider.\n     */\n\n  }, {\n    key: 'logoutWithRedirect',\n    value: function logoutWithRedirect() {\n      this.profile.$clear();\n      location.href = this.$deauthorizeUrl;\n    }\n\n    /**\n     * Authenticates, requests the access token, and returns it if necessary.\n     * @return {Promise<string>} a promise that resolves when we retrieve the access token\n     */\n\n  }, {\n    key: 'retrieveAccessToken',\n    value: function retrieveAccessToken() {\n      var _this6 = this;\n\n      if (this.$promises.token) {\n        return this.$promises.token;\n      }\n\n      this.$promises.token = Promise.resolve();\n      if (this.profile.idTokenExpired) {\n        if (this.$config.loginType === 'popup') {\n          this.$promises.token = this.loginWithPopup();\n        } else if ([undefined, null, 'iframe'].indexOf(this.$config.loginType) !== -1) {\n          this.$promises.token = this.loginWithIframe();\n        } else {\n          this.$promises.token = null;\n          return Promise.reject(new ReferenceError('Invaid Login Type (' + this.$config.loginType + ')'));\n        }\n      }\n\n      this.$promises.token = this.$promises.token.then(function () {\n        _this6.profile.$clearErrors();\n        if (_this6.profile.accessTokenExpired) {\n          return _this6.$utilities.createIframe(_this6.$accessTokenUrl).then(function () {\n            _this6.$promises.token = null;\n            var error = _this6.profile.$validate(true);\n\n            if (error) {\n              return Promise.reject(error);\n            }\n            return _this6.profile.$accessToken;\n          });\n        }\n        _this6.$promises.token = null;\n        return _this6.profile.$accessToken;\n      }).catch(function (error) {\n        _this6.$promises.token = null;\n        return Promise.reject(error);\n      });\n\n      return this.$promises.token;\n    }\n\n    /**\n     * Checks if the current route is secured and authenticates the user if necessary\n     * @ignore\n     */\n\n  }, {\n    key: '$$onRouteChanged',\n    value: function $$onRouteChanged() {\n      if (!this.$utilities.isRouteSecure(location.href, this.$config.routes)) return;\n\n      this.retrieveAccessToken();\n    }\n  }, {\n    key: '$provider',\n    get: function get() {\n      if (!this.$config.provider) {\n        throw new ReferenceError('A provider must be specified');\n      }\n\n      if (typeof this.$config.provider === 'string') {\n        var provider = this.$providers[this.$config.provider];\n        if (!provider) {\n          throw new ReferenceError('Unknown Provider (' + this.$config.provider + ')');\n        }\n        return provider;\n      }\n\n      return this.$config.provider;\n    }\n\n    /**\n     * The authentication url to retrieve the access token\n     * @type {String}\n     * @private\n     */\n\n  }, {\n    key: '$accessTokenUrl',\n    get: function get() {\n      this.profile.$localState = _uuid2.default.v4();\n      this.profile.$nonce = _uuid2.default.v4();\n\n      var authorizeEndpoint = this.$config.providerUrl + '/authorize';\n      if (this.$provider.authorizeEndpoint) {\n        authorizeEndpoint = this.$provider.authorizeEndpoint.call(this, this.$config);\n      }\n\n      return this.$utilities.createUrl(authorizeEndpoint, (0, _lodash.assign)({\n        'state': this.profile.$localState,\n        'nonce': this.profile.$nonce,\n        'response_type': 'token',\n        'redirect_uri': this.$config.redirectUrl,\n        'client_id': this.$config.clientId,\n        'scope': this.$config.scope,\n        'prompt': 'none'\n      }, this.$config.queryParams));\n    }\n\n    /**\n     * The authentication url to retrieve the id token\n     * @type {String}\n     * @private\n     */\n\n  }, {\n    key: '$loginUrl',\n    get: function get() {\n      this.profile.$localState = _uuid2.default.v4();\n      this.profile.$nonce = _uuid2.default.v4();\n\n      var authorizeEndpoint = this.$config.providerUrl + '/authorize';\n      if (this.$provider.authorizeEndpoint) {\n        authorizeEndpoint = this.$provider.authorizeEndpoint.call(this, this.$config);\n      }\n\n      return this.$utilities.createUrl(authorizeEndpoint, (0, _lodash.assign)({\n        'state': this.profile.$localState,\n        'nonce': this.profile.$nonce,\n        'response_type': this.$config.responseType,\n        'redirect_uri': this.$config.redirectUrl,\n        'client_id': this.$config.clientId,\n        'scope': this.$config.scope\n      }, this.$config.queryParams));\n    }\n\n    /**\n     * The url to logout of the configured provider\n     * @type {String}\n     * @private\n     */\n\n  }, {\n    key: '$deauthorizeUrl',\n    get: function get() {\n      return this.$provider.deauthorizeUrl.call(this, this.$config);\n    }\n  }]);\n\n  return SalteAuth;\n}();\n\n(0, _lodash.set)(window, 'salte.SalteAuth', (0, _lodash.get)(window, 'salte.SalteAuth', SalteAuth));\nexports.SalteAuth = SalteAuth;\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar v1 = __webpack_require__(6);\nvar v4 = __webpack_require__(7);\n\nvar uuid = v4;\nuuid.v1 = v1;\nuuid.v4 = v4;\n\nmodule.exports = uuid;\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar rng = __webpack_require__(1);\nvar bytesToUuid = __webpack_require__(2);\n\n// **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\nvar _nodeId;\nvar _clockseq;\n\n// Previous uuid creation time\nvar _lastMSecs = 0;\nvar _lastNSecs = 0;\n\n// See https://github.com/broofa/node-uuid for API details\nfunction v1(options, buf, offset) {\n  var i = buf && offset || 0;\n  var b = buf || [];\n\n  options = options || {};\n  var node = options.node || _nodeId;\n  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;\n\n  // node and clockseq need to be initialized to random values if they're not\n  // specified.  We do this lazily to minimize issues related to insufficient\n  // system entropy.  See #189\n  if (node == null || clockseq == null) {\n    var seedBytes = rng();\n    if (node == null) {\n      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n      node = _nodeId = [\n        seedBytes[0] | 0x01,\n        seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]\n      ];\n    }\n    if (clockseq == null) {\n      // Per 4.2.2, randomize (14 bit) clockseq\n      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n    }\n  }\n\n  // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();\n\n  // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;\n\n  // Time since last uuid creation (in msecs)\n  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;\n\n  // Per 4.2.1.2, Bump clockseq on clock regression\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  }\n\n  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  }\n\n  // Per 4.2.1.2 Throw error if too many uuids are requested\n  if (nsecs >= 10000) {\n    throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq;\n\n  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n  msecs += 12219292800000;\n\n  // `time_low`\n  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff;\n\n  // `time_mid`\n  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff;\n\n  // `time_high_and_version`\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n  b[i++] = tmh >>> 16 & 0xff;\n\n  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n  b[i++] = clockseq >>> 8 | 0x80;\n\n  // `clock_seq_low`\n  b[i++] = clockseq & 0xff;\n\n  // `node`\n  for (var n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf ? buf : bytesToUuid(b);\n}\n\nmodule.exports = v1;\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar rng = __webpack_require__(1);\nvar bytesToUuid = __webpack_require__(2);\n\nfunction v4(options, buf, offset) {\n  var i = buf && offset || 0;\n\n  if (typeof(options) == 'string') {\n    buf = options === 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || bytesToUuid(rnds);\n}\n\nmodule.exports = v4;\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Providers = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _auth = __webpack_require__(9);\n\nvar _auth2 = _interopRequireDefault(_auth);\n\nvar _azure = __webpack_require__(10);\n\nvar _azure2 = _interopRequireDefault(_azure);\n\nvar _cognito = __webpack_require__(11);\n\nvar _cognito2 = _interopRequireDefault(_cognito);\n\nvar _wso = __webpack_require__(12);\n\nvar _wso2 = _interopRequireDefault(_wso);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * A collection of overrides for specific Identity Providers\n */\nvar Providers = function () {\n  function Providers() {\n    _classCallCheck(this, Providers);\n  }\n\n  _createClass(Providers, null, [{\n    key: 'auth0',\n\n    /**\n     * Provider for Auth0\n     * @type {SalteAuthAuth0Provider}\n     */\n    get: function get() {\n      return _auth2.default;\n    }\n\n    /**\n     * Provider for Azure's Active Directory\n     * @type {SalteAuthAzureProvider}\n     */\n\n  }, {\n    key: 'azure',\n    get: function get() {\n      return _azure2.default;\n    }\n\n    /**\n     * Provider for Amazon's Cognito\n     * @type {SalteAuthCognitoProvider}\n     */\n\n  }, {\n    key: 'cognito',\n    get: function get() {\n      return _cognito2.default;\n    }\n\n    /**\n     * Provider for WSO2's API Gateway\n     * @type {SalteAuthWSO2Provider}\n     */\n\n  }, {\n    key: 'wso2',\n    get: function get() {\n      return _wso2.default;\n    }\n  }]);\n\n  return Providers;\n}();\n\n;\n\nexports.Providers = Providers;\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Provider for Auth0\n * @see https://auth0.com\n */\nvar SalteAuthAuth0Provider = function () {\n  function SalteAuthAuth0Provider() {\n    _classCallCheck(this, SalteAuthAuth0Provider);\n  }\n\n  _createClass(SalteAuthAuth0Provider, null, [{\n    key: \"deauthorizeUrl\",\n\n    /**\n     * Computes the deauthorization url\n     * @param {Config} config configuration for salte auth\n     * @return {String} the deauthorization url\n     */\n    value: function deauthorizeUrl(config) {\n      return this.$utilities.createUrl(config.providerUrl + \"/v2/logout\", {\n        returnTo: config.redirectUrl,\n        client_id: config.clientId\n      });\n    }\n  }]);\n\n  return SalteAuthAuth0Provider;\n}();\n\nexports.default = SalteAuthAuth0Provider;\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/** Provider for Azure's Active Directory */\nvar SalteAuthAzureProvider = function () {\n  function SalteAuthAzureProvider() {\n    _classCallCheck(this, SalteAuthAzureProvider);\n  }\n\n  _createClass(SalteAuthAzureProvider, null, [{\n    key: \"authorizeEndpoint\",\n\n    /**\n     * Computes the authorization endpoint\n     * @param {Config} config configuration for salte auth\n     * @return {String} the authorization endpoint\n     */\n    value: function authorizeEndpoint(config) {\n      return config.providerUrl + \"/oauth2/authorize\";\n    }\n\n    /**\n     * Computes the deauthorization url\n     * @param {Config} config configuration for salte auth\n     * @return {String} the deauthorization url\n     */\n\n  }, {\n    key: \"deauthorizeUrl\",\n    value: function deauthorizeUrl(config) {\n      return this.$utilities.createUrl(config.providerUrl + \"/oauth2/logout\", {\n        post_logout_redirect_uri: config.redirectUrl\n      });\n    }\n  }]);\n\n  return SalteAuthAzureProvider;\n}();\n\nexports.default = SalteAuthAzureProvider;\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/** Provider for Amazon's Cognito */\nvar SalteAuthCognitoProvider = function () {\n  function SalteAuthCognitoProvider() {\n    _classCallCheck(this, SalteAuthCognitoProvider);\n  }\n\n  _createClass(SalteAuthCognitoProvider, null, [{\n    key: \"authorizeEndpoint\",\n\n    /**\n     * Computes the authorization endpoint\n     * @param {Config} config configuration for salte auth\n     * @return {String} the authorization endpoint\n     */\n    value: function authorizeEndpoint(config) {\n      return config.providerUrl + \"/oauth2/authorize\";\n    }\n\n    /**\n     * Computes the deauthorization url\n     * @param {Config} config configuration for salte auth\n     * @return {String} the deauthorization url\n     */\n\n  }, {\n    key: \"deauthorizeUrl\",\n    value: function deauthorizeUrl(config) {\n      return this.$utilities.createUrl(config.providerUrl + \"/logout\", {\n        logout_uri: config.redirectUrl,\n        client_id: config.clientId\n      });\n    }\n\n    /**\n     * Provides a set of default config options required for cognito\n     */\n\n  }, {\n    key: \"defaultConfig\",\n    get: function get() {\n      return {\n        validation: {\n          // Amazon Cognito doesn't support nonce validation\n          nonce: false\n        }\n      };\n    }\n  }]);\n\n  return SalteAuthCognitoProvider;\n}();\n\nexports.default = SalteAuthCognitoProvider;\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/** Provider for WSO2's API Gateway */\nvar SalteAuthWSO2Provider = function () {\n  function SalteAuthWSO2Provider() {\n    _classCallCheck(this, SalteAuthWSO2Provider);\n  }\n\n  _createClass(SalteAuthWSO2Provider, null, [{\n    key: 'deauthorizeUrl',\n\n    /**\n     * Computes the deauthorization url\n     * @param {Config} config configuration for salte auth\n     * @return {String} the deauthorization url\n     */\n    value: function deauthorizeUrl(config) {\n      return this.$utilities.createUrl(config.providerUrl + '/commonauth', {\n        commonAuthLogout: true,\n        type: 'oidc',\n        commonAuthCallerPath: config.redirectUrl,\n        relyingParty: config.relyingParty\n      });\n    }\n  }]);\n\n  return SalteAuthWSO2Provider;\n}();\n\nexports.default = SalteAuthWSO2Provider;\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SalteAuthProfile = undefined;\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _lodash = __webpack_require__(0);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * All the profile information associated with the current authentication session\n */\nvar SalteAuthProfile = function () {\n  /**\n   * Parses the current url for the authentication values\n   * @param {Config} config configuration for salte auth\n   */\n  function SalteAuthProfile(config) {\n    _classCallCheck(this, SalteAuthProfile);\n\n    if (window.salte.SalteAuthProfile.$instance) {\n      return window.salte.SalteAuthProfile.$instance;\n    }\n    /** @ignore */\n    this.$$config = (0, _lodash.defaultsDeep)(config, {\n      validation: {\n        nonce: true,\n        state: true,\n        azp: true,\n        aud: true\n      },\n      storageType: 'session'\n    });\n    if (location.hash) {\n      var params = location.hash.replace(/(#!?[^#]+)?#/, '').split('&');\n      for (var i = 0; i < params.length; i++) {\n        var param = params[i];\n\n        var _param$split = param.split('='),\n            _param$split2 = _slicedToArray(_param$split, 2),\n            key = _param$split2[0],\n            value = _param$split2[1];\n\n        this.$parse(key, decodeURIComponent(value));\n      }\n    }\n    window.salte.SalteAuthProfile.$instance = this;\n  }\n\n  /**\n   * Parse a key-value pair\n   * @param {String} key the key to parse\n   * @param {Object} value the matching value to parse\n   * @private\n   */\n\n\n  _createClass(SalteAuthProfile, [{\n    key: '$parse',\n    value: function $parse(key, value) {\n      switch (key) {\n        case 'token_type':\n          this.$tokenType = value;\n          break;\n        case 'expires_in':\n          this.$expiration = Date.now() + value;\n          break;\n        case 'access_token':\n          this.$accessToken = value;\n          break;\n        case 'id_token':\n          this.$idToken = value;\n          break;\n        case 'state':\n          this.$state = value;\n          break;\n        case 'error':\n          this.$error = value;\n          break;\n        case 'error_description':\n          this.$errorDescription = value;\n          break;\n      }\n    }\n\n    /**\n     * Whether the ID Token has expired\n     * @return {Boolean} true if the \"id_token\" has expired\n     */\n\n  }, {\n    key: '$validate',\n\n\n    /**\n     * Verifies that we were logged in successfully and that all security checks pass\n     * @param {Boolean} accessTokenRequest if the request we're validating was an access token request\n     * @return {Object} the error message\n     * @private\n     */\n    value: function $validate(accessTokenRequest) {\n      var _this = this;\n\n      if (!this.$$config.validation) {\n        return;\n      }\n\n      if (this.$error) {\n        return {\n          code: this.$error,\n          description: this.$errorDescription\n        };\n      }\n\n      if (!this.$idToken) {\n        return {\n          code: 'login_canceled',\n          description: 'User likely canceled the login or something unexpected occurred.'\n        };\n      }\n\n      if (this.$$config.validation.state && this.$localState !== this.$state) {\n        return {\n          code: 'invalid_state',\n          description: 'State provided by identity provider did not match local state.'\n        };\n      }\n\n      if (accessTokenRequest) return;\n\n      if (this.$$config.validation.nonce && this.$nonce !== this.userInfo.nonce) {\n        return {\n          code: 'invalid_nonce',\n          description: 'Nonce provided by identity provider did not match local nonce.'\n        };\n      }\n\n      if (Array.isArray(this.userInfo.aud)) {\n        if (this.$$config.validation.azp) {\n          if (!this.userInfo.azp) {\n            return {\n              code: 'invalid_azp',\n              description: 'Audience was returned as an array and AZP was not present on the ID Token.'\n            };\n          }\n\n          if (this.userInfo.azp !== this.$$config.clientId) {\n            return {\n              code: 'invalid_azp',\n              description: 'AZP does not match the Client ID.'\n            };\n          }\n        }\n\n        if (this.$$config.validation.aud) {\n          var aud = (0, _lodash.find)(this.userInfo.aud, function (audience) {\n            return audience === _this.$$config.clientId;\n          });\n\n          if (!aud) {\n            return {\n              code: 'invalid_aud',\n              description: 'None of the audience values matched the Client ID.'\n            };\n          }\n        }\n      } else if (this.$$config.validation.aud && this.userInfo.aud !== this.$$config.clientId) {\n        return {\n          code: 'invalid_aud',\n          description: 'The audience did not match the Client ID.'\n        };\n      }\n    }\n\n    /**\n     * Saves a value to the Web Storage API\n     * @param {String} key The key to save to\n     * @param {*} value The value to save, if this is undefined or null it will delete the key\n     * @private\n     */\n\n  }, {\n    key: '$saveItem',\n    value: function $saveItem(key, value) {\n      if ([undefined, null].indexOf(value) !== -1) {\n        this.$storage.removeItem(key);\n      } else {\n        this.$storage.setItem(key, value);\n      }\n    }\n\n    /**\n     * Return the active Web Storage API\n     * @return {Storage} the storage api to save and pull values from\n     * @private\n     */\n\n  }, {\n    key: '$$getStorage',\n\n\n    /**\n     * Determines which Web Storage API to return using the name provided\n     * @param {String} storageType the name of the storageType to use\n     * @return {Storage} the web storage api that matches the given string\n     * @ignore\n     */\n    value: function $$getStorage(storageType) {\n      if (storageType === 'local') {\n        return localStorage;\n      } else if (storageType === 'session') {\n        return sessionStorage;\n      } else {\n        throw new ReferenceError('Unknown Storage Type (' + storageType + ')');\n      }\n    }\n\n    /**\n     * Transfers values from one storage type to the other\n     * @param {String} source the name of the storage type to pull from\n     * @param {String} destination the name of the storage type to push to\n     * @ignore\n     */\n\n  }, {\n    key: '$$transfer',\n    value: function $$transfer(source, destination) {\n      var sourceStorage = this.$$getStorage(source);\n      var destinationStorage = this.$$getStorage(destination);\n\n      for (var key in sourceStorage) {\n        if (key.indexOf('salte.auth.') !== 0) continue;\n\n        destinationStorage.setItem(key, sourceStorage.getItem(key));\n        sourceStorage.removeItem(key);\n      }\n    }\n\n    /**\n     * Clears all `salte.auth` values from localStorage\n     * @private\n     */\n\n  }, {\n    key: '$clear',\n    value: function $clear() {\n      for (var key in this.$storage) {\n        if (key.match(/^salte\\.auth\\.[^$]/)) {\n          this.$saveItem(key, undefined);\n        }\n      }\n    }\n\n    /**\n     * Clears all `salte.auth` error values from localStorage\n     * @private\n     */\n\n  }, {\n    key: '$clearErrors',\n    value: function $clearErrors() {\n      this.$error = undefined;\n      this.$errorDescription = undefined;\n    }\n  }, {\n    key: 'idTokenExpired',\n    get: function get() {\n      return !this.$idToken || Date.now() >= this.userInfo.exp * 1000;\n    }\n\n    /**\n     * Whether the Access Token has expired\n     * @return {Boolean} true if the \"access_token\" has expired\n     */\n\n  }, {\n    key: 'accessTokenExpired',\n    get: function get() {\n      return !this.$accessToken || Date.now() >= this.$expiration;\n    }\n\n    /**\n     * The type of Access Token that was returned by the identity provider\n     * @return {String} the type of access token\n     * @private\n     */\n\n  }, {\n    key: '$tokenType',\n    get: function get() {\n      return this.$storage.getItem('salte.auth.token-type');\n    },\n    set: function set(tokenType) {\n      this.$saveItem('salte.auth.token-type', tokenType);\n    }\n\n    /**\n     * The date and time that the access token will expire\n     * @return {String} the expiration time as unix timestamp\n     * @private\n     */\n\n  }, {\n    key: '$expiration',\n    get: function get() {\n      return this.$storage.getItem('salte.auth.expiration');\n    },\n    set: function set(expiration) {\n      this.$saveItem('salte.auth.expiration', expiration);\n    }\n\n    /**\n     * The Access Token returned by the identity provider\n     * @return {String} the access token\n     * @private\n     */\n\n  }, {\n    key: '$accessToken',\n    get: function get() {\n      return this.$storage.getItem('salte.auth.access-token');\n    },\n    set: function set(accessToken) {\n      this.$saveItem('salte.auth.access-token', accessToken);\n    }\n\n    /**\n     * The ID Token returned by the identity provider\n     * @return {String} the id token\n     * @private\n     */\n\n  }, {\n    key: '$idToken',\n    get: function get() {\n      return this.$storage.getItem('salte.auth.id-token');\n    },\n    set: function set(idToken) {\n      this.$saveItem('salte.auth.id-token', idToken);\n    }\n\n    /**\n     * The authentication state returned by the identity provider\n     * @return {String} the state value\n     * @private\n     *\n     * @see https://tools.ietf.org/html/rfc6749#section-4.1.1\n     */\n\n  }, {\n    key: '$state',\n    get: function get() {\n      return this.$storage.getItem('salte.auth.state');\n    },\n    set: function set(state) {\n      this.$saveItem('salte.auth.state', state);\n    }\n\n    /**\n     * The locally generate authentication state\n     * @return {String} the local state value\n     * @private\n     *\n     * @see https://tools.ietf.org/html/rfc6749#section-4.1.1\n     */\n\n  }, {\n    key: '$localState',\n    get: function get() {\n      return this.$storage.getItem('salte.auth.local-state');\n    },\n    set: function set(localState) {\n      this.$saveItem('salte.auth.local-state', localState);\n    }\n\n    /**\n     * The error returned by the identity provider\n     * @return {String} the state value\n     * @private\n     */\n\n  }, {\n    key: '$error',\n    get: function get() {\n      return this.$storage.getItem('salte.auth.error');\n    },\n    set: function set(error) {\n      this.$saveItem('salte.auth.error', error);\n    }\n\n    /**\n     * The error description returned by the identity provider\n     * @return {String} a string that describes the error that occurred\n     * @private\n     */\n\n  }, {\n    key: '$errorDescription',\n    get: function get() {\n      return this.$storage.getItem('salte.auth.error-description');\n    },\n    set: function set(errorDescription) {\n      this.$saveItem('salte.auth.error-description', errorDescription);\n    }\n\n    /**\n     * The url the user originated from before authentication occurred\n     * @return {String} The url the user originated from before authentication occurred\n     * @private\n     */\n\n  }, {\n    key: '$redirectUrl',\n    get: function get() {\n      return this.$storage.getItem('salte.auth.$redirect-url');\n    },\n    set: function set(redirectUrl) {\n      this.$saveItem('salte.auth.$redirect-url', redirectUrl);\n    }\n\n    /**\n     * Parses the User Info from the ID Token\n     * @return {String} The User Info from the ID Token\n     * @private\n     */\n\n  }, {\n    key: '$nonce',\n    get: function get() {\n      return this.$storage.getItem('salte.auth.nonce');\n    },\n    set: function set(nonce) {\n      this.$saveItem('salte.auth.nonce', nonce);\n    }\n\n    /**\n     * Parses the User Info from the ID Token\n     * @return {Object} The User Info from the ID Token\n     */\n\n  }, {\n    key: 'userInfo',\n    get: function get() {\n      if (this.$idToken) {\n        var separatedToken = this.$idToken.split('.');\n        if (separatedToken.length === 3) {\n          return JSON.parse(atob(separatedToken[1]));\n        }\n      }\n      return null;\n    }\n  }, {\n    key: '$storage',\n    get: function get() {\n      return this.$$getStorage(this.$$config.storageType);\n    }\n  }]);\n\n  return SalteAuthProfile;\n}();\n\n(0, _lodash.set)(window, 'salte.SalteAuthProfile', (0, _lodash.get)(window, 'salte.SalteAuthProfile', SalteAuthProfile));\nexports.SalteAuthProfile = SalteAuthProfile;\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SalteAuthUtilities = undefined;\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _lodash = __webpack_require__(0);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Basic utilities to support the authentication flow\n */\nvar SalteAuthUtilities = function () {\n  /**\n   * Wraps all XHR and Fetch (if available) requests to allow promise interceptors\n   */\n  function SalteAuthUtilities() {\n    _classCallCheck(this, SalteAuthUtilities);\n\n    if (window.salte.SalteAuthUtilities.$instance) {\n      return window.salte.SalteAuthUtilities.$instance;\n    }\n\n    /** @ignore */\n    this.$interceptors = {\n      fetch: [],\n      xhr: []\n    };\n\n    (function (open) {\n      XMLHttpRequest.prototype.open = function (method, url) {\n        /** @ignore */\n        this.$url = url;\n        return open.call(this, method, url);\n      };\n    })(XMLHttpRequest.prototype.open);\n\n    var self = this;\n    (function (send) {\n      XMLHttpRequest.prototype.send = function (data) {\n        var _this = this;\n\n        var promises = [];\n        for (var i = 0; i < self.$interceptors.xhr.length; i++) {\n          var interceptor = self.$interceptors.xhr[i];\n          promises.push(interceptor(this, data));\n        }\n        Promise.all(promises).then(function () {\n          send.call(_this, data);\n        }).catch(function (error) {\n          var event = document.createEvent('Event');\n          event.initEvent('error', false, true);\n          event.detail = error;\n          _this.dispatchEvent(event);\n        });\n      };\n    })(XMLHttpRequest.prototype.send);\n\n    if (window.fetch) {\n      (function (fetch) {\n        window.fetch = function (input) {\n          var _this2 = this;\n\n          var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n          var promises = [];\n          for (var i = 0; i < self.$interceptors.fetch.length; i++) {\n            var interceptor = self.$interceptors.fetch[i];\n            promises.push(interceptor(input, options));\n          }\n          return Promise.all(promises).then(function () {\n            return fetch.call(_this2, input, options);\n          });\n        };\n      })(fetch);\n    }\n    window.salte.SalteAuthUtilities.$instance = this;\n  }\n\n  /**\n   * Creates a URL using a base url and a queryParams object\n   * @param {String} baseUrl the base url to attach the queryParams to\n   * @param {Object} queryParams the queryParams to attach to the baseUrl\n   * @return {String} the url with the request queryParams\n   */\n\n\n  _createClass(SalteAuthUtilities, [{\n    key: 'createUrl',\n    value: function createUrl(baseUrl) {\n      var queryParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      var url = baseUrl;\n\n      Object.keys(queryParams).forEach(function (key) {\n        var value = queryParams[key];\n        if ([undefined, null, ''].indexOf(value) === -1) {\n          url += '' + (url.indexOf('?') === -1 ? '?' : '&') + key + '=' + encodeURIComponent(value);\n        }\n      });\n\n      return url;\n    }\n\n    /**\n     * Converts a url to an absolute url\n     * @param {String} path the url path to resolve to an absolute url\n     * @return {String} the absolutely resolved url\n     */\n\n  }, {\n    key: 'resolveUrl',\n    value: function resolveUrl(path) {\n      if (!this.$$urlDocument) {\n        /** @ignore */\n        this.$$urlDocument = document.implementation.createHTMLDocument('url');\n        /** @ignore */\n        this.$$urlBase = this.$$urlDocument.createElement('base');\n        /** @ignore */\n        this.$$urlAnchor = this.$$urlDocument.createElement('a');\n        this.$$urlDocument.head.appendChild(this.$$urlBase);\n      }\n      this.$$urlBase.href = window.location.protocol + '//' + window.location.host;\n      this.$$urlAnchor.href = path.replace(/ /g, '%20');\n      return this.$$urlAnchor.href;\n    }\n\n    /**\n     * Checks if the given url matches any of the test urls\n     * @param {String} url The url to test\n     * @param {Array<String|RegExp>} tests The urls to match the test url against\n     * @return {Boolean} true if the url matches one of the tests\n     */\n\n  }, {\n    key: 'checkForMatchingUrl',\n    value: function checkForMatchingUrl(url) {\n      var tests = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n      var resolvedUrl = this.resolveUrl(url);\n      for (var i = 0; i < tests.length; i++) {\n        var test = tests[i];\n        if (test instanceof RegExp) {\n          return !!resolvedUrl.match(test);\n        } else {\n          return resolvedUrl.indexOf(this.resolveUrl(test)) === 0;\n        }\n      }\n\n      return false;\n    }\n\n    /**\n     * Determines if the given route is a secured route\n     * @param {String} route the route to verify\n     * @param {Boolean|Array<String>} securedRoutes a list of routes that require authentication\n     * @return {Boolean} true if the route provided is a secured route\n     */\n\n  }, {\n    key: 'isRouteSecure',\n    value: function isRouteSecure(route, securedRoutes) {\n      if (securedRoutes === true) {\n        return true;\n      } else if (securedRoutes instanceof Array) {\n        return this.checkForMatchingUrl(route, securedRoutes);\n      }\n      return false;\n    }\n\n    /**\n     * Opens a popup window in the middle of the viewport\n     * @param {String} url the url to be loaded\n     * @param {String} name the name of the window\n     * @param {Number} height the height of the window\n     * @param {Number} width the width of the window\n     * @return {Promise} resolves when the popup is closed\n     */\n\n  }, {\n    key: 'openPopup',\n    value: function openPopup(url) {\n      var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'salte-auth';\n      var height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 600;\n      var width = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 400;\n\n      var top = window.innerHeight / 2 - height / 2 + window.screenTop;\n      var left = window.innerWidth / 2 - width / 2 + window.screenLeft;\n      var popupWindow = window.open(url, name, 'height=' + height + ', width=' + width + ', status=yes, toolbar=no, menubar=no, location=no, top=' + top + ', left=' + left);\n      if (!popupWindow) {\n        return Promise.reject(new ReferenceError('We were unable to open the popup window, its likely that the request was blocked.'));\n      }\n\n      popupWindow.focus();\n      // TODO: Find a better way of tracking when a Popup Window closes.\n      return new Promise(function (resolve) {\n        var checker = setInterval(function () {\n          if (!popupWindow.closed) return;\n          clearInterval(checker);\n          setTimeout(resolve);\n        }, 100);\n      });\n    }\n\n    /**\n     * Opens an iframe in the background\n     * @param {String} url the url to be loaded\n     * @param {Boolean} show whether the iframe should be visible\n     * @return {Promise} resolves when the iframe is closed\n     */\n\n  }, {\n    key: 'createIframe',\n    value: function createIframe(url, show) {\n      var iframe = document.createElement('iframe');\n      iframe.setAttribute('owner', 'salte-auth');\n      if (show) {\n        (0, _lodash.assign)(iframe.style, {\n          position: 'fixed',\n          top: 0,\n          bottom: 0,\n          left: 0,\n          right: 0,\n          height: '100%',\n          width: '100%',\n          zIndex: 9999,\n          border: 'none',\n\n          opacity: 0,\n          transition: '0.5s opacity'\n        });\n\n        setTimeout(function () {\n          iframe.style.opacity = 1;\n        });\n      } else {\n        iframe.style.display = 'none';\n      }\n      iframe.src = url;\n      document.body.appendChild(iframe);\n      return new Promise(function (resolve) {\n        iframe.addEventListener('DOMNodeRemoved', function () {\n          setTimeout(resolve);\n        });\n      });\n    }\n\n    /**\n     * Adds a XMLHttpRequest interceptor\n     * @param {Function} interceptor the interceptor function\n     */\n\n  }, {\n    key: 'addXHRInterceptor',\n    value: function addXHRInterceptor(interceptor) {\n      this.$interceptors.xhr.push(interceptor);\n    }\n\n    /**\n     * Adds a fetch interceptor\n     * @param {Function} interceptor the interceptor function\n     */\n\n  }, {\n    key: 'addFetchInterceptor',\n    value: function addFetchInterceptor(interceptor) {\n      this.$interceptors.fetch.push(interceptor);\n    }\n\n    /**\n     * Checks if the current window is an iframe\n     * @return {HTMLIFrameElement} true if the current window is an iframe.\n     * @private\n     */\n\n  }, {\n    key: '$iframe',\n    get: function get() {\n      if (window.self === window.top) {\n        return null;\n      }\n      return parent.document.querySelector('body > iframe[owner=\"salte-auth\"]');\n    }\n\n    /**\n     * Determines if the current window is a popup window opened by salte auth\n     * @return {Window} the window object\n     * @private\n     */\n\n  }, {\n    key: '$popup',\n    get: function get() {\n      if (window.opener && window.name === 'salte-auth') {\n        return window;\n      }\n      return null;\n    }\n  }]);\n\n  return SalteAuthUtilities;\n}();\n\n(0, _lodash.set)(window, 'salte.SalteAuthUtilities', (0, _lodash.get)(window, 'salte.SalteAuthUtilities', SalteAuthUtilities));\nexports.SalteAuthUtilities = SalteAuthUtilities;\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// salte-auth.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 9630a714b1c1ef4c4013","module.exports = __WEBPACK_EXTERNAL_MODULE_0__;\n\n\n//////////////////\n// WEBPACK FOOTER\n// external {\"root\":\"_\",\"commonjs\":\"lodash\",\"commonjs2\":\"lodash\",\"amd\":\"lodash\"}\n// module id = 0\n// module chunks = 0","// Unique ID creation requires a high quality random # generator.  In the\n// browser this is a little complicated due to unknown quality of Math.random()\n// and inconsistent support for the `crypto` API.  We do the best we can via\n// feature-detection\n\n// getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation.\nvar getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues.bind(crypto)) ||\n                      (typeof(msCrypto) != 'undefined' && msCrypto.getRandomValues.bind(msCrypto));\nif (getRandomValues) {\n  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef\n\n  module.exports = function whatwgRNG() {\n    getRandomValues(rnds8);\n    return rnds8;\n  };\n} else {\n  // Math.random()-based (RNG)\n  //\n  // If all else fails, use Math.random().  It's fast, but is of unspecified\n  // quality.\n  var rnds = new Array(16);\n\n  module.exports = function mathRNG() {\n    for (var i = 0, r; i < 16; i++) {\n      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return rnds;\n  };\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../node_modules/uuid/lib/rng-browser.js\n// module id = 1\n// module chunks = 0","/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex;\n  return bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]];\n}\n\nmodule.exports = bytesToUuid;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../node_modules/uuid/lib/bytesToUuid.js\n// module id = 2\n// module chunks = 0","import { assign, defaultsDeep, get, set } from 'lodash';\nimport uuid from 'uuid';\n\nimport { Providers } from './salte-auth.providers.js';\nimport { SalteAuthProfile } from './salte-auth.profile.js';\nimport { SalteAuthUtilities } from './salte-auth.utilities.js';\n\n/**\n * Disable certain security validations if your provider doesn't support them.\n * @typedef {Object} Validation\n * @property {Boolean} [nonce=true] Passing false will disable nonce validation, leaving you vulnerable to replay attacks.\n * @property {Boolean} [state=true] Passing false will disable state validation, leaving you vulnerable to XSRF attacks.\n * @property {Boolean} [azp=true] Passing false will disable azp validation.\n * @property {Boolean} [aud=true] Passing false will disable aud validation.\n */\n\n/**\n * The configuration for salte auth\n * @typedef {Object} Config\n * @property {String} providerUrl The base url of your identity provider.\n * @property {('id_token'|'id_token token')} responseType The response type to authenticate with.\n * @property {String} redirectUrl The redirect url specified in your identity provider.\n * @property {String} clientId The client id of your identity provider\n * @property {String} scope A list of space-delimited claims used to determine what user information is provided and what access is given. Most providers require 'openid'.\n * @property {Boolean|Array<String>} routes A list of secured routes. If true is provided then all routes are secured.\n * @property {Array<String|RegExp>} endpoints A list of secured endpoints.\n * @property {('auth0'|'azure'|'cognito'|'wso2')} provider The identity provider you're using.\n * @property {Function} [redirectLoginCallback] A callback that is invoked when a redirect login fails or succeeds.\n * @property {('session'|'local')} [storageType='session'] The Storage api to keep authenticate information stored in.\n * @property {Boolean|Validation} [validation] Used to disable certain security validations if your provider doesn't support them.\n */\n\n/**\n * Authentication Controller\n */\nclass SalteAuth {\n  /**\n   * Sets up Salte Auth\n   * @param {Config} config configuration for salte auth\n   */\n  constructor(config) {\n    if (window.salte.auth) {\n      return window.salte.auth;\n    }\n\n    if (!config) {\n      throw new ReferenceError('A config must be provided.');\n    }\n\n    /**\n     * The supported identity providers\n     * @type {Providers}\n     * @private\n     */\n    this.$providers = Providers;\n    /**\n     * The active authentication promises\n     * @private\n     */\n    this.$promises = {};\n    /**\n     * The configuration for salte auth\n     * @private\n     */\n    this.$config = config;\n    this.$config = defaultsDeep(config, this.$provider.defaultConfig);\n    /**\n     * Various utility functions for salte auth\n     * @type {SalteAuthUtilities}\n     * @private\n     */\n    this.$utilities = new SalteAuthUtilities();\n\n    /**\n     * The user profile for salte auth\n     * @type {SalteAuthProfile}\n     */\n    this.profile = new SalteAuthProfile(this.$config);\n\n    if (this.$utilities.$iframe) {\n      parent.document.body.removeChild(this.$utilities.$iframe);\n    } else if (this.$utilities.$popup) {\n      // We need to utilize local storage to retain our parsed values\n      if (this.$config.storageType === 'session') {\n        this.profile.$$transfer('session', 'local');\n      }\n      setTimeout(this.$utilities.$popup.close);\n    } else if (this.profile.$redirectUrl && location.href !== this.profile.$redirectUrl) {\n      const error = this.profile.$validate();\n      if (error) {\n        this.profile.$clear();\n      } else {\n        location.href = this.profile.$redirectUrl;\n        this.profile.$redirectUrl = undefined;\n      }\n      this.$config.redirectLoginCallback(error);\n    } else {\n      this.$utilities.addXHRInterceptor((request, data) => {\n        if (this.$utilities.checkForMatchingUrl(request.$url, this.$config.endpoints)) {\n          return this.retrieveAccessToken().then((accessToken) => {\n            request.setRequestHeader('Authorization', `Bearer ${accessToken}`);\n          });\n        }\n      });\n\n      this.$utilities.addFetchInterceptor((input, options) => {\n        if (this.$utilities.checkForMatchingUrl(input, this.$config.endpoints)) {\n          return this.retrieveAccessToken().then((accessToken) => {\n            options.headers = options.headers || {};\n            options.headers.Authorization = `Bearer ${accessToken}`;\n          });\n        }\n      });\n\n      window.addEventListener('popstate', this.$$onRouteChanged.bind(this));\n      document.addEventListener('click', this.$$onRouteChanged.bind(this));\n      setTimeout(this.$$onRouteChanged.bind(this));\n    }\n    window.salte.auth = this;\n  }\n\n  /**\n   * Returns the configured provider\n   * @type {Class|Object}\n   * @private\n   */\n  get $provider() {\n    if (!this.$config.provider) {\n      throw new ReferenceError('A provider must be specified');\n    }\n\n    if (typeof this.$config.provider === 'string') {\n      const provider = this.$providers[this.$config.provider];\n      if (!provider) {\n        throw new ReferenceError(`Unknown Provider (${this.$config.provider})`);\n      }\n      return provider;\n    }\n\n    return this.$config.provider;\n  }\n\n  /**\n   * The authentication url to retrieve the access token\n   * @type {String}\n   * @private\n   */\n  get $accessTokenUrl() {\n    this.profile.$localState = uuid.v4();\n    this.profile.$nonce = uuid.v4();\n\n    let authorizeEndpoint = `${this.$config.providerUrl}/authorize`;\n    if (this.$provider.authorizeEndpoint) {\n      authorizeEndpoint = this.$provider.authorizeEndpoint.call(this, this.$config);\n    }\n\n    return this.$utilities.createUrl(authorizeEndpoint, assign({\n      'state': this.profile.$localState,\n      'nonce': this.profile.$nonce,\n      'response_type': 'token',\n      'redirect_uri': this.$config.redirectUrl,\n      'client_id': this.$config.clientId,\n      'scope': this.$config.scope,\n      'prompt': 'none'\n    }, this.$config.queryParams));\n  }\n\n  /**\n   * The authentication url to retrieve the id token\n   * @type {String}\n   * @private\n   */\n  get $loginUrl() {\n    this.profile.$localState = uuid.v4();\n    this.profile.$nonce = uuid.v4();\n\n    let authorizeEndpoint = `${this.$config.providerUrl}/authorize`;\n    if (this.$provider.authorizeEndpoint) {\n      authorizeEndpoint = this.$provider.authorizeEndpoint.call(this, this.$config);\n    }\n\n    return this.$utilities.createUrl(authorizeEndpoint, assign({\n      'state': this.profile.$localState,\n      'nonce': this.profile.$nonce,\n      'response_type': this.$config.responseType,\n      'redirect_uri': this.$config.redirectUrl,\n      'client_id': this.$config.clientId,\n      'scope': this.$config.scope\n    }, this.$config.queryParams));\n  }\n\n  /**\n   * The url to logout of the configured provider\n   * @type {String}\n   * @private\n   */\n  get $deauthorizeUrl() {\n    return this.$provider.deauthorizeUrl.call(this, this.$config);\n  }\n\n  /**\n   * Authenticates using the iframe-based OAuth flow.\n   * @return {Promise} a promise that resolves when we finish authenticating\n   */\n  loginWithIframe() {\n    if (this.$promises.login) {\n      return this.$promises.login;\n    }\n\n    this.profile.$clear();\n    this.$promises.login = this.$utilities.createIframe(this.$loginUrl, true).then(() => {\n      this.$promises.login = null;\n      const error = this.profile.$validate();\n\n      if (error) {\n        this.profile.$clear();\n        return Promise.reject(error);\n      }\n    }).catch((error) => {\n      this.$promises.login = null;\n      return Promise.reject(error);\n    });\n\n    return this.$promises.login;\n  }\n\n  /**\n   * Authenticates using the popup-based OAuth flow.\n   * @return {Promise} a promise that resolves when we finish authenticating\n   */\n  loginWithPopup() {\n    if (this.$promises.login) {\n      return this.$promises.login;\n    }\n\n    this.profile.$clear();\n    this.$promises.login = this.$utilities.openPopup(this.$loginUrl).then(() => {\n      this.$promises.login = null;\n      // We need to utilize local storage to retain our parsed values\n      if (this.$config.storageType === 'session') {\n        this.profile.$$transfer('local', 'session');\n      }\n      const error = this.profile.$validate();\n\n      if (error) {\n        this.profile.$clear();\n        return Promise.reject(error);\n      }\n    }).catch((error) => {\n      this.$promises.login = null;\n      return Promise.reject(error);\n    });\n\n    return this.$promises.login;\n  }\n\n  /**\n   * Authenticates using the redirect-based OAuth flow.\n   */\n  loginWithRedirect() {\n    if (!this.$config.redirectLoginCallback) {\n      throw new ReferenceError('A redirectLoginCallback is required to invoke \"loginWithRedirect\"!');\n    }\n\n    this.profile.$clear();\n    this.profile.$redirectUrl = this.profile.$redirectUrl || location.href;\n    location.href = this.$loginUrl;\n  }\n\n  /**\n   * Unauthenticates using the iframe-based OAuth flow.\n   * @return {Promise} a promise that resolves when we finish deauthenticating\n   */\n  logoutWithIframe() {\n    if (this.$promises.logout) {\n      return this.$promises.logout;\n    }\n\n    this.profile.$clear();\n    this.$promises.logout = this.$utilities.createIframe(this.$deauthorizeUrl).then(() => {\n      this.$promises.logout = null;\n    });\n    return this.$promises.logout;\n  }\n\n  /**\n   * Unauthenticates using the popup-based OAuth flow.\n   * @return {Promise} a promise that resolves when we finish deauthenticating\n   */\n  logoutWithPopup() {\n    if (this.$promises.logout) {\n      return this.$promises.logout;\n    }\n\n    this.profile.$clear();\n    this.$promises.logout = this.$utilities.openPopup(this.$deauthorizeUrl).then(() => {\n      this.$promises.logout = null;\n    });\n\n    return this.$promises.logout;\n  }\n\n  /**\n   * Logs the user out of their configured identity provider.\n   */\n  logoutWithRedirect() {\n    this.profile.$clear();\n    location.href = this.$deauthorizeUrl;\n  }\n\n  /**\n   * Authenticates, requests the access token, and returns it if necessary.\n   * @return {Promise<string>} a promise that resolves when we retrieve the access token\n   */\n  retrieveAccessToken() {\n    if (this.$promises.token) {\n      return this.$promises.token;\n    }\n\n    this.$promises.token = Promise.resolve();\n    if (this.profile.idTokenExpired) {\n      if (this.$config.loginType === 'popup') {\n        this.$promises.token = this.loginWithPopup();\n      } else if ([undefined, null, 'iframe'].indexOf(this.$config.loginType) !== -1) {\n        this.$promises.token = this.loginWithIframe();\n      } else {\n        this.$promises.token = null;\n        return Promise.reject(new ReferenceError(`Invaid Login Type (${this.$config.loginType})`));\n      }\n    }\n\n    this.$promises.token = this.$promises.token.then(() => {\n      this.profile.$clearErrors();\n      if (this.profile.accessTokenExpired) {\n        return this.$utilities.createIframe(this.$accessTokenUrl).then(() => {\n          this.$promises.token = null;\n          const error = this.profile.$validate(true);\n\n          if (error) {\n            return Promise.reject(error);\n          }\n          return this.profile.$accessToken;\n        });\n      }\n      this.$promises.token = null;\n      return this.profile.$accessToken;\n    }).catch((error) => {\n      this.$promises.token = null;\n      return Promise.reject(error);\n    });\n\n    return this.$promises.token;\n  }\n\n  /**\n   * Checks if the current route is secured and authenticates the user if necessary\n   * @ignore\n   */\n  $$onRouteChanged() {\n    if (!this.$utilities.isRouteSecure(location.href, this.$config.routes)) return;\n\n    this.retrieveAccessToken();\n  }\n}\n\nset(window, 'salte.SalteAuth', get(window, 'salte.SalteAuth', SalteAuth));\nexport { SalteAuth };\n\n\n\n// WEBPACK FOOTER //\n// ./salte-auth.js","var v1 = require('./v1');\nvar v4 = require('./v4');\n\nvar uuid = v4;\nuuid.v1 = v1;\nuuid.v4 = v4;\n\nmodule.exports = uuid;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../node_modules/uuid/index.js\n// module id = 5\n// module chunks = 0","var rng = require('./lib/rng');\nvar bytesToUuid = require('./lib/bytesToUuid');\n\n// **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\nvar _nodeId;\nvar _clockseq;\n\n// Previous uuid creation time\nvar _lastMSecs = 0;\nvar _lastNSecs = 0;\n\n// See https://github.com/broofa/node-uuid for API details\nfunction v1(options, buf, offset) {\n  var i = buf && offset || 0;\n  var b = buf || [];\n\n  options = options || {};\n  var node = options.node || _nodeId;\n  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;\n\n  // node and clockseq need to be initialized to random values if they're not\n  // specified.  We do this lazily to minimize issues related to insufficient\n  // system entropy.  See #189\n  if (node == null || clockseq == null) {\n    var seedBytes = rng();\n    if (node == null) {\n      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n      node = _nodeId = [\n        seedBytes[0] | 0x01,\n        seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]\n      ];\n    }\n    if (clockseq == null) {\n      // Per 4.2.2, randomize (14 bit) clockseq\n      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n    }\n  }\n\n  // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();\n\n  // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;\n\n  // Time since last uuid creation (in msecs)\n  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;\n\n  // Per 4.2.1.2, Bump clockseq on clock regression\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  }\n\n  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  }\n\n  // Per 4.2.1.2 Throw error if too many uuids are requested\n  if (nsecs >= 10000) {\n    throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq;\n\n  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n  msecs += 12219292800000;\n\n  // `time_low`\n  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff;\n\n  // `time_mid`\n  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff;\n\n  // `time_high_and_version`\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n  b[i++] = tmh >>> 16 & 0xff;\n\n  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n  b[i++] = clockseq >>> 8 | 0x80;\n\n  // `clock_seq_low`\n  b[i++] = clockseq & 0xff;\n\n  // `node`\n  for (var n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf ? buf : bytesToUuid(b);\n}\n\nmodule.exports = v1;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../node_modules/uuid/v1.js\n// module id = 6\n// module chunks = 0","var rng = require('./lib/rng');\nvar bytesToUuid = require('./lib/bytesToUuid');\n\nfunction v4(options, buf, offset) {\n  var i = buf && offset || 0;\n\n  if (typeof(options) == 'string') {\n    buf = options === 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || bytesToUuid(rnds);\n}\n\nmodule.exports = v4;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../node_modules/uuid/v4.js\n// module id = 7\n// module chunks = 0","import auth0 from './providers/auth0.js';\nimport azure from './providers/azure.js';\nimport cognito from './providers/cognito.js';\nimport wso2 from './providers/wso2.js';\n\n/**\n * A collection of overrides for specific Identity Providers\n */\nclass Providers {\n  /**\n   * Provider for Auth0\n   * @type {SalteAuthAuth0Provider}\n   */\n  static get auth0() {\n    return auth0;\n  }\n\n  /**\n   * Provider for Azure's Active Directory\n   * @type {SalteAuthAzureProvider}\n   */\n  static get azure() {\n    return azure;\n  }\n\n  /**\n   * Provider for Amazon's Cognito\n   * @type {SalteAuthCognitoProvider}\n   */\n  static get cognito() {\n    return cognito;\n  }\n\n  /**\n   * Provider for WSO2's API Gateway\n   * @type {SalteAuthWSO2Provider}\n   */\n  static get wso2() {\n    return wso2;\n  }\n};\n\nexport { Providers };\n\n\n\n// WEBPACK FOOTER //\n// ./salte-auth.providers.js","/**\n * Provider for Auth0\n * @see https://auth0.com\n */\nclass SalteAuthAuth0Provider {\n  /**\n   * Computes the deauthorization url\n   * @param {Config} config configuration for salte auth\n   * @return {String} the deauthorization url\n   */\n  static deauthorizeUrl(config) {\n    return this.$utilities.createUrl(`${config.providerUrl}/v2/logout`, {\n      returnTo: config.redirectUrl,\n      client_id: config.clientId\n    });\n  }\n}\n\nexport default SalteAuthAuth0Provider;\n\n\n\n// WEBPACK FOOTER //\n// ./providers/auth0.js","/** Provider for Azure's Active Directory */\nclass SalteAuthAzureProvider {\n  /**\n   * Computes the authorization endpoint\n   * @param {Config} config configuration for salte auth\n   * @return {String} the authorization endpoint\n   */\n  static authorizeEndpoint(config) {\n    return `${config.providerUrl}/oauth2/authorize`;\n  }\n\n  /**\n   * Computes the deauthorization url\n   * @param {Config} config configuration for salte auth\n   * @return {String} the deauthorization url\n   */\n  static deauthorizeUrl(config) {\n    return this.$utilities.createUrl(`${config.providerUrl}/oauth2/logout`, {\n      post_logout_redirect_uri: config.redirectUrl\n    });\n  }\n}\n\nexport default SalteAuthAzureProvider;\n\n\n\n// WEBPACK FOOTER //\n// ./providers/azure.js","/** Provider for Amazon's Cognito */\nclass SalteAuthCognitoProvider {\n  /**\n   * Computes the authorization endpoint\n   * @param {Config} config configuration for salte auth\n   * @return {String} the authorization endpoint\n   */\n  static authorizeEndpoint(config) {\n    return `${config.providerUrl}/oauth2/authorize`;\n  }\n\n  /**\n   * Computes the deauthorization url\n   * @param {Config} config configuration for salte auth\n   * @return {String} the deauthorization url\n   */\n  static deauthorizeUrl(config) {\n    return this.$utilities.createUrl(`${config.providerUrl}/logout`, {\n      logout_uri: config.redirectUrl,\n      client_id: config.clientId\n    });\n  }\n\n  /**\n   * Provides a set of default config options required for cognito\n   */\n  static get defaultConfig() {\n    return {\n      validation: {\n        // Amazon Cognito doesn't support nonce validation\n        nonce: false\n      }\n    };\n  }\n}\n\nexport default SalteAuthCognitoProvider;\n\n\n\n// WEBPACK FOOTER //\n// ./providers/cognito.js","/** Provider for WSO2's API Gateway */\nclass SalteAuthWSO2Provider {\n  /**\n   * Computes the deauthorization url\n   * @param {Config} config configuration for salte auth\n   * @return {String} the deauthorization url\n   */\n  static deauthorizeUrl(config) {\n    return this.$utilities.createUrl(`${config.providerUrl}/commonauth`, {\n      commonAuthLogout: true,\n      type: 'oidc',\n      commonAuthCallerPath: config.redirectUrl,\n      relyingParty: config.relyingParty\n    });\n  }\n}\n\nexport default SalteAuthWSO2Provider;\n\n\n\n// WEBPACK FOOTER //\n// ./providers/wso2.js","import { defaultsDeep, find, get, set } from 'lodash';\n\n/**\n * All the profile information associated with the current authentication session\n */\nclass SalteAuthProfile {\n  /**\n   * Parses the current url for the authentication values\n   * @param {Config} config configuration for salte auth\n   */\n  constructor(config) {\n    if (window.salte.SalteAuthProfile.$instance) {\n      return window.salte.SalteAuthProfile.$instance;\n    }\n    /** @ignore */\n    this.$$config = defaultsDeep(config, {\n      validation: {\n        nonce: true,\n        state: true,\n        azp: true,\n        aud: true\n      },\n      storageType: 'session'\n    });\n    if (location.hash) {\n      const params = location.hash.replace(/(#!?[^#]+)?#/, '').split('&');\n      for (let i = 0; i < params.length; i++) {\n        const param = params[i];\n        const [key, value] = param.split('=');\n        this.$parse(key, decodeURIComponent(value));\n      }\n    }\n    window.salte.SalteAuthProfile.$instance = this;\n  }\n\n  /**\n   * Parse a key-value pair\n   * @param {String} key the key to parse\n   * @param {Object} value the matching value to parse\n   * @private\n   */\n  $parse(key, value) {\n    switch (key) {\n      case 'token_type':\n        this.$tokenType = value;\n        break;\n      case 'expires_in':\n        this.$expiration = Date.now() + value;\n        break;\n      case 'access_token':\n        this.$accessToken = value;\n        break;\n      case 'id_token':\n        this.$idToken = value;\n        break;\n      case 'state':\n        this.$state = value;\n        break;\n      case 'error':\n        this.$error = value;\n        break;\n      case 'error_description':\n        this.$errorDescription = value;\n        break;\n    }\n  }\n\n  /**\n   * Whether the ID Token has expired\n   * @return {Boolean} true if the \"id_token\" has expired\n   */\n  get idTokenExpired() {\n    return !this.$idToken || Date.now() >= (this.userInfo.exp * 1000);\n  }\n\n  /**\n   * Whether the Access Token has expired\n   * @return {Boolean} true if the \"access_token\" has expired\n   */\n  get accessTokenExpired() {\n    return !this.$accessToken || Date.now() >= this.$expiration;\n  }\n\n  /**\n   * The type of Access Token that was returned by the identity provider\n   * @return {String} the type of access token\n   * @private\n   */\n  get $tokenType() {\n    return this.$storage.getItem('salte.auth.token-type');\n  }\n\n  set $tokenType(tokenType) {\n    this.$saveItem('salte.auth.token-type', tokenType);\n  }\n\n  /**\n   * The date and time that the access token will expire\n   * @return {String} the expiration time as unix timestamp\n   * @private\n   */\n  get $expiration() {\n    return this.$storage.getItem('salte.auth.expiration');\n  }\n\n  set $expiration(expiration) {\n    this.$saveItem('salte.auth.expiration', expiration);\n  }\n\n  /**\n   * The Access Token returned by the identity provider\n   * @return {String} the access token\n   * @private\n   */\n  get $accessToken() {\n    return this.$storage.getItem('salte.auth.access-token');\n  }\n\n  set $accessToken(accessToken) {\n    this.$saveItem('salte.auth.access-token', accessToken);\n  }\n\n  /**\n   * The ID Token returned by the identity provider\n   * @return {String} the id token\n   * @private\n   */\n  get $idToken() {\n    return this.$storage.getItem('salte.auth.id-token');\n  }\n\n  set $idToken(idToken) {\n    this.$saveItem('salte.auth.id-token', idToken);\n  }\n\n  /**\n   * The authentication state returned by the identity provider\n   * @return {String} the state value\n   * @private\n   *\n   * @see https://tools.ietf.org/html/rfc6749#section-4.1.1\n   */\n  get $state() {\n    return this.$storage.getItem('salte.auth.state');\n  }\n\n  set $state(state) {\n    this.$saveItem('salte.auth.state', state);\n  }\n\n  /**\n   * The locally generate authentication state\n   * @return {String} the local state value\n   * @private\n   *\n   * @see https://tools.ietf.org/html/rfc6749#section-4.1.1\n   */\n  get $localState() {\n    return this.$storage.getItem('salte.auth.local-state');\n  }\n\n  set $localState(localState) {\n    this.$saveItem('salte.auth.local-state', localState);\n  }\n\n  /**\n   * The error returned by the identity provider\n   * @return {String} the state value\n   * @private\n   */\n  get $error() {\n    return this.$storage.getItem('salte.auth.error');\n  }\n\n  set $error(error) {\n    this.$saveItem('salte.auth.error', error);\n  }\n\n  /**\n   * The error description returned by the identity provider\n   * @return {String} a string that describes the error that occurred\n   * @private\n   */\n  get $errorDescription() {\n    return this.$storage.getItem('salte.auth.error-description');\n  }\n\n  set $errorDescription(errorDescription) {\n    this.$saveItem('salte.auth.error-description', errorDescription);\n  }\n\n  /**\n   * The url the user originated from before authentication occurred\n   * @return {String} The url the user originated from before authentication occurred\n   * @private\n   */\n  get $redirectUrl() {\n    return this.$storage.getItem('salte.auth.$redirect-url');\n  }\n\n  set $redirectUrl(redirectUrl) {\n    this.$saveItem('salte.auth.$redirect-url', redirectUrl);\n  }\n\n  /**\n   * Parses the User Info from the ID Token\n   * @return {String} The User Info from the ID Token\n   * @private\n   */\n  get $nonce() {\n    return this.$storage.getItem('salte.auth.nonce');\n  }\n\n  set $nonce(nonce) {\n    this.$saveItem('salte.auth.nonce', nonce);\n  }\n\n  /**\n   * Parses the User Info from the ID Token\n   * @return {Object} The User Info from the ID Token\n   */\n  get userInfo() {\n    if (this.$idToken) {\n      const separatedToken = this.$idToken.split('.');\n      if (separatedToken.length === 3) {\n        return JSON.parse(atob(separatedToken[1]));\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Verifies that we were logged in successfully and that all security checks pass\n   * @param {Boolean} accessTokenRequest if the request we're validating was an access token request\n   * @return {Object} the error message\n   * @private\n   */\n  $validate(accessTokenRequest) {\n    if (!this.$$config.validation) {\n      return;\n    }\n\n    if (this.$error) {\n      return {\n        code: this.$error,\n        description: this.$errorDescription\n      };\n    }\n\n    if (!this.$idToken) {\n      return {\n        code: 'login_canceled',\n        description: 'User likely canceled the login or something unexpected occurred.'\n      };\n    }\n\n    if (this.$$config.validation.state && this.$localState !== this.$state) {\n      return {\n        code: 'invalid_state',\n        description: 'State provided by identity provider did not match local state.'\n      };\n    }\n\n    if (accessTokenRequest) return;\n\n    if (this.$$config.validation.nonce && this.$nonce !== this.userInfo.nonce) {\n      return {\n        code: 'invalid_nonce',\n        description: 'Nonce provided by identity provider did not match local nonce.'\n      };\n    }\n\n    if (Array.isArray(this.userInfo.aud)) {\n      if (this.$$config.validation.azp) {\n        if (!this.userInfo.azp) {\n          return {\n            code: 'invalid_azp',\n            description: 'Audience was returned as an array and AZP was not present on the ID Token.'\n          };\n        }\n\n        if (this.userInfo.azp !== this.$$config.clientId) {\n          return {\n            code: 'invalid_azp',\n            description: 'AZP does not match the Client ID.'\n          };\n        }\n      }\n\n\n      if (this.$$config.validation.aud) {\n        const aud = find(this.userInfo.aud, (audience) => {\n          return audience === this.$$config.clientId;\n        });\n\n        if (!aud) {\n          return {\n            code: 'invalid_aud',\n            description: 'None of the audience values matched the Client ID.'\n          };\n        }\n      }\n    } else if (this.$$config.validation.aud && this.userInfo.aud !== this.$$config.clientId) {\n      return {\n        code: 'invalid_aud',\n        description: 'The audience did not match the Client ID.'\n      };\n    }\n  }\n\n  /**\n   * Saves a value to the Web Storage API\n   * @param {String} key The key to save to\n   * @param {*} value The value to save, if this is undefined or null it will delete the key\n   * @private\n   */\n  $saveItem(key, value) {\n    if ([undefined, null].indexOf(value) !== -1) {\n      this.$storage.removeItem(key);\n    } else {\n      this.$storage.setItem(key, value);\n    }\n  }\n\n  /**\n   * Return the active Web Storage API\n   * @return {Storage} the storage api to save and pull values from\n   * @private\n   */\n  get $storage() {\n    return this.$$getStorage(this.$$config.storageType);\n  }\n\n  /**\n   * Determines which Web Storage API to return using the name provided\n   * @param {String} storageType the name of the storageType to use\n   * @return {Storage} the web storage api that matches the given string\n   * @ignore\n   */\n  $$getStorage(storageType) {\n    if (storageType === 'local') {\n      return localStorage;\n    } else if (storageType === 'session') {\n      return sessionStorage;\n    } else {\n      throw new ReferenceError(`Unknown Storage Type (${storageType})`);\n    }\n  }\n\n  /**\n   * Transfers values from one storage type to the other\n   * @param {String} source the name of the storage type to pull from\n   * @param {String} destination the name of the storage type to push to\n   * @ignore\n   */\n  $$transfer(source, destination) {\n    const sourceStorage = this.$$getStorage(source);\n    const destinationStorage = this.$$getStorage(destination);\n\n    for (const key in sourceStorage) {\n      if (key.indexOf('salte.auth.') !== 0) continue;\n\n      destinationStorage.setItem(key, sourceStorage.getItem(key));\n      sourceStorage.removeItem(key);\n    }\n  }\n\n  /**\n   * Clears all `salte.auth` values from localStorage\n   * @private\n   */\n  $clear() {\n    for (const key in this.$storage) {\n      if (key.match(/^salte\\.auth\\.[^$]/)) {\n        this.$saveItem(key, undefined);\n      }\n    }\n  }\n\n  /**\n   * Clears all `salte.auth` error values from localStorage\n   * @private\n   */\n  $clearErrors() {\n    this.$error = undefined;\n    this.$errorDescription = undefined;\n  }\n}\n\nset(window, 'salte.SalteAuthProfile', get(window, 'salte.SalteAuthProfile', SalteAuthProfile));\nexport { SalteAuthProfile };\n\n\n\n// WEBPACK FOOTER //\n// ./salte-auth.profile.js","import { assign, get, set } from 'lodash';\n\n/**\n * Basic utilities to support the authentication flow\n */\nclass SalteAuthUtilities {\n  /**\n   * Wraps all XHR and Fetch (if available) requests to allow promise interceptors\n   */\n  constructor() {\n    if (window.salte.SalteAuthUtilities.$instance) {\n      return window.salte.SalteAuthUtilities.$instance;\n    }\n\n    /** @ignore */\n    this.$interceptors = {\n      fetch: [],\n      xhr: []\n    };\n\n    (function(open) {\n      XMLHttpRequest.prototype.open = function(method, url) {\n        /** @ignore */\n        this.$url = url;\n        return open.call(this, method, url);\n      };\n    })(XMLHttpRequest.prototype.open);\n\n    const self = this;\n    (function(send) {\n      XMLHttpRequest.prototype.send = function(data) {\n        const promises = [];\n        for (let i = 0; i < self.$interceptors.xhr.length; i++) {\n          const interceptor = self.$interceptors.xhr[i];\n          promises.push(interceptor(this, data));\n        }\n        Promise.all(promises).then(() => {\n          send.call(this, data);\n        }).catch((error) => {\n          const event = document.createEvent('Event');\n          event.initEvent('error', false, true);\n          event.detail = error;\n          this.dispatchEvent(event);\n        });\n      };\n    })(XMLHttpRequest.prototype.send);\n\n    if (window.fetch) {\n      (function(fetch) {\n        window.fetch = function(input, options = {}) {\n          const promises = [];\n          for (let i = 0; i < self.$interceptors.fetch.length; i++) {\n            const interceptor = self.$interceptors.fetch[i];\n            promises.push(interceptor(input, options));\n          }\n          return Promise.all(promises).then(() => {\n            return fetch.call(this, input, options);\n          });\n        };\n      })(fetch);\n    }\n    window.salte.SalteAuthUtilities.$instance = this;\n  }\n\n  /**\n   * Creates a URL using a base url and a queryParams object\n   * @param {String} baseUrl the base url to attach the queryParams to\n   * @param {Object} queryParams the queryParams to attach to the baseUrl\n   * @return {String} the url with the request queryParams\n   */\n  createUrl(baseUrl, queryParams = {}) {\n    let url = baseUrl;\n\n    Object.keys(queryParams).forEach((key) => {\n      const value = queryParams[key];\n      if ([undefined, null, ''].indexOf(value) === -1) {\n        url += `${url.indexOf('?') === -1 ? '?' : '&'}${key}=${encodeURIComponent(value)}`;\n      }\n    });\n\n    return url;\n  }\n\n  /**\n   * Converts a url to an absolute url\n   * @param {String} path the url path to resolve to an absolute url\n   * @return {String} the absolutely resolved url\n   */\n  resolveUrl(path) {\n    if (!this.$$urlDocument) {\n      /** @ignore */\n      this.$$urlDocument = document.implementation.createHTMLDocument('url');\n      /** @ignore */\n      this.$$urlBase = this.$$urlDocument.createElement('base');\n      /** @ignore */\n      this.$$urlAnchor = this.$$urlDocument.createElement('a');\n      this.$$urlDocument.head.appendChild(this.$$urlBase);\n    }\n    this.$$urlBase.href = window.location.protocol + '//' + window.location.host;\n    this.$$urlAnchor.href = path.replace(/ /g, '%20');\n    return this.$$urlAnchor.href;\n  }\n\n  /**\n   * Checks if the given url matches any of the test urls\n   * @param {String} url The url to test\n   * @param {Array<String|RegExp>} tests The urls to match the test url against\n   * @return {Boolean} true if the url matches one of the tests\n   */\n  checkForMatchingUrl(url, tests = []) {\n    const resolvedUrl = this.resolveUrl(url);\n    for (let i = 0; i < tests.length; i++) {\n      const test = tests[i];\n      if (test instanceof RegExp) {\n        return !!resolvedUrl.match(test);\n      } else {\n        return resolvedUrl.indexOf(this.resolveUrl(test)) === 0;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Determines if the given route is a secured route\n   * @param {String} route the route to verify\n   * @param {Boolean|Array<String>} securedRoutes a list of routes that require authentication\n   * @return {Boolean} true if the route provided is a secured route\n   */\n  isRouteSecure(route, securedRoutes) {\n    if (securedRoutes === true) {\n      return true;\n    } else if (securedRoutes instanceof Array) {\n      return this.checkForMatchingUrl(route, securedRoutes);\n    }\n    return false;\n  }\n\n  /**\n   * Opens a popup window in the middle of the viewport\n   * @param {String} url the url to be loaded\n   * @param {String} name the name of the window\n   * @param {Number} height the height of the window\n   * @param {Number} width the width of the window\n   * @return {Promise} resolves when the popup is closed\n   */\n  openPopup(url, name = 'salte-auth', height = 600, width = 400) {\n    const top = ((window.innerHeight / 2) - (height / 2)) + window.screenTop;\n    const left = ((window.innerWidth / 2) - (width / 2)) + window.screenLeft;\n    const popupWindow = window.open(url, name, `height=${height}, width=${width}, status=yes, toolbar=no, menubar=no, location=no, top=${top}, left=${left}`);\n    if (!popupWindow) {\n      return Promise.reject(new ReferenceError('We were unable to open the popup window, its likely that the request was blocked.'));\n    }\n\n    popupWindow.focus();\n    // TODO: Find a better way of tracking when a Popup Window closes.\n    return new Promise((resolve) => {\n      const checker = setInterval(() => {\n        if (!popupWindow.closed) return;\n        clearInterval(checker);\n        setTimeout(resolve);\n      }, 100);\n    });\n  }\n\n  /**\n   * Opens an iframe in the background\n   * @param {String} url the url to be loaded\n   * @param {Boolean} show whether the iframe should be visible\n   * @return {Promise} resolves when the iframe is closed\n   */\n  createIframe(url, show) {\n    const iframe = document.createElement('iframe');\n    iframe.setAttribute('owner', 'salte-auth');\n    if (show) {\n      assign(iframe.style, {\n        position: 'fixed',\n        top: 0,\n        bottom: 0,\n        left: 0,\n        right: 0,\n        height: '100%',\n        width: '100%',\n        zIndex: 9999,\n        border: 'none',\n\n        opacity: 0,\n        transition: '0.5s opacity'\n      });\n\n      setTimeout(() => {\n        iframe.style.opacity = 1;\n      });\n    } else {\n      iframe.style.display = 'none';\n    }\n    iframe.src = url;\n    document.body.appendChild(iframe);\n    return new Promise((resolve) => {\n      iframe.addEventListener('DOMNodeRemoved', () => {\n        setTimeout(resolve);\n      });\n    });\n  }\n\n  /**\n   * Adds a XMLHttpRequest interceptor\n   * @param {Function} interceptor the interceptor function\n   */\n  addXHRInterceptor(interceptor) {\n    this.$interceptors.xhr.push(interceptor);\n  }\n\n  /**\n   * Adds a fetch interceptor\n   * @param {Function} interceptor the interceptor function\n   */\n  addFetchInterceptor(interceptor) {\n    this.$interceptors.fetch.push(interceptor);\n  }\n\n  /**\n   * Checks if the current window is an iframe\n   * @return {HTMLIFrameElement} true if the current window is an iframe.\n   * @private\n   */\n  get $iframe() {\n    if (window.self === window.top) {\n      return null;\n    }\n    return parent.document.querySelector('body > iframe[owner=\"salte-auth\"]');\n  }\n\n  /**\n   * Determines if the current window is a popup window opened by salte auth\n   * @return {Window} the window object\n   * @private\n   */\n  get $popup() {\n    if (window.opener && window.name === 'salte-auth') {\n      return window;\n    }\n    return null;\n  }\n}\n\nset(window, 'salte.SalteAuthUtilities', get(window, 'salte.SalteAuthUtilities', SalteAuthUtilities));\nexport { SalteAuthUtilities };\n\n\n\n// WEBPACK FOOTER //\n// ./salte-auth.utilities.js"],"sourceRoot":""}