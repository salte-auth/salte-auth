{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///salte-auth.js","webpack:///webpack/bootstrap d5ca05275691deb67c2c","webpack:///./salte-auth.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","global","_classCallCheck","instance","Constructor","TypeError","Object","defineProperty","value","_typeof","Symbol","iterator","obj","constructor","prototype","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","protoProps","staticProps","AuthenticationContext","config","REQUEST_TYPE","LOGIN","RENEW_TOKEN","UNKNOWN","CONSTANTS","ACCESS_TOKEN","EXPIRES_IN","ID_TOKEN","ERROR_DESCRIPTION","SESSION_STATE","STORAGE","TOKEN_KEYS","ACCESS_TOKEN_KEY","EXPIRATION_KEY","STATE_LOGIN","STATE_RENEW","NONCE_IDTOKEN","USERNAME","IDTOKEN","ERROR","LOGIN_REQUEST","LOGIN_ERROR","RENEW_STATUS","RESOURCE_DELIMETER","LOADFRAME_TIMEOUT","TOKEN_RENEW_STATUS_CANCELED","TOKEN_RENEW_STATUS_COMPLETED","TOKEN_RENEW_STATUS_IN_PROGRESS","LOGGING_LEVEL","WARN","INFO","VERBOSE","LEVEL_STRING_MAP","0","1","2","3","POPUP_WIDTH","POPUP_HEIGHT","window","callback","popUp","isAngular","crypto","msCrypto","_user","_activeRenewals","_loginInProgress","_renewStates","callBackMappedToRenewStates","callBacksMappedToRenewStates","displayCall","Error","clientId","_cloneConfig","match","loginResource","redirectUri","location","href","anonymousEndpoints","setResponseType","responseType","startPage","info","expectedState","_guid","state","_idTokenNonce","verbose","_saveItem","urlNavigate","_getNavigateUrl","encodeURIComponent","_loginPopup","promptUser","title","popUpWidth","popUpHeight","winLeft","screenLeft","screenX","winTop","screenTop","screenY","width","innerWidth","document","documentElement","clientWidth","body","height","innerHeight","clientHeight","left","top","popupWindow","open","focus","e","warn","message","_this","_openPopup","_getItem","registeredRedirectUri","indexOf","split","pollTimer","setInterval","closed","undefined","clearInterval","hash","handleWindowCallback","search","close","keys","_isEmpty","resource","_hasResource","token","expired","offset","expireOffsetSeconds","_now","idtoken","_createUser","_this2","push","error","frameHandle","_addAuthFrame","_addHintParameters","registerCallback","src","_loadFrameTimeout","idTokenNonce","name","url","regex","RegExp","test","urlNavigation","frameName","_this3","_loadFrame","setTimeout","_this4","frameCheck","getCachedToken","_renewIdToken","_renewToken","navigate","clearCache","logout","postLogoutRedirectUri","str","profile","hasOwnProperty","upn","_urlContainsQueryStringParameter","parts","idToken","user","parsedJson","_extractIdToken","audienceMatch","Array","isArray","aud","azp","toLowerCase","userName","email","sub","substring","parameters","_getHash","_deserialize","_getSearch","searchParameters","_extend","_getParameters","requestInfo","valid","stateMatch","stateResponse","requestType","parent","statesInParentContext","splitIndex","_getResourceFromState","error_description","_expiresIn","nonce","exp","endpoint","endpoints","configEndpoint","_getHostFromUri","uri","extractedUri","String","replace","isCallback","getRequestInfo","saveTokenFromHash","isIframe","_serialize","_addLibMetadata","scope","encodedIdToken","decodedToken","_decodeJwt","base64IdToken","JWSPayload","base64Decoded","_base64DecodeStringUrlSafe","JSON","parse","err","decodeURIComponent","escape","atob","jwtToken","idTokenPartsRegex","matches","exec","crackedToken","header","JWSSig","slice","extraQueryParameter","correlationId","join","query","pl","decode","s","number","hex","toString","getRandomValues","buffer","Uint8Array","_decimalToHex","guidHolder","r","guidResponse","Math","random","expires","parseInt","round","Date","getTime","iframeId","authFrame","getElementById","createElement","opera","navigator","userAgent","ifr","setAttribute","style","visibility","position","borderWidth","getElementsByTagName","appendChild","insertAdjacentHTML","frames","cacheLocation","_supportsLocalStorage","localStorage","setItem","_supportsSessionStorage","sessionStorage","getItem","copy","attr","_libVersion","level","Logging","timestamp","toUTCString","formattedMessage","stack","log","features"],"mappings":"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","file":"salte-auth.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"salte-auth\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"salte-auth\"] = factory();\n\telse\n\t\troot[\"salte-auth\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","/**\n * salte-auth JavaScript Library v1.0.5\n *\n * @license MIT (https://github.com/salte-io/salte-auth/blob/master/LICENSE)\n *\n * Made with ♥ by Ceci <admin@cecilias.me>, Dave Woodward <dave@salte.io>\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"salte-auth\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"salte-auth\"] = factory();\n\telse\n\t\troot[\"salte-auth\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/**\n\t * @public\n\t * @class Config\n\t * @property {clientId}        Identifier assigned to your app by Azure Active Directory\n\t * @property {redirectUri}     Endpoint at which you expect to receive tokens\n\t * @property {instance}        This is the URL path to the identity provider that authorize and logout will be called against.\n\t * @property {endpoints}       Collection of {Endpoint-ResourceId} used for autmatically attaching tokens in webApi calls\n\t * @property {scope}           This may be used to define the specific authorization(s) being requested from the resource owner.\n\t */\n\t\n\t/**\n\t * User information from idtoken.\n\t *  @class User\n\t *  @property {string} userName - username assigned from upn, email, or sub (i.e. subject).\n\t *  @property {object} profile - properties parsed from idtoken.\n\t */\n\t\n\t/**\n\t * Creates a new AuthenticationContext object.\n\t * @constructor\n\t * @param {object}  config               Configuration options for AuthenticationContext\n\t */\n\tvar AuthenticationContext = function () {\n\t  function AuthenticationContext(config) {\n\t    _classCallCheck(this, AuthenticationContext);\n\t\n\t    /**\n\t    * Enum for request type\n\t    * @enum {string}\n\t    */\n\t    this.REQUEST_TYPE = {\n\t      LOGIN: 'LOGIN',\n\t      RENEW_TOKEN: 'RENEW_TOKEN',\n\t      UNKNOWN: 'UNKNOWN'\n\t    };\n\t\n\t    /**\n\t    * Enum for storage constants\n\t    * @enum {string}\n\t    */\n\t    this.CONSTANTS = {\n\t      ACCESS_TOKEN: 'access_token',\n\t      EXPIRES_IN: 'expires_in',\n\t      ID_TOKEN: 'id_token',\n\t      ERROR_DESCRIPTION: 'error_description',\n\t      SESSION_STATE: 'session_state',\n\t      STORAGE: {\n\t        TOKEN_KEYS: 'auth.token.keys',\n\t        ACCESS_TOKEN_KEY: 'auth.access.token.key',\n\t        EXPIRATION_KEY: 'auth.expiration.key',\n\t        STATE_LOGIN: 'auth.state.login',\n\t        STATE_RENEW: 'auth.state.renew',\n\t        NONCE_IDTOKEN: 'auth.nonce.idtoken',\n\t        SESSION_STATE: 'auth.session.state',\n\t        USERNAME: 'auth.username',\n\t        IDTOKEN: 'auth.idtoken',\n\t        ERROR: 'auth.error',\n\t        ERROR_DESCRIPTION: 'auth.error.description',\n\t        LOGIN_REQUEST: 'auth.login.request',\n\t        LOGIN_ERROR: 'auth.login.error',\n\t        RENEW_STATUS: 'auth.token.renew.status'\n\t      },\n\t      RESOURCE_DELIMETER: '|',\n\t      LOADFRAME_TIMEOUT: '6000',\n\t      TOKEN_RENEW_STATUS_CANCELED: 'Canceled',\n\t      TOKEN_RENEW_STATUS_COMPLETED: 'Completed',\n\t      TOKEN_RENEW_STATUS_IN_PROGRESS: 'In Progress',\n\t      LOGGING_LEVEL: {\n\t        ERROR: 0,\n\t        WARN: 1,\n\t        INFO: 2,\n\t        VERBOSE: 3\n\t      },\n\t      LEVEL_STRING_MAP: {\n\t        0: 'ERROR:',\n\t        1: 'WARNING:',\n\t        2: 'INFO:',\n\t        3: 'VERBOSE:'\n\t      },\n\t      POPUP_WIDTH: 483,\n\t      POPUP_HEIGHT: 600\n\t    };\n\t\n\t    if (window.AuthenticationContext) {\n\t      return window.AuthenticationContext;\n\t    }\n\t    window.AuthenticationContext = this;\n\t\n\t    // public\n\t    this.config = {};\n\t    this.callback = null;\n\t    this.popUp = false;\n\t    this.isAngular = false;\n\t    this.crypto = window.crypto || window.msCrypto;\n\t\n\t    // private\n\t    this._user = null;\n\t    this._activeRenewals = {};\n\t    this._loginInProgress = false;\n\t    this._renewStates = [];\n\t\n\t    this.callBackMappedToRenewStates = {};\n\t    this.callBacksMappedToRenewStates = {};\n\t\n\t    // validate before constructor assignments\n\t    if (config.displayCall && typeof config.displayCall !== 'function') {\n\t      throw new Error('displayCall is not a function');\n\t    }\n\t\n\t    if (!config.clientId) {\n\t      throw new Error('clientId is required');\n\t    }\n\t\n\t    this.config = this._cloneConfig(config);\n\t\n\t    if (this.config.popUp) {\n\t      this.popUp = true;\n\t    }\n\t\n\t    if (this.config.callback && typeof this.config.callback === 'function') {\n\t      this.callback = this.config.callback;\n\t    }\n\t\n\t    if (!this.config.instance || !this.config.instance.match(/^https:\\/\\/.*\\/$/)) {\n\t      throw new Error('instance must be a valid https endpoint that ends in a forward slash.');\n\t    }\n\t\n\t    // App can request idtoken for itself using clientid as resource\n\t    if (!this.config.loginResource) {\n\t      this.config.loginResource = this.config.clientId;\n\t    }\n\t\n\t    if (!this.config.redirectUri) {\n\t      this.config.redirectUri = window.location.href;\n\t    }\n\t\n\t    if (!this.config.anonymousEndpoints) {\n\t      this.config.anonymousEndpoints = [];\n\t    }\n\t\n\t    if (this.config.isAngular) {\n\t      this.isAngular = this.config.isAngular;\n\t    }\n\t\n\t    this.setResponseType(this.config.responseType);\n\t  }\n\t\n\t  _createClass(AuthenticationContext, [{\n\t    key: 'setResponseType',\n\t    value: function setResponseType(responseType) {\n\t      this.config.responseType = responseType || this.CONSTANTS.ID_TOKEN;\n\t    }\n\t\n\t    /**\n\t     * Gets initial Idtoken for the app backend\n\t     * Saves the resulting Idtoken in localStorage.\n\t     * @param {string} startPage the start page\n\t     */\n\t\n\t  }, {\n\t    key: 'login',\n\t    value: function login(startPage) {\n\t      // Token is not present and user needs to login\n\t      if (this._loginInProgress) {\n\t        this.info('Login in progress');\n\t        return;\n\t      }\n\t      var expectedState = this._guid();\n\t      this.config.state = expectedState;\n\t      this._idTokenNonce = this._guid();\n\t      if (!startPage) {\n\t        startPage = window.location;\n\t      }\n\t      this.verbose('Expected state: ' + expectedState + ' startPage:' + startPage);\n\t      this._saveItem(this.CONSTANTS.STORAGE.LOGIN_REQUEST, startPage);\n\t      this._saveItem(this.CONSTANTS.STORAGE.LOGIN_ERROR, '');\n\t      this._saveItem(this.CONSTANTS.STORAGE.STATE_LOGIN, expectedState);\n\t      this._saveItem(this.CONSTANTS.STORAGE.NONCE_IDTOKEN, this._idTokenNonce);\n\t      this._saveItem(this.CONSTANTS.STORAGE.ERROR, '');\n\t      this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, '');\n\t      var urlNavigate = this._getNavigateUrl(this.config.responseType, null) + '&nonce=' + encodeURIComponent(this._idTokenNonce);\n\t      this._loginInProgress = true;\n\t      if (this.popUp) {\n\t        this._loginPopup(urlNavigate);\n\t        return;\n\t      }\n\t      if (this.config.displayCall) {\n\t        // User defined way of handling the navigation\n\t        this.config.displayCall(urlNavigate);\n\t      } else {\n\t        this.promptUser(urlNavigate);\n\t      }\n\t    }\n\t  }, {\n\t    key: '_openPopup',\n\t    value: function _openPopup(urlNavigate, title, popUpWidth, popUpHeight) {\n\t      try {\n\t        /**\n\t        * adding winLeft and winTop to account for dual monitor\n\t        * using screenLeft and screenTop for IE8 and earlier\n\t        */\n\t        var winLeft = window.screenLeft ? window.screenLeft : window.screenX;\n\t        var winTop = window.screenTop ? window.screenTop : window.screenY;\n\t        /**\n\t        * window.innerWidth displays browser window's height and width excluding toolbars\n\t        * using document.documentElement.clientWidth for IE8 and earlier\n\t        */\n\t        var width = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;\n\t        var height = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;\n\t        var left = width / 2 - popUpWidth / 2 + winLeft;\n\t        var top = height / 2 - popUpHeight / 2 + winTop;\n\t\n\t        var popupWindow = this.open(urlNavigate, title, 'width=' + popUpWidth + ', height=' + popUpHeight + ', top=' + top + ', left=' + left);\n\t        if (popupWindow.focus) {\n\t          popupWindow.focus();\n\t        }\n\t        return popupWindow;\n\t      } catch (e) {\n\t        this.warn('Error opening popup, ' + e.message);\n\t        this._loginInProgress = false;\n\t        return null;\n\t      }\n\t    }\n\t  }, {\n\t    key: '_loginPopup',\n\t    value: function _loginPopup(urlNavigate) {\n\t      var _this = this;\n\t\n\t      var popupWindow = this._openPopup(urlNavigate, 'login', this.CONSTANTS.POPUP_WIDTH, this.CONSTANTS.POPUP_HEIGHT);\n\t      if (popupWindow === null) {\n\t        this.warn('Popup Window is null. This can happen if you are using IE');\n\t        this._saveItem(this.CONSTANTS.STORAGE.ERROR, 'Error opening popup');\n\t        this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, 'Popup Window is null. This can happen if you are using IE');\n\t        this._saveItem(this.CONSTANTS.STORAGE.LOGIN_ERROR, 'Popup Window is null. This can happen if you are using IE');\n\t        if (this.callback) {\n\t          this.callback(this._getItem(this.CONSTANTS.STORAGE.LOGIN_ERROR), null);\n\t        }\n\t        return;\n\t      }\n\t      var registeredRedirectUri = void 0;\n\t      if (this.config.redirectUri.indexOf('#') === -1) {\n\t        registeredRedirectUri = this.config.redirectUri;\n\t      } else {\n\t        registeredRedirectUri = this.config.redirectUri.split('#')[0];\n\t      }\n\t      var pollTimer = window.setInterval(function () {\n\t        if (!popupWindow || popupWindow.closed || popupWindow.closed === undefined) {\n\t          _this._loginInProgress = false;\n\t          window.clearInterval(pollTimer);\n\t        }\n\t        try {\n\t          if (popupWindow.location.href.indexOf(registeredRedirectUri) !== -1) {\n\t            if (_this.isAngular) {\n\t              window.location.hash = popupWindow.location.hash;\n\t            } else {\n\t              _this.handleWindowCallback(popupWindow.location.hash, popupWindow.location.search);\n\t            }\n\t            window.clearInterval(pollTimer);\n\t            _this._loginInProgress = false;\n\t            _this.info('Closing popup window');\n\t            popupWindow.close();\n\t          }\n\t        } catch (e) {}\n\t      }, 20);\n\t    }\n\t  }, {\n\t    key: 'loginInProgress',\n\t    value: function loginInProgress() {\n\t      return this._loginInProgress;\n\t    }\n\t  }, {\n\t    key: '_hasResource',\n\t    value: function _hasResource(key) {\n\t      var keys = this._getItem(this.CONSTANTS.STORAGE.TOKEN_KEYS);\n\t      return keys && !this._isEmpty(keys) && keys.indexOf(key + this.CONSTANTS.RESOURCE_DELIMETER) > -1;\n\t    }\n\t\n\t    /**\n\t     * Gets token for the specified resource from local storage cache\n\t     * @param {string}   resource A URI that identifies the resource for which the token is valid.\n\t     * @return {string} token if exists and not expired or null\n\t     */\n\t\n\t  }, {\n\t    key: 'getCachedToken',\n\t    value: function getCachedToken(resource) {\n\t      if (!this._hasResource(resource)) {\n\t        return null;\n\t      }\n\t\n\t      var token = this._getItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY + resource);\n\t      var expired = this._getItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY + resource);\n\t\n\t      // If expiration is within offset, it will force renew\n\t      var offset = this.config.expireOffsetSeconds || 120;\n\t\n\t      if (expired && expired > this._now() + offset) {\n\t        return token;\n\t      }\n\t      this._saveItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY + resource, '');\n\t      this._saveItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY + resource, 0);\n\t      return null;\n\t    }\n\t\n\t    /**\n\t     * Retrieves and parse idToken from localstorage\n\t     * @return {User} user object\n\t     */\n\t\n\t  }, {\n\t    key: 'getCachedUser',\n\t    value: function getCachedUser() {\n\t      if (this._user) {\n\t        return this._user;\n\t      }\n\t\n\t      var idtoken = this._getItem(this.CONSTANTS.STORAGE.IDTOKEN);\n\t      this._user = this._createUser(idtoken);\n\t      return this._user;\n\t    }\n\t  }, {\n\t    key: 'registerCallback',\n\t    value: function registerCallback(expectedState, resource, callback) {\n\t      var _this2 = this;\n\t\n\t      this._activeRenewals[resource] = expectedState;\n\t      if (!this.callBacksMappedToRenewStates[expectedState]) {\n\t        this.callBacksMappedToRenewStates[expectedState] = [];\n\t      }\n\t      this.callBacksMappedToRenewStates[expectedState].push(callback);\n\t      if (!this.callBackMappedToRenewStates[expectedState]) {\n\t        this.callBackMappedToRenewStates[expectedState] = function (message, token) {\n\t          for (var i = 0; i < _this2.callBacksMappedToRenewStates[expectedState].length; ++i) {\n\t            try {\n\t              _this2.callBacksMappedToRenewStates[expectedState][i](message, token);\n\t            } catch (error) {\n\t              _this2.warn(error);\n\t            }\n\t          }\n\t          _this2._activeRenewals[resource] = null;\n\t          _this2.callBacksMappedToRenewStates[expectedState] = null;\n\t          _this2.callBackMappedToRenewStates[expectedState] = null;\n\t        };\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Acquires access token with hidden iframe\n\t     * @param {string} resource  ResourceUri identifying the target resource\n\t     * @param {string} callback  ResourceUri identifying the target resource\n\t     */\n\t\n\t  }, {\n\t    key: '_renewToken',\n\t    value: function _renewToken(resource, callback) {\n\t      // use iframe to try refresh token\n\t      // use given resource to create new authz url\n\t      this.info('renewToken is called for resource:' + resource);\n\t      var frameHandle = this._addAuthFrame('authRenewFrame' + resource);\n\t      var expectedState = this._guid() + '|' + resource;\n\t      this.config.state = expectedState;\n\t      // renew happens in iframe, so it keeps javascript context\n\t      this._renewStates.push(expectedState);\n\t\n\t      this.verbose('Renew token Expected state: ' + expectedState);\n\t      var urlNavigate = this._getNavigateUrl('token', resource) + '&prompt=none';\n\t      urlNavigate = this._addHintParameters(urlNavigate);\n\t\n\t      this.registerCallback(expectedState, resource, callback);\n\t      this.verbose('Navigate to:' + urlNavigate);\n\t      this._saveItem(this.CONSTANTS.STORAGE.LOGIN_REQUEST, '');\n\t      frameHandle.src = 'about:blank';\n\t      this._loadFrameTimeout(urlNavigate, 'authRenewFrame' + resource, resource);\n\t    }\n\t  }, {\n\t    key: '_renewIdToken',\n\t    value: function _renewIdToken(callback) {\n\t      // use iframe to try refresh token\n\t      this.info('renewIdToken is called');\n\t      var frameHandle = this._addAuthFrame('authIdTokenFrame');\n\t      var expectedState = this._guid() + '|' + this.config.clientId;\n\t      this._idTokenNonce = this._guid();\n\t      this._saveItem(this.CONSTANTS.STORAGE.NONCE_IDTOKEN, this._idTokenNonce);\n\t      this.config.state = expectedState;\n\t      // renew happens in iframe, so it keeps javascript context\n\t      this._renewStates.push(expectedState);\n\t\n\t      this.verbose('Renew Idtoken Expected state: ' + expectedState);\n\t      var urlNavigate = this._getNavigateUrl(this.config.responseType, null) + '&prompt=none';\n\t      urlNavigate = this._addHintParameters(urlNavigate);\n\t\n\t      urlNavigate += '&nonce=' + encodeURIComponent(this._idTokenNonce);\n\t      this.registerCallback(expectedState, this.config.clientId, callback);\n\t      this.idTokenNonce = null;\n\t      this.verbose('Navigate to:' + urlNavigate);\n\t      this._saveItem(this.CONSTANTS.STORAGE.LOGIN_REQUEST, '');\n\t      frameHandle.src = 'about:blank';\n\t      this._loadFrameTimeout(urlNavigate, 'authIdTokenFrame', this.config.clientId);\n\t    }\n\t  }, {\n\t    key: '_urlContainsQueryStringParameter',\n\t    value: function _urlContainsQueryStringParameter(name, url) {\n\t      // regex to detect pattern of a ? or & followed by the name parameter and an equals character\n\t      var regex = new RegExp('[\\\\?&]' + name + '=');\n\t      return regex.test(url);\n\t    }\n\t\n\t    // Calling _loadFrame but with a timeout to signal failure in loadframeStatus. Callbacks are left\n\t    // registered when network errors occur and subsequent token requests for same resource are registered to the pending request\n\t\n\t  }, {\n\t    key: '_loadFrameTimeout',\n\t    value: function _loadFrameTimeout(urlNavigation, frameName, resource) {\n\t      var _this3 = this;\n\t\n\t      // set iframe session to pending\n\t      this.verbose('Set loading state to pending for: ' + resource);\n\t      this._saveItem(this.CONSTANTS.STORAGE.RENEW_STATUS + resource, this.CONSTANTS.TOKEN_RENEW_STATUS_IN_PROGRESS);\n\t      this._loadFrame(urlNavigation, frameName);\n\t      setTimeout(function () {\n\t        if (_this3._getItem(_this3.CONSTANTS.STORAGE.RENEW_STATUS + resource) === _this3.CONSTANTS.TOKEN_RENEW_STATUS_IN_PROGRESS) {\n\t          // fail the iframe session if it's in pending state\n\t          _this3.verbose('Loading frame has timed out after: ' + _this3.CONSTANTS.LOADFRAME_TIMEOUT / 1000 + ' seconds for resource ' + resource);\n\t          var expectedState = _this3._activeRenewals[resource];\n\t\n\t          _this3._saveItem(_this3.CONSTANTS.STORAGE.RENEW_STATUS + resource, _this3.CONSTANTS.TOKEN_RENEW_STATUS_CANCELED);\n\t\n\t          if (expectedState && _this3.callBackMappedToRenewStates[expectedState]) {\n\t            _this3.callBackMappedToRenewStates[expectedState]('Token renewal operation failed due to timeout', null);\n\t          }\n\t        }\n\t      }, this.CONSTANTS.LOADFRAME_TIMEOUT);\n\t    }\n\t  }, {\n\t    key: '_loadFrame',\n\t    value: function _loadFrame(urlNavigate, frameName) {\n\t      var _this4 = this;\n\t\n\t      // This trick overcomes iframe navigation in IE\n\t      // IE does not load the page consistently in iframe\n\t      this.info('LoadFrame: ' + frameName);\n\t      var frameCheck = frameName;\n\t      setTimeout(function () {\n\t        var frameHandle = _this4._addAuthFrame(frameCheck);\n\t        if (frameHandle.src === '' || frameHandle.src === 'about:blank') {\n\t          frameHandle.src = urlNavigate;\n\t          _this4._loadFrame(urlNavigate, frameCheck);\n\t        }\n\t      }, 500);\n\t    }\n\t\n\t    /**\n\t     * Acquire token from cache if not expired and available. Acquires token from iframe if expired.\n\t     * @param {string} resource  ResourceUri identifying the target resource\n\t     * @param {function} callback The callback function\n\t     */\n\t\n\t  }, {\n\t    key: 'acquireToken',\n\t    value: function acquireToken(resource, callback) {\n\t      if (this._isEmpty(resource)) {\n\t        this.warn('resource is required');\n\t        callback('resource is required', null);\n\t        return;\n\t      }\n\t\n\t      var token = this.getCachedToken(resource);\n\t      if (token) {\n\t        this.info('Token is already in cache for resource:' + resource);\n\t        callback(null, token);\n\t        return;\n\t      }\n\t\n\t      if (!this._user) {\n\t        this.warn('User login is required');\n\t        callback('User login is required', null);\n\t        return;\n\t      }\n\t\n\t      // refresh attept with iframe\n\t      // Already renewing for this resource, callback when we get the token.\n\t      if (this._activeRenewals[resource]) {\n\t        // Active renewals contains the state for each renewal.\n\t        this.registerCallback(this._activeRenewals[resource], resource, callback);\n\t      } else if (resource === this.config.clientId) {\n\t        // App uses idtoken to send to api endpoints\n\t        // Default resource is tracked as clientid to store this token\n\t        this.verbose('renewing idtoken');\n\t        this._renewIdToken(callback);\n\t      } else {\n\t        this._renewToken(resource, callback);\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Redirect the Browser to Azure AD Authorization endpoint\n\t     * @param {string} urlNavigate The authorization request url\n\t     */\n\t\n\t  }, {\n\t    key: 'promptUser',\n\t    value: function promptUser(urlNavigate) {\n\t      if (urlNavigate) {\n\t        this.info('Navigate to:' + urlNavigate);\n\t        this.navigate(urlNavigate);\n\t      } else {\n\t        this.info('Navigate url is empty');\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Clear cache items.\n\t     */\n\t\n\t  }, {\n\t    key: 'clearCache',\n\t    value: function clearCache() {\n\t      this._saveItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY, '');\n\t      this._saveItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY, 0);\n\t      this._saveItem(this.CONSTANTS.STORAGE.SESSION_STATE, '');\n\t      this._saveItem(this.CONSTANTS.STORAGE.STATE_LOGIN, '');\n\t      this._renewStates = [];\n\t      this._saveItem(this.CONSTANTS.STORAGE.USERNAME, '');\n\t      this._saveItem(this.CONSTANTS.STORAGE.IDTOKEN, '');\n\t      this._saveItem(this.CONSTANTS.STORAGE.ERROR, '');\n\t      this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, '');\n\t      var keys = this._getItem(this.CONSTANTS.STORAGE.TOKEN_KEYS);\n\t\n\t      if (!this._isEmpty(keys)) {\n\t        keys = keys.split(this.CONSTANTS.RESOURCE_DELIMETER);\n\t        for (var i = 0; i < keys.length; i++) {\n\t          this._saveItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY + keys[i], '');\n\t          this._saveItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY + keys[i], 0);\n\t        }\n\t      }\n\t      this._saveItem(this.CONSTANTS.STORAGE.TOKEN_KEYS, '');\n\t    }\n\t\n\t    /**\n\t     * Clear cache items for a resource.\n\t     * @param {string} resource The resource\n\t     */\n\t\n\t  }, {\n\t    key: 'clearCacheForResource',\n\t    value: function clearCacheForResource(resource) {\n\t      this._saveItem(this.CONSTANTS.STORAGE.STATE_RENEW, '');\n\t      this._saveItem(this.CONSTANTS.STORAGE.ERROR, '');\n\t      this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, '');\n\t      if (this._hasResource(resource)) {\n\t        this._saveItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY + resource, '');\n\t        this._saveItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY + resource, 0);\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Logout user will redirect page to logout endpoint.\n\t     * After logout, it will redirect to post_logout page if provided.\n\t     */\n\t\n\t  }, {\n\t    key: 'logOut',\n\t    value: function logOut() {\n\t      this.clearCache();\n\t      var logout = '';\n\t      this._user = null;\n\t\n\t      if (this.config.postLogoutRedirectUri) {\n\t        logout = 'post_logout_redirect_uri=' + encodeURIComponent(this.config.postLogoutRedirectUri);\n\t      }\n\t\n\t      var urlNavigate = this.config.instance + 'logout?' + logout;\n\t      this.info('Logout navigate to: ' + urlNavigate);\n\t      this.promptUser(urlNavigate);\n\t    }\n\t  }, {\n\t    key: '_isEmpty',\n\t    value: function _isEmpty(str) {\n\t      return typeof str === 'undefined' || !str || str.length === 0;\n\t    }\n\t\n\t    /**\n\t     * Gets a user profile\n\t     * @param {requestCallback} callback The callback that handles the response.\n\t     */\n\t\n\t  }, {\n\t    key: 'getUser',\n\t    value: function getUser(callback) {\n\t      // IDToken is first call\n\t      if (typeof callback !== 'function') {\n\t        throw new Error('callback is not a function');\n\t      }\n\t\n\t      // user in memory\n\t      if (this._user) {\n\t        callback(null, this._user);\n\t        return;\n\t      }\n\t\n\t      // frame is used to get idtoken\n\t      var idtoken = this._getItem(this.CONSTANTS.STORAGE.IDTOKEN);\n\t      if (this._isEmpty(idtoken)) {\n\t        this.warn('User information is not available');\n\t        callback('User information is not available');\n\t      } else {\n\t        this.info('User exists in cache: ');\n\t        this._user = this._createUser(idtoken);\n\t        callback(null, this._user);\n\t      }\n\t    }\n\t  }, {\n\t    key: '_addHintParameters',\n\t    value: function _addHintParameters(urlNavigate) {\n\t      // include hint params only if upn is present\n\t      if (this._user && this._user.profile && this._user.profile.hasOwnProperty('upn')) {\n\t        // add login_hint\n\t        urlNavigate += '&login_hint=' + encodeURIComponent(this._user.profile.upn);\n\t\n\t        // don't add domain_hint twice if user provided it in the extraQueryParameter value\n\t        if (!this._urlContainsQueryStringParameter('domain_hint', urlNavigate) && this._user.profile.upn.indexOf('@') > -1) {\n\t          var parts = this._user.profile.upn.split('@');\n\t          // local part can include @ in quotes. Sending last part handles that.\n\t          urlNavigate += '&domain_hint=' + encodeURIComponent(parts[parts.length - 1]);\n\t        }\n\t      }\n\t\n\t      return urlNavigate;\n\t    }\n\t  }, {\n\t    key: '_createUser',\n\t    value: function _createUser(idToken) {\n\t      var user = null;\n\t      var parsedJson = this._extractIdToken(idToken);\n\t      if (parsedJson && parsedJson.hasOwnProperty('aud')) {\n\t        var audienceMatch = false;\n\t\n\t        if (Array.isArray(parsedJson.aud)) {\n\t          // If the ID Token contains multiple audiences then an azp claim must be present and equal to the client id.\n\t          if (parsedJson.hasOwnProperty('azp') && parsedJson.azp.toLowerCase() === this.config.clientId.toLowerCase()) {\n\t            for (var i = 0; i < parsedJson.aud.length; i++) {\n\t              if (parsedJson.aud[i].toLowerCase() === this.config.clientId.toLowerCase()) {\n\t                audienceMatch = true;\n\t                break;\n\t              }\n\t            }\n\t          }\n\t        } else {\n\t          audienceMatch = parsedJson.aud.toLowerCase() === this.config.clientId.toLowerCase();\n\t        }\n\t\n\t        if (audienceMatch) {\n\t          user = {\n\t            userName: '',\n\t            profile: parsedJson\n\t          };\n\t\n\t          if (parsedJson.hasOwnProperty('upn')) {\n\t            user.userName = parsedJson.upn;\n\t          } else if (parsedJson.hasOwnProperty('email')) {\n\t            user.userName = parsedJson.email;\n\t          } else if (parsedJson.hasOwnProperty('sub')) {\n\t            user.userName = parsedJson.sub;\n\t          }\n\t        } else {\n\t          this.warn('IdToken has invalid aud/azp field');\n\t        }\n\t      }\n\t\n\t      return user;\n\t    }\n\t  }, {\n\t    key: '_getHash',\n\t    value: function _getHash(hash) {\n\t      if (hash.indexOf('#/') > -1) {\n\t        hash = hash.substring(hash.indexOf('#/') + 2);\n\t      } else if (hash.indexOf('#') > -1) {\n\t        hash = hash.substring(1);\n\t      }\n\t\n\t      return hash;\n\t    }\n\t  }, {\n\t    key: '_getSearch',\n\t    value: function _getSearch(search) {\n\t      if (search.indexOf('?') > -1) {\n\t        search = search.substring(1);\n\t      }\n\t\n\t      return search;\n\t    }\n\t  }, {\n\t    key: '_getParameters',\n\t    value: function _getParameters(hash, search) {\n\t      var parameters = {};\n\t\n\t      if (hash) {\n\t        hash = this._getHash(hash);\n\t        parameters = this._deserialize(hash);\n\t      }\n\t\n\t      if (search) {\n\t        search = this._getSearch(search);\n\t        var searchParameters = this._deserialize(search);\n\t        parameters = this._extend(parameters, searchParameters);\n\t      }\n\t\n\t      return parameters;\n\t    }\n\t  }, {\n\t    key: '_extend',\n\t    value: function _extend(obj, src) {\n\t      for (var key in src) {\n\t        if (src.hasOwnProperty(key)) {\n\t          obj[key] = src[key];\n\t        }\n\t      }\n\t      return obj;\n\t    }\n\t\n\t    /**\n\t     * Checks if hash contains access token or id token or error_description\n\t     * @param {string} hash  -  Hash passed from redirect page\n\t     * @param {string} search  -  Search passed from redirect page\n\t     * @return {boolean} exists if all the parameters exist\n\t     */\n\t\n\t  }, {\n\t    key: 'isCallback',\n\t    value: function isCallback(hash, search) {\n\t      var parameters = this._getParameters(hash, search);\n\t\n\t      return parameters.hasOwnProperty(this.CONSTANTS.ERROR_DESCRIPTION) || parameters.hasOwnProperty(this.CONSTANTS.ACCESS_TOKEN) || parameters.hasOwnProperty(this.CONSTANTS.ID_TOKEN);\n\t    }\n\t\n\t    /**\n\t     * Gets login error\n\t     * @return {string} error message related to login\n\t     */\n\t\n\t  }, {\n\t    key: 'getLoginError',\n\t    value: function getLoginError() {\n\t      return this._getItem(this.CONSTANTS.STORAGE.LOGIN_ERROR);\n\t    }\n\t\n\t    /**\n\t     * Gets requestInfo from given hash.\n\t     * @param {string} hash  -  Hash passed from redirect page\n\t     * @param {string} search  -  Search passed from redirect page\n\t     * @return {string} error message related to login\n\t     */\n\t\n\t  }, {\n\t    key: 'getRequestInfo',\n\t    value: function getRequestInfo(hash, search) {\n\t      var parameters = this._getParameters(hash, search);\n\t      var requestInfo = {\n\t        valid: false,\n\t        parameters: {},\n\t        stateMatch: false,\n\t        stateResponse: '',\n\t        requestType: this.REQUEST_TYPE.UNKNOWN\n\t      };\n\t\n\t      if (parameters) {\n\t        requestInfo.parameters = parameters;\n\t        if (parameters.hasOwnProperty(this.CONSTANTS.ERROR_DESCRIPTION) || parameters.hasOwnProperty(this.CONSTANTS.ACCESS_TOKEN) || parameters.hasOwnProperty(this.CONSTANTS.ID_TOKEN)) {\n\t          requestInfo.valid = true;\n\t\n\t          // which call\n\t          var stateResponse = '';\n\t          if (parameters.hasOwnProperty('state')) {\n\t            this.verbose('State: ' + parameters.state);\n\t            stateResponse = parameters.state;\n\t          } else {\n\t            this.warn('No state returned');\n\t            return requestInfo;\n\t          }\n\t\n\t          requestInfo.stateResponse = stateResponse;\n\t\n\t          // async calls can fire iframe and login request at the same time if developer does not use the API as expected\n\t          // incoming callback needs to be looked up to find the request type\n\t          if (stateResponse === this._getItem(this.CONSTANTS.STORAGE.STATE_LOGIN)) {\n\t            requestInfo.requestType = this.REQUEST_TYPE.LOGIN;\n\t            requestInfo.stateMatch = true;\n\t            return requestInfo;\n\t          }\n\t\n\t          // external api requests may have many renewtoken requests for different resource\n\t          if (!requestInfo.stateMatch && window.parent && window.parent.AuthenticationContext) {\n\t            var statesInParentContext = window.parent.AuthenticationContext._renewStates;\n\t            for (var i = 0; i < statesInParentContext.length; i++) {\n\t              if (statesInParentContext[i] === requestInfo.stateResponse) {\n\t                requestInfo.requestType = this.REQUEST_TYPE.RENEW_TOKEN;\n\t                requestInfo.stateMatch = true;\n\t                break;\n\t              }\n\t            }\n\t          }\n\t        }\n\t      }\n\t\n\t      return requestInfo;\n\t    }\n\t  }, {\n\t    key: '_getResourceFromState',\n\t    value: function _getResourceFromState(state) {\n\t      if (state) {\n\t        var splitIndex = state.indexOf('|');\n\t        if (splitIndex > -1 && splitIndex + 1 < state.length) {\n\t          return state.substring(splitIndex + 1);\n\t        }\n\t      }\n\t\n\t      return '';\n\t    }\n\t\n\t    /**\n\t     * Saves token from hash that is received from redirect.\n\t     * @param {string} requestInfo Hash passed from redirect page\n\t     */\n\t\n\t  }, {\n\t    key: 'saveTokenFromHash',\n\t    value: function saveTokenFromHash(requestInfo) {\n\t      this.info('State status:' + requestInfo.stateMatch + '; Request type:' + requestInfo.requestType);\n\t      this._saveItem(this.CONSTANTS.STORAGE.ERROR, '');\n\t      this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, '');\n\t\n\t      var resource = this._getResourceFromState(requestInfo.stateResponse);\n\t\n\t      // Record error\n\t      if (requestInfo.parameters.hasOwnProperty(this.CONSTANTS.ERROR_DESCRIPTION)) {\n\t        this.info('Error :' + requestInfo.parameters.error + '; Error description:' + requestInfo.parameters[this.CONSTANTS.ERROR_DESCRIPTION]);\n\t        this._saveItem(this.CONSTANTS.STORAGE.ERROR, requestInfo.parameters.error);\n\t        this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, requestInfo.parameters[this.CONSTANTS.ERROR_DESCRIPTION]);\n\t\n\t        if (requestInfo.requestType === this.REQUEST_TYPE.LOGIN) {\n\t          this._loginInProgress = false;\n\t          this._saveItem(this.CONSTANTS.STORAGE.LOGIN_ERROR, requestInfo.parameters.error_description);\n\t        }\n\t      } else if (requestInfo.stateMatch) {\n\t        // record tokens to storage if exists\n\t        this.info('State is right');\n\t        if (requestInfo.parameters.hasOwnProperty(this.CONSTANTS.SESSION_STATE)) {\n\t          this._saveItem(this.CONSTANTS.STORAGE.SESSION_STATE, requestInfo.parameters[this.CONSTANTS.SESSION_STATE]);\n\t        }\n\t\n\t        var keys = void 0;\n\t\n\t        if (requestInfo.parameters.hasOwnProperty(this.CONSTANTS.ACCESS_TOKEN)) {\n\t          this.info('Fragment has access token');\n\t\n\t          if (!this._hasResource(resource)) {\n\t            keys = this._getItem(this.CONSTANTS.STORAGE.TOKEN_KEYS) || '';\n\t            this._saveItem(this.CONSTANTS.STORAGE.TOKEN_KEYS, keys + resource + this.CONSTANTS.RESOURCE_DELIMETER);\n\t          }\n\t          // save token with related resource\n\t          this._saveItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY + resource, requestInfo.parameters[this.CONSTANTS.ACCESS_TOKEN]);\n\t          this._saveItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY + resource, this._expiresIn(requestInfo.parameters[this.CONSTANTS.EXPIRES_IN]));\n\t        }\n\t\n\t        if (requestInfo.parameters.hasOwnProperty(this.CONSTANTS.ID_TOKEN)) {\n\t          this.info('Fragment has id token');\n\t          this._loginInProgress = false;\n\t\n\t          this._user = this._createUser(requestInfo.parameters[this.CONSTANTS.ID_TOKEN]);\n\t\n\t          if (this._user && this._user.profile) {\n\t            if (this._user.profile.nonce === this._getItem(this.CONSTANTS.STORAGE.NONCE_IDTOKEN)) {\n\t              this._saveItem(this.CONSTANTS.STORAGE.IDTOKEN, requestInfo.parameters[this.CONSTANTS.ID_TOKEN]);\n\t\n\t              // Save idtoken as access token for app itself\n\t              resource = this.config.loginResource ? this.config.loginResource : this.config.clientId;\n\t\n\t              if (!this._hasResource(resource)) {\n\t                keys = this._getItem(this.CONSTANTS.STORAGE.TOKEN_KEYS) || '';\n\t                this._saveItem(this.CONSTANTS.STORAGE.TOKEN_KEYS, keys + resource + this.CONSTANTS.RESOURCE_DELIMETER);\n\t              }\n\t              this._saveItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY + resource, requestInfo.parameters[this.CONSTANTS.ID_TOKEN]);\n\t              this._saveItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY + resource, this._user.profile.exp);\n\t            } else {\n\t              this._user = null;\n\t              this._saveItem(this.CONSTANTS.STORAGE.LOGIN_ERROR, 'Nonce is not same as ' + this._idTokenNonce);\n\t            }\n\t          } else {\n\t            this._saveItem(this.CONSTANTS.STORAGE.ERROR, 'invalid id_token');\n\t            this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, 'Invalid id_token. id_token: ' + requestInfo.parameters[this.CONSTANTS.ID_TOKEN]);\n\t          }\n\t        }\n\t      } else {\n\t        this._saveItem(this.CONSTANTS.STORAGE.ERROR, 'Invalid_state');\n\t        this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, 'Invalid_state. state: ' + requestInfo.stateResponse);\n\t      }\n\t      this._saveItem(this.CONSTANTS.STORAGE.RENEW_STATUS + resource, this.CONSTANTS.TOKEN_RENEW_STATUS_COMPLETED);\n\t    }\n\t\n\t    /**\n\t     * Gets resource for given endpoint if mapping is provided with config.\n\t     * @param {string} endpoint API endpoint\n\t     * @return {string} resource for this API endpoint\n\t     */\n\t\n\t  }, {\n\t    key: 'getResourceForEndpoint',\n\t    value: function getResourceForEndpoint(endpoint) {\n\t      if (this.config && this.config.endpoints) {\n\t        for (var configEndpoint in this.config.endpoints) {\n\t          // configEndpoint is like /api/Todo requested endpoint can be /api/Todo/1\n\t          if (endpoint.indexOf(configEndpoint) > -1) {\n\t            return this.config.endpoints[configEndpoint];\n\t          }\n\t        }\n\t      }\n\t\n\t      // default resource will be clientid if nothing specified\n\t      // App will use idtoken for calls to itself\n\t      // check if it's staring from http or https, needs to match with app host\n\t      if (endpoint.indexOf('http://') > -1 || endpoint.indexOf('https://') > -1) {\n\t        if (this._getHostFromUri(endpoint) === this._getHostFromUri(this.config.redirectUri)) {\n\t          return this.config.loginResource;\n\t        }\n\t      } else {\n\t        // in angular level, the url for $http interceptor call could be relative url,\n\t        // if it's relative call, we'll treat it as app backend call.\n\t        // if user specified list of anonymous endpoints, no need to send token to these endpoints, return null.\n\t        if (this.config && this.config.anonymousEndpoints) {\n\t          for (var i = 0; i < this.config.anonymousEndpoints.length; i++) {\n\t            if (endpoint.indexOf(this.config.anonymousEndpoints[i]) > -1) {\n\t              return null;\n\t            }\n\t          }\n\t        }\n\t        // all other app's backend calls are secured.\n\t        return this.config.loginResource;\n\t      }\n\t\n\t      // if not the app's own backend or not a domain listed in the endpoints structure\n\t      return null;\n\t    }\n\t  }, {\n\t    key: '_getHostFromUri',\n\t    value: function _getHostFromUri(uri) {\n\t      // remove http:// or https:// from uri\n\t      var extractedUri = String(uri).replace(/^(https?:)\\/\\//, '');\n\t\n\t      extractedUri = extractedUri.split('/')[0];\n\t      return extractedUri;\n\t    }\n\t\n\t    /* exported  oauth2Callback */\n\t\n\t  }, {\n\t    key: 'handleWindowCallback',\n\t    value: function handleWindowCallback(hash, search) {\n\t      // This is for regular javascript usage for redirect handling\n\t      // need to make sure this is for callback\n\t      if (!hash) {\n\t        hash = window.location.hash;\n\t      }\n\t\n\t      if (!search) {\n\t        search = window.location.search;\n\t      }\n\t\n\t      if (this.isCallback(hash, search)) {\n\t        var requestInfo = this.getRequestInfo(hash, search);\n\t        this.info('Returned from redirect url');\n\t        this.saveTokenFromHash(requestInfo);\n\t        var callback = null;\n\t        if (requestInfo.requestType === this.REQUEST_TYPE.RENEW_TOKEN && this.isIframe()) {\n\t          // iframe call but same single page\n\t          this.verbose('Window is in iframe');\n\t          callback = window.parent.AuthenticationContext.callBackMappedToRenewStates[requestInfo.stateResponse];\n\t          if (callback) {\n\t            callback(this._getItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION), requestInfo.parameters[this.CONSTANTS.ACCESS_TOKEN] || requestInfo.parameters[this.CONSTANTS.ID_TOKEN]);\n\t          }\n\t          return;\n\t        } else if (requestInfo.requestType === this.REQUEST_TYPE.LOGIN) {\n\t          callback = this.callback;\n\t          if (callback) {\n\t            callback(this._getItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION), requestInfo.parameters[this.CONSTANTS.ID_TOKEN]);\n\t          }\n\t        }\n\t        // No need to redirect user in case of popup\n\t        if (!this.popUp) {\n\t          this.navigate(this._getItem(this.CONSTANTS.STORAGE.LOGIN_REQUEST));\n\t        }\n\t      }\n\t    }\n\t  }, {\n\t    key: '_getNavigateUrl',\n\t    value: function _getNavigateUrl(responseType, resource) {\n\t      var urlNavigate = this.config.instance + 'authorize' + this._serialize(responseType, this.config, resource) + this._addLibMetadata();\n\t      if (this.config.scope) {\n\t        urlNavigate += '&scope=' + encodeURIComponent(this.config.scope);\n\t      }\n\t      this.info('Navigate url:' + urlNavigate);\n\t      return urlNavigate;\n\t    }\n\t  }, {\n\t    key: '_extractIdToken',\n\t    value: function _extractIdToken(encodedIdToken) {\n\t      // id token will be decoded to get the username\n\t      var decodedToken = this._decodeJwt(encodedIdToken);\n\t      if (!decodedToken) {\n\t        return null;\n\t      }\n\t\n\t      try {\n\t        var base64IdToken = decodedToken.JWSPayload;\n\t        var base64Decoded = this._base64DecodeStringUrlSafe(base64IdToken);\n\t        if (!base64Decoded) {\n\t          this.info('The returned id_token could not be base64 url safe decoded.');\n\t          return null;\n\t        }\n\t\n\t        return JSON.parse(base64Decoded);\n\t      } catch (err) {\n\t        this.error('The returned id_token could not be decoded', err);\n\t      }\n\t\n\t      return null;\n\t    }\n\t  }, {\n\t    key: '_base64DecodeStringUrlSafe',\n\t    value: function _base64DecodeStringUrlSafe(base64IdToken) {\n\t      base64IdToken = base64IdToken.replace(/-/g, '+').replace(/_/g, '/');\n\t      return decodeURIComponent(escape(window.atob(base64IdToken)));\n\t    }\n\t\n\t    // Auth.node js crack function\n\t\n\t  }, {\n\t    key: '_decodeJwt',\n\t    value: function _decodeJwt(jwtToken) {\n\t      if (this._isEmpty(jwtToken)) {\n\t        return null;\n\t      }\n\t\n\t      var idTokenPartsRegex = /^([^\\.\\s]*)\\.([^\\.\\s]+)\\.([^\\.\\s]*)$/;\n\t\n\t      var matches = idTokenPartsRegex.exec(jwtToken);\n\t      if (!matches || matches.length < 4) {\n\t        this.warn('The returned id_token is not parseable.');\n\t        return null;\n\t      }\n\t\n\t      var crackedToken = {\n\t        header: matches[1],\n\t        JWSPayload: matches[2],\n\t        JWSSig: matches[3]\n\t      };\n\t\n\t      return crackedToken;\n\t    }\n\t  }, {\n\t    key: '_convertUrlSafeToRegularBase64EncodedString',\n\t    value: function _convertUrlSafeToRegularBase64EncodedString(str) {\n\t      return str.replace('-', '+').replace('_', '/');\n\t    }\n\t  }, {\n\t    key: '_serialize',\n\t    value: function _serialize(responseType, obj, resource) {\n\t      var str = [];\n\t      if (obj !== null) {\n\t        str.push('?response_type=' + encodeURIComponent(responseType));\n\t        str.push('client_id=' + encodeURIComponent(obj.clientId));\n\t        if (resource) {\n\t          str.push('resource=' + encodeURIComponent(resource));\n\t        }\n\t\n\t        str.push('redirect_uri=' + encodeURIComponent(obj.redirectUri));\n\t        str.push('state=' + encodeURIComponent(obj.state));\n\t\n\t        if (obj.hasOwnProperty('slice')) {\n\t          str.push('slice=' + encodeURIComponent(obj.slice));\n\t        }\n\t\n\t        if (obj.hasOwnProperty('extraQueryParameter')) {\n\t          str.push(obj.extraQueryParameter);\n\t        }\n\t\n\t        var correlationId = obj.correlationId ? obj.correlationId : this._guid();\n\t        str.push('client-request-id=' + encodeURIComponent(correlationId));\n\t      }\n\t\n\t      return str.join('&');\n\t    }\n\t  }, {\n\t    key: '_deserialize',\n\t    value: function _deserialize(query) {\n\t      var pl = /\\+/g; // Regex for replacing addition symbol with a space\n\t      var search = /([^&=]+)=([^&]*)/g;\n\t      var decode = function decode(s) {\n\t        return decodeURIComponent(s.replace(pl, ' '));\n\t      };\n\t      var obj = {};\n\t      var match = search.exec(query);\n\t      while (match) {\n\t        obj[decode(match[1])] = decode(match[2]);\n\t        match = search.exec(query);\n\t      }\n\t\n\t      return obj;\n\t    }\n\t  }, {\n\t    key: '_decimalToHex',\n\t    value: function _decimalToHex(number) {\n\t      var hex = number.toString(16);\n\t      while (hex.length < 2) {\n\t        hex = '0' + hex;\n\t      }\n\t      return hex;\n\t    }\n\t  }, {\n\t    key: '_guid',\n\t    value: function _guid() {\n\t      // RFC4122: The version 4 UUID is meant for generating UUIDs from truly-random or\n\t      // pseudo-random numbers.\n\t      // The algorithm is as follows:\n\t      //     Set the two most significant bits (bits 6 and 7) of the\n\t      //        clock_seq_hi_and_reserved to zero and one, respectively.\n\t      //     Set the four most significant bits (bits 12 through 15) of the\n\t      //        time_hi_and_version field to the 4-bit version number from\n\t      //        Section 4.1.3. Version4\n\t      //     Set all the other bits to randomly (or pseudo-randomly) chosen\n\t      //     values.\n\t      // UUID                   = time-low \"-\" time-mid \"-\"time-high-and-version \"-\"clock-seq-reserved and low(2hexOctet)\"-\" node\n\t      // time-low               = 4hexOctet\n\t      // time-mid               = 2hexOctet\n\t      // time-high-and-version  = 2hexOctet\n\t      // clock-seq-and-reserved = hexOctet:\n\t      // clock-seq-low          = hexOctet\n\t      // node                   = 6hexOctet\n\t      // Format: xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\n\t      // y could be 1000, 1001, 1010, 1011 since most significant two bits needs to be 10\n\t      // y values are 8, 9, A, B\n\t      if (this.crypto && this.crypto.getRandomValues) {\n\t        var buffer = new Uint8Array(16);\n\t        this.crypto.getRandomValues(buffer);\n\t        // buffer[6] and buffer[7] represents the time_hi_and_version field. We will set the four most significant bits (4 through 7) of buffer[6] to represent decimal number 4 (UUID version number).\n\t        buffer[6] |= 0x40; // buffer[6] | 01000000 will set the 6 bit to 1.\n\t        buffer[6] &= 0x4f; // buffer[6] & 01001111 will set the 4, 5, and 7 bit to 0 such that bits 4-7 == 0100 = \"4\".\n\t        // buffer[8] represents the clock_seq_hi_and_reserved field. We will set the two most significant bits (6 and 7) of the clock_seq_hi_and_reserved to zero and one, respectively.\n\t        buffer[8] |= 0x80; // buffer[8] | 10000000 will set the 7 bit to 1.\n\t        buffer[8] &= 0xbf; // buffer[8] & 10111111 will set the 6 bit to 0.\n\t        return this._decimalToHex(buffer[0]) + this._decimalToHex(buffer[1]) + this._decimalToHex(buffer[2]) + this._decimalToHex(buffer[3]) + '-' + this._decimalToHex(buffer[4]) + this._decimalToHex(buffer[5]) + '-' + this._decimalToHex(buffer[6]) + this._decimalToHex(buffer[7]) + '-' + this._decimalToHex(buffer[8]) + this._decimalToHex(buffer[9]) + '-' + this._decimalToHex(buffer[10]) + this._decimalToHex(buffer[11]) + this._decimalToHex(buffer[12]) + this._decimalToHex(buffer[13]) + this._decimalToHex(buffer[14]) + this._decimalToHex(buffer[15]);\n\t      }\n\t      var guidHolder = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx';\n\t      var hex = '0123456789abcdef';\n\t      var r = 0;\n\t      var guidResponse = '';\n\t      for (var i = 0; i < 36; i++) {\n\t        if (guidHolder[i] !== '-' && guidHolder[i] !== '4') {\n\t          // each x and y needs to be random\n\t          r = Math.random() * 16 | 0;\n\t        }\n\t        if (guidHolder[i] === 'x') {\n\t          guidResponse += hex[r];\n\t        } else if (guidHolder[i] === 'y') {\n\t          // clock-seq-and-reserved first hex is filtered and remaining hex values are random\n\t          r &= 0x3; // bit and with 0011 to set pos 2 to zero ?0??\n\t          r |= 0x8; // set pos 3 to 1 as 1???\n\t          guidResponse += hex[r];\n\t        } else {\n\t          guidResponse += guidHolder[i];\n\t        }\n\t      }\n\t      return guidResponse;\n\t    }\n\t  }, {\n\t    key: '_expiresIn',\n\t    value: function _expiresIn(expires) {\n\t      return this._now() + parseInt(expires, 10);\n\t    }\n\t  }, {\n\t    key: '_now',\n\t    value: function _now() {\n\t      return Math.round(new Date().getTime() / 1000.0);\n\t    }\n\t  }, {\n\t    key: '_addAuthFrame',\n\t    value: function _addAuthFrame(iframeId) {\n\t      if (typeof iframeId === 'undefined') {\n\t        return;\n\t      }\n\t\n\t      this.info('Add auth frame to document:' + iframeId);\n\t      var authFrame = document.getElementById(iframeId);\n\t\n\t      if (!authFrame) {\n\t        if (document.createElement && document.documentElement && (window.opera || window.navigator.userAgent.indexOf('MSIE 5.0') === -1)) {\n\t          var ifr = document.createElement('iframe');\n\t          ifr.setAttribute('id', iframeId);\n\t          ifr.style.visibility = 'hidden';\n\t          ifr.style.position = 'absolute';\n\t          ifr.style.width = ifr.style.height = ifr.borderWidth = '0px';\n\t\n\t          authFrame = document.getElementsByTagName('body')[0].appendChild(ifr);\n\t        } else if (document.body && document.body.insertAdjacentHTML) {\n\t          document.body.insertAdjacentHTML('beforeEnd', '<iframe name=\"' + iframeId + '\" id=\"' + iframeId + '\" style=\"display:none\"></iframe>');\n\t        }\n\t        if (window.frames && window.frames[iframeId]) {\n\t          authFrame = window.frames[iframeId];\n\t        }\n\t      }\n\t\n\t      return authFrame;\n\t    }\n\t  }, {\n\t    key: '_saveItem',\n\t    value: function _saveItem(key, obj) {\n\t      if (this.config && this.config.cacheLocation && this.config.cacheLocation === 'localStorage') {\n\t        if (!this._supportsLocalStorage()) {\n\t          this.info('Local storage is not supported');\n\t          return false;\n\t        }\n\t\n\t        localStorage.setItem(key, obj);\n\t\n\t        return true;\n\t      }\n\t\n\t      // Default as session storage\n\t      if (!this._supportsSessionStorage()) {\n\t        this.info('Session storage is not supported');\n\t        return false;\n\t      }\n\t\n\t      sessionStorage.setItem(key, obj);\n\t      return true;\n\t    }\n\t  }, {\n\t    key: '_getItem',\n\t    value: function _getItem(key) {\n\t      if (this.config && this.config.cacheLocation && this.config.cacheLocation === 'localStorage') {\n\t        if (!this._supportsLocalStorage()) {\n\t          this.info('Local storage is not supported');\n\t          return null;\n\t        }\n\t\n\t        return localStorage.getItem(key);\n\t      }\n\t\n\t      // Default as session storage\n\t      if (!this._supportsSessionStorage()) {\n\t        this.info('Session storage is not supported');\n\t        return null;\n\t      }\n\t\n\t      return sessionStorage.getItem(key);\n\t    }\n\t  }, {\n\t    key: '_supportsLocalStorage',\n\t    value: function _supportsLocalStorage() {\n\t      try {\n\t        return 'localStorage' in window && window.localStorage;\n\t      } catch (e) {\n\t        return false;\n\t      }\n\t    }\n\t  }, {\n\t    key: '_supportsSessionStorage',\n\t    value: function _supportsSessionStorage() {\n\t      try {\n\t        return 'sessionStorage' in window && window.sessionStorage;\n\t      } catch (e) {\n\t        return false;\n\t      }\n\t    }\n\t  }, {\n\t    key: '_cloneConfig',\n\t    value: function _cloneConfig(obj) {\n\t      if (obj === null || (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object') {\n\t        return obj;\n\t      }\n\t\n\t      var copy = {};\n\t      for (var attr in obj) {\n\t        if (obj.hasOwnProperty(attr)) {\n\t          copy[attr] = obj[attr];\n\t        }\n\t      }\n\t      return copy;\n\t    }\n\t  }, {\n\t    key: '_addLibMetadata',\n\t    value: function _addLibMetadata() {\n\t      // x-client-SKU\n\t      // x-client-Ver\n\t      return '&x-client-SKU=Js&x-client-Ver=' + this._libVersion();\n\t    }\n\t  }, {\n\t    key: 'log',\n\t    value: function log(level, message, error) {\n\t      if (level <= Logging.level) {\n\t        var timestamp = new Date().toUTCString();\n\t        var formattedMessage = '';\n\t\n\t        if (this.config.correlationId) {\n\t          formattedMessage = timestamp + ':' + this.config.correlationId + '-' + this._libVersion() + '-' + this.CONSTANTS.LEVEL_STRING_MAP[level] + ' ' + message;\n\t        } else {\n\t          formattedMessage = timestamp + ':' + this._libVersion() + '-' + this.CONSTANTS.LEVEL_STRING_MAP[level] + ' ' + message;\n\t        }\n\t\n\t        if (error) {\n\t          formattedMessage += '\\nstack:\\n' + error.stack;\n\t        }\n\t\n\t        Logging.log(formattedMessage);\n\t      }\n\t    }\n\t  }, {\n\t    key: 'error',\n\t    value: function error(message, _error) {\n\t      this.log(this.CONSTANTS.LOGGING_LEVEL.ERROR, message, _error);\n\t    }\n\t  }, {\n\t    key: 'warn',\n\t    value: function warn(message) {\n\t      this.log(this.CONSTANTS.LOGGING_LEVEL.WARN, message, null);\n\t    }\n\t  }, {\n\t    key: 'info',\n\t    value: function info(message) {\n\t      this.log(this.CONSTANTS.LOGGING_LEVEL.INFO, message, null);\n\t    }\n\t  }, {\n\t    key: 'verbose',\n\t    value: function verbose(message) {\n\t      this.log(this.CONSTANTS.LOGGING_LEVEL.VERBOSE, message, null);\n\t    }\n\t  }, {\n\t    key: 'navigate',\n\t    value: function navigate(url) {\n\t      window.location.replace(url);\n\t    }\n\t  }, {\n\t    key: 'isIframe',\n\t    value: function isIframe() {\n\t      return window.parent && window.parent !== window;\n\t    }\n\t  }, {\n\t    key: 'open',\n\t    value: function open(url, name, features) {\n\t      return window.open(url, name, features);\n\t    }\n\t  }, {\n\t    key: '_libVersion',\n\t    value: function _libVersion() {\n\t      return '1.0.12';\n\t    }\n\t  }]);\n\t\n\t  return AuthenticationContext;\n\t}();\n\t\n\texports.default = AuthenticationContext;\n\t\n\t\n\tglobal.Logging = {\n\t  level: 0,\n\t  log: function log(message) {}\n\t};\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** salte-auth.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap d5ca05275691deb67c2c\n **/","/**\n * @public\n * @class Config\n * @property {clientId}        Identifier assigned to your app by Azure Active Directory\n * @property {redirectUri}     Endpoint at which you expect to receive tokens\n * @property {instance}        This is the URL path to the identity provider that authorize and logout will be called against.\n * @property {endpoints}       Collection of {Endpoint-ResourceId} used for autmatically attaching tokens in webApi calls\n * @property {scope}           This may be used to define the specific authorization(s) being requested from the resource owner.\n */\n\n/**\n * User information from idtoken.\n *  @class User\n *  @property {string} userName - username assigned from upn, email, or sub (i.e. subject).\n *  @property {object} profile - properties parsed from idtoken.\n */\n\n/**\n * Creates a new AuthenticationContext object.\n * @constructor\n * @param {object}  config               Configuration options for AuthenticationContext\n */\nexport default class AuthenticationContext {\n  constructor(config) {\n    /**\n    * Enum for request type\n    * @enum {string}\n    */\n    this.REQUEST_TYPE = {\n      LOGIN: 'LOGIN',\n      RENEW_TOKEN: 'RENEW_TOKEN',\n      UNKNOWN: 'UNKNOWN'\n    };\n\n    /**\n    * Enum for storage constants\n    * @enum {string}\n    */\n    this.CONSTANTS = {\n      ACCESS_TOKEN: 'access_token',\n      EXPIRES_IN: 'expires_in',\n      ID_TOKEN: 'id_token',\n      ERROR_DESCRIPTION: 'error_description',\n      SESSION_STATE: 'session_state',\n      STORAGE: {\n        TOKEN_KEYS: 'auth.token.keys',\n        ACCESS_TOKEN_KEY: 'auth.access.token.key',\n        EXPIRATION_KEY: 'auth.expiration.key',\n        STATE_LOGIN: 'auth.state.login',\n        STATE_RENEW: 'auth.state.renew',\n        NONCE_IDTOKEN: 'auth.nonce.idtoken',\n        SESSION_STATE: 'auth.session.state',\n        USERNAME: 'auth.username',\n        IDTOKEN: 'auth.idtoken',\n        ERROR: 'auth.error',\n        ERROR_DESCRIPTION: 'auth.error.description',\n        LOGIN_REQUEST: 'auth.login.request',\n        LOGIN_ERROR: 'auth.login.error',\n        RENEW_STATUS: 'auth.token.renew.status'\n      },\n      RESOURCE_DELIMETER: '|',\n      LOADFRAME_TIMEOUT: '6000',\n      TOKEN_RENEW_STATUS_CANCELED: 'Canceled',\n      TOKEN_RENEW_STATUS_COMPLETED: 'Completed',\n      TOKEN_RENEW_STATUS_IN_PROGRESS: 'In Progress',\n      LOGGING_LEVEL: {\n        ERROR: 0,\n        WARN: 1,\n        INFO: 2,\n        VERBOSE: 3\n      },\n      LEVEL_STRING_MAP: {\n        0: 'ERROR:',\n        1: 'WARNING:',\n        2: 'INFO:',\n        3: 'VERBOSE:'\n      },\n      POPUP_WIDTH: 483,\n      POPUP_HEIGHT: 600\n    };\n\n    if (window.AuthenticationContext) {\n      return window.AuthenticationContext;\n    }\n    window.AuthenticationContext = this;\n\n    // public\n    this.config = {};\n    this.callback = null;\n    this.popUp = false;\n    this.isAngular = false;\n    this.crypto = window.crypto || window.msCrypto;\n\n    // private\n    this._user = null;\n    this._activeRenewals = {};\n    this._loginInProgress = false;\n    this._renewStates = [];\n\n    this.callBackMappedToRenewStates = {};\n    this.callBacksMappedToRenewStates = {};\n\n    // validate before constructor assignments\n    if (config.displayCall && typeof config.displayCall !== 'function') {\n      throw new Error('displayCall is not a function');\n    }\n\n    if (!config.clientId) {\n      throw new Error('clientId is required');\n    }\n\n    this.config = this._cloneConfig(config);\n\n    if (this.config.popUp) {\n      this.popUp = true;\n    }\n\n    if (this.config.callback && typeof this.config.callback === 'function') {\n      this.callback = this.config.callback;\n    }\n\n    if (!this.config.instance || !this.config.instance.match(/^https:\\/\\/.*\\/$/)) {\n      throw new Error('instance must be a valid https endpoint that ends in a forward slash.');\n    }\n\n    // App can request idtoken for itself using clientid as resource\n    if (!this.config.loginResource) {\n      this.config.loginResource = this.config.clientId;\n    }\n\n    if (!this.config.redirectUri) {\n      this.config.redirectUri = window.location.href;\n    }\n\n    if (!this.config.anonymousEndpoints) {\n      this.config.anonymousEndpoints = [];\n    }\n\n    if (this.config.isAngular) {\n      this.isAngular = this.config.isAngular;\n    }\n\n    this.setResponseType(this.config.responseType);\n  }\n\n  setResponseType(responseType) {\n    this.config.responseType = responseType || this.CONSTANTS.ID_TOKEN;\n  }\n\n  /**\n   * Gets initial Idtoken for the app backend\n   * Saves the resulting Idtoken in localStorage.\n   * @param {string} startPage the start page\n   */\n  login(startPage) {\n    // Token is not present and user needs to login\n    if (this._loginInProgress) {\n      this.info('Login in progress');\n      return;\n    }\n    const expectedState = this._guid();\n    this.config.state = expectedState;\n    this._idTokenNonce = this._guid();\n    if (!startPage) {\n      startPage = window.location;\n    }\n    this.verbose('Expected state: ' + expectedState + ' startPage:' + startPage);\n    this._saveItem(this.CONSTANTS.STORAGE.LOGIN_REQUEST, startPage);\n    this._saveItem(this.CONSTANTS.STORAGE.LOGIN_ERROR, '');\n    this._saveItem(this.CONSTANTS.STORAGE.STATE_LOGIN, expectedState);\n    this._saveItem(this.CONSTANTS.STORAGE.NONCE_IDTOKEN, this._idTokenNonce);\n    this._saveItem(this.CONSTANTS.STORAGE.ERROR, '');\n    this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, '');\n    const urlNavigate = this._getNavigateUrl(this.config.responseType, null) + '&nonce=' + encodeURIComponent(this._idTokenNonce);\n    this._loginInProgress = true;\n    if (this.popUp) {\n      this._loginPopup(urlNavigate);\n      return;\n    }\n    if (this.config.displayCall) {\n      // User defined way of handling the navigation\n      this.config.displayCall(urlNavigate);\n    } else {\n      this.promptUser(urlNavigate);\n    }\n  }\n\n  _openPopup(urlNavigate, title, popUpWidth, popUpHeight) {\n    try {\n      /**\n      * adding winLeft and winTop to account for dual monitor\n      * using screenLeft and screenTop for IE8 and earlier\n      */\n      const winLeft = window.screenLeft ? window.screenLeft : window.screenX;\n      const winTop = window.screenTop ? window.screenTop : window.screenY;\n      /**\n      * window.innerWidth displays browser window's height and width excluding toolbars\n      * using document.documentElement.clientWidth for IE8 and earlier\n      */\n      const width = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;\n      const height = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;\n      const left = ((width / 2) - (popUpWidth / 2)) + winLeft;\n      const top = ((height / 2) - (popUpHeight / 2)) + winTop;\n\n      const popupWindow = this.open(urlNavigate, title, 'width=' + popUpWidth + ', height=' + popUpHeight + ', top=' + top + ', left=' + left);\n      if (popupWindow.focus) {\n        popupWindow.focus();\n      }\n      return popupWindow;\n    } catch (e) {\n      this.warn('Error opening popup, ' + e.message);\n      this._loginInProgress = false;\n      return null;\n    }\n  }\n\n  _loginPopup(urlNavigate) {\n    const popupWindow = this._openPopup(urlNavigate, 'login', this.CONSTANTS.POPUP_WIDTH, this.CONSTANTS.POPUP_HEIGHT);\n    if (popupWindow === null) {\n      this.warn('Popup Window is null. This can happen if you are using IE');\n      this._saveItem(this.CONSTANTS.STORAGE.ERROR, 'Error opening popup');\n      this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, 'Popup Window is null. This can happen if you are using IE');\n      this._saveItem(this.CONSTANTS.STORAGE.LOGIN_ERROR, 'Popup Window is null. This can happen if you are using IE');\n      if (this.callback) {\n        this.callback(this._getItem(this.CONSTANTS.STORAGE.LOGIN_ERROR), null);\n      }\n      return;\n    }\n    let registeredRedirectUri;\n    if (this.config.redirectUri.indexOf('#') === -1) {\n      registeredRedirectUri = this.config.redirectUri;\n    } else {\n      registeredRedirectUri = this.config.redirectUri.split('#')[0];\n    }\n    const pollTimer = window.setInterval(() => {\n      if (!popupWindow || popupWindow.closed || popupWindow.closed === undefined) {\n        this._loginInProgress = false;\n        window.clearInterval(pollTimer);\n      }\n      try {\n        if (popupWindow.location.href.indexOf(registeredRedirectUri) !== -1) {\n          if (this.isAngular) {\n            window.location.hash = popupWindow.location.hash;\n          } else {\n            this.handleWindowCallback(popupWindow.location.hash, popupWindow.location.search);\n          }\n          window.clearInterval(pollTimer);\n          this._loginInProgress = false;\n          this.info('Closing popup window');\n          popupWindow.close();\n        }\n      } catch (e) {\n      }\n    }, 20);\n  }\n\n  loginInProgress() {\n    return this._loginInProgress;\n  }\n\n  _hasResource(key) {\n    const keys = this._getItem(this.CONSTANTS.STORAGE.TOKEN_KEYS);\n    return keys && !this._isEmpty(keys) && (keys.indexOf(key + this.CONSTANTS.RESOURCE_DELIMETER) > -1);\n  }\n\n  /**\n   * Gets token for the specified resource from local storage cache\n   * @param {string}   resource A URI that identifies the resource for which the token is valid.\n   * @return {string} token if exists and not expired or null\n   */\n  getCachedToken(resource) {\n    if (!this._hasResource(resource)) {\n      return null;\n    }\n\n    const token = this._getItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY + resource);\n    const expired = this._getItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY + resource);\n\n    // If expiration is within offset, it will force renew\n    const offset = this.config.expireOffsetSeconds || 120;\n\n    if (expired && (expired > this._now() + offset)) {\n      return token;\n    }\n    this._saveItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY + resource, '');\n    this._saveItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY + resource, 0);\n    return null;\n  }\n\n  /**\n   * Retrieves and parse idToken from localstorage\n   * @return {User} user object\n   */\n  getCachedUser() {\n    if (this._user) {\n      return this._user;\n    }\n\n    const idtoken = this._getItem(this.CONSTANTS.STORAGE.IDTOKEN);\n    this._user = this._createUser(idtoken);\n    return this._user;\n  }\n\n  registerCallback(expectedState, resource, callback) {\n    this._activeRenewals[resource] = expectedState;\n    if (!this.callBacksMappedToRenewStates[expectedState]) {\n      this.callBacksMappedToRenewStates[expectedState] = [];\n    }\n    this.callBacksMappedToRenewStates[expectedState].push(callback);\n    if (!this.callBackMappedToRenewStates[expectedState]) {\n      this.callBackMappedToRenewStates[expectedState] = (message, token) => {\n        for (let i = 0; i < this.callBacksMappedToRenewStates[expectedState].length; ++i) {\n          try {\n            this.callBacksMappedToRenewStates[expectedState][i](message, token);\n          } catch (error) {\n            this.warn(error);\n          }\n        }\n        this._activeRenewals[resource] = null;\n        this.callBacksMappedToRenewStates[expectedState] = null;\n        this.callBackMappedToRenewStates[expectedState] = null;\n      };\n    }\n  }\n\n  /**\n   * Acquires access token with hidden iframe\n   * @param {string} resource  ResourceUri identifying the target resource\n   * @param {string} callback  ResourceUri identifying the target resource\n   */\n  _renewToken(resource, callback) {\n    // use iframe to try refresh token\n    // use given resource to create new authz url\n    this.info('renewToken is called for resource:' + resource);\n    const frameHandle = this._addAuthFrame('authRenewFrame' + resource);\n    const expectedState = this._guid() + '|' + resource;\n    this.config.state = expectedState;\n    // renew happens in iframe, so it keeps javascript context\n    this._renewStates.push(expectedState);\n\n    this.verbose('Renew token Expected state: ' + expectedState);\n    let urlNavigate = this._getNavigateUrl('token', resource) + '&prompt=none';\n    urlNavigate = this._addHintParameters(urlNavigate);\n\n    this.registerCallback(expectedState, resource, callback);\n    this.verbose('Navigate to:' + urlNavigate);\n    this._saveItem(this.CONSTANTS.STORAGE.LOGIN_REQUEST, '');\n    frameHandle.src = 'about:blank';\n    this._loadFrameTimeout(urlNavigate, 'authRenewFrame' + resource, resource);\n  }\n\n  _renewIdToken(callback) {\n    // use iframe to try refresh token\n    this.info('renewIdToken is called');\n    const frameHandle = this._addAuthFrame('authIdTokenFrame');\n    const expectedState = this._guid() + '|' + this.config.clientId;\n    this._idTokenNonce = this._guid();\n    this._saveItem(this.CONSTANTS.STORAGE.NONCE_IDTOKEN, this._idTokenNonce);\n    this.config.state = expectedState;\n    // renew happens in iframe, so it keeps javascript context\n    this._renewStates.push(expectedState);\n\n    this.verbose('Renew Idtoken Expected state: ' + expectedState);\n    let urlNavigate = this._getNavigateUrl(this.config.responseType, null) + '&prompt=none';\n    urlNavigate = this._addHintParameters(urlNavigate);\n\n    urlNavigate += '&nonce=' + encodeURIComponent(this._idTokenNonce);\n    this.registerCallback(expectedState, this.config.clientId, callback);\n    this.idTokenNonce = null;\n    this.verbose('Navigate to:' + urlNavigate);\n    this._saveItem(this.CONSTANTS.STORAGE.LOGIN_REQUEST, '');\n    frameHandle.src = 'about:blank';\n    this._loadFrameTimeout(urlNavigate, 'authIdTokenFrame', this.config.clientId);\n  }\n\n  _urlContainsQueryStringParameter(name, url) {\n    // regex to detect pattern of a ? or & followed by the name parameter and an equals character\n    const regex = new RegExp('[\\\\?&]' + name + '=');\n    return regex.test(url);\n  }\n\n  // Calling _loadFrame but with a timeout to signal failure in loadframeStatus. Callbacks are left\n  // registered when network errors occur and subsequent token requests for same resource are registered to the pending request\n  _loadFrameTimeout(urlNavigation, frameName, resource) {\n    // set iframe session to pending\n    this.verbose('Set loading state to pending for: ' + resource);\n    this._saveItem(this.CONSTANTS.STORAGE.RENEW_STATUS + resource, this.CONSTANTS.TOKEN_RENEW_STATUS_IN_PROGRESS);\n    this._loadFrame(urlNavigation, frameName);\n    setTimeout(() => {\n      if (this._getItem(this.CONSTANTS.STORAGE.RENEW_STATUS + resource) === this.CONSTANTS.TOKEN_RENEW_STATUS_IN_PROGRESS) {\n        // fail the iframe session if it's in pending state\n        this.verbose('Loading frame has timed out after: ' + (this.CONSTANTS.LOADFRAME_TIMEOUT / 1000) + ' seconds for resource ' + resource);\n        const expectedState = this._activeRenewals[resource];\n\n        this._saveItem(this.CONSTANTS.STORAGE.RENEW_STATUS + resource, this.CONSTANTS.TOKEN_RENEW_STATUS_CANCELED);\n\n        if (expectedState && this.callBackMappedToRenewStates[expectedState]) {\n          this.callBackMappedToRenewStates[expectedState]('Token renewal operation failed due to timeout', null);\n        }\n      }\n    }, this.CONSTANTS.LOADFRAME_TIMEOUT);\n  }\n\n  _loadFrame(urlNavigate, frameName) {\n    // This trick overcomes iframe navigation in IE\n    // IE does not load the page consistently in iframe\n    this.info('LoadFrame: ' + frameName);\n    const frameCheck = frameName;\n    setTimeout(() => {\n      const frameHandle = this._addAuthFrame(frameCheck);\n      if (frameHandle.src === '' || frameHandle.src === 'about:blank') {\n        frameHandle.src = urlNavigate;\n        this._loadFrame(urlNavigate, frameCheck);\n      }\n    }, 500);\n  }\n\n  /**\n   * Acquire token from cache if not expired and available. Acquires token from iframe if expired.\n   * @param {string} resource  ResourceUri identifying the target resource\n   * @param {function} callback The callback function\n   */\n  acquireToken(resource, callback) {\n    if (this._isEmpty(resource)) {\n      this.warn('resource is required');\n      callback('resource is required', null);\n      return;\n    }\n\n    const token = this.getCachedToken(resource);\n    if (token) {\n      this.info('Token is already in cache for resource:' + resource);\n      callback(null, token);\n      return;\n    }\n\n    if (!this._user) {\n      this.warn('User login is required');\n      callback('User login is required', null);\n      return;\n    }\n\n    // refresh attept with iframe\n    // Already renewing for this resource, callback when we get the token.\n    if (this._activeRenewals[resource]) {\n      // Active renewals contains the state for each renewal.\n      this.registerCallback(this._activeRenewals[resource], resource, callback);\n    } else if (resource === this.config.clientId) {\n      // App uses idtoken to send to api endpoints\n      // Default resource is tracked as clientid to store this token\n      this.verbose('renewing idtoken');\n      this._renewIdToken(callback);\n    } else {\n      this._renewToken(resource, callback);\n    }\n  }\n\n  /**\n   * Redirect the Browser to Azure AD Authorization endpoint\n   * @param {string} urlNavigate The authorization request url\n   */\n  promptUser(urlNavigate) {\n    if (urlNavigate) {\n      this.info('Navigate to:' + urlNavigate);\n      this.navigate(urlNavigate);\n    } else {\n      this.info('Navigate url is empty');\n    }\n  }\n\n  /**\n   * Clear cache items.\n   */\n  clearCache() {\n    this._saveItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY, '');\n    this._saveItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY, 0);\n    this._saveItem(this.CONSTANTS.STORAGE.SESSION_STATE, '');\n    this._saveItem(this.CONSTANTS.STORAGE.STATE_LOGIN, '');\n    this._renewStates = [];\n    this._saveItem(this.CONSTANTS.STORAGE.USERNAME, '');\n    this._saveItem(this.CONSTANTS.STORAGE.IDTOKEN, '');\n    this._saveItem(this.CONSTANTS.STORAGE.ERROR, '');\n    this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, '');\n    let keys = this._getItem(this.CONSTANTS.STORAGE.TOKEN_KEYS);\n\n    if (!this._isEmpty(keys)) {\n      keys = keys.split(this.CONSTANTS.RESOURCE_DELIMETER);\n      for (let i = 0; i < keys.length; i++) {\n        this._saveItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY + keys[i], '');\n        this._saveItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY + keys[i], 0);\n      }\n    }\n    this._saveItem(this.CONSTANTS.STORAGE.TOKEN_KEYS, '');\n  }\n\n  /**\n   * Clear cache items for a resource.\n   * @param {string} resource The resource\n   */\n  clearCacheForResource(resource) {\n    this._saveItem(this.CONSTANTS.STORAGE.STATE_RENEW, '');\n    this._saveItem(this.CONSTANTS.STORAGE.ERROR, '');\n    this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, '');\n    if (this._hasResource(resource)) {\n      this._saveItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY + resource, '');\n      this._saveItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY + resource, 0);\n    }\n  }\n\n  /**\n   * Logout user will redirect page to logout endpoint.\n   * After logout, it will redirect to post_logout page if provided.\n   */\n  logOut() {\n    this.clearCache();\n    let logout = '';\n    this._user = null;\n\n    if (this.config.postLogoutRedirectUri) {\n      logout = 'post_logout_redirect_uri=' + encodeURIComponent(this.config.postLogoutRedirectUri);\n    }\n\n    const urlNavigate = this.config.instance + 'logout?' + logout;\n    this.info('Logout navigate to: ' + urlNavigate);\n    this.promptUser(urlNavigate);\n  }\n\n  _isEmpty(str) {\n    return (typeof str === 'undefined' || !str || str.length === 0);\n  }\n\n  /**\n   * Gets a user profile\n   * @param {requestCallback} callback The callback that handles the response.\n   */\n  getUser(callback) {\n    // IDToken is first call\n    if (typeof callback !== 'function') {\n      throw new Error('callback is not a function');\n    }\n\n    // user in memory\n    if (this._user) {\n      callback(null, this._user);\n      return;\n    }\n\n    // frame is used to get idtoken\n    const idtoken = this._getItem(this.CONSTANTS.STORAGE.IDTOKEN);\n    if (this._isEmpty(idtoken)) {\n      this.warn('User information is not available');\n      callback('User information is not available');\n    } else {\n      this.info('User exists in cache: ');\n      this._user = this._createUser(idtoken);\n      callback(null, this._user);\n    }\n  }\n\n  _addHintParameters(urlNavigate) {\n    // include hint params only if upn is present\n    if (this._user && this._user.profile && this._user.profile.hasOwnProperty('upn')) {\n      // add login_hint\n      urlNavigate += '&login_hint=' + encodeURIComponent(this._user.profile.upn);\n\n      // don't add domain_hint twice if user provided it in the extraQueryParameter value\n      if (!this._urlContainsQueryStringParameter('domain_hint', urlNavigate) && this._user.profile.upn.indexOf('@') > -1) {\n        const parts = this._user.profile.upn.split('@');\n        // local part can include @ in quotes. Sending last part handles that.\n        urlNavigate += '&domain_hint=' + encodeURIComponent(parts[parts.length - 1]);\n      }\n    }\n\n    return urlNavigate;\n  }\n\n  _createUser(idToken) {\n    let user = null;\n    const parsedJson = this._extractIdToken(idToken);\n    if (parsedJson && parsedJson.hasOwnProperty('aud')) {\n      let audienceMatch = false;\n\n      if (Array.isArray(parsedJson.aud)) {\n        // If the ID Token contains multiple audiences then an azp claim must be present and equal to the client id.\n        if (parsedJson.hasOwnProperty('azp') && parsedJson.azp.toLowerCase() === this.config.clientId.toLowerCase()) {\n          for (let i = 0; i < parsedJson.aud.length; i++) {\n            if (parsedJson.aud[i].toLowerCase() === this.config.clientId.toLowerCase()) {\n              audienceMatch = true;\n              break;\n            }\n          }\n        }\n      } else {\n        audienceMatch = (parsedJson.aud.toLowerCase() === this.config.clientId.toLowerCase());\n      }\n\n      if (audienceMatch) {\n        user = {\n          userName: '',\n          profile: parsedJson\n        };\n\n        if (parsedJson.hasOwnProperty('upn')) {\n          user.userName = parsedJson.upn;\n        } else if (parsedJson.hasOwnProperty('email')) {\n          user.userName = parsedJson.email;\n        } else if (parsedJson.hasOwnProperty('sub')) {\n          user.userName = parsedJson.sub;\n        }\n      } else {\n        this.warn('IdToken has invalid aud/azp field');\n      }\n    }\n\n    return user;\n  }\n\n  _getHash(hash) {\n    if (hash.indexOf('#/') > -1) {\n      hash = hash.substring(hash.indexOf('#/') + 2);\n    } else if (hash.indexOf('#') > -1) {\n      hash = hash.substring(1);\n    }\n\n    return hash;\n  }\n\n  _getSearch(search) {\n    if (search.indexOf('?') > -1) {\n      search = search.substring(1);\n    }\n\n    return search;\n  }\n\n  _getParameters(hash, search) {\n    let parameters = {};\n\n    if (hash) {\n      hash = this._getHash(hash);\n      parameters = this._deserialize(hash);\n    }\n\n    if (search) {\n      search = this._getSearch(search);\n      const searchParameters = this._deserialize(search);\n      parameters = this._extend(parameters, searchParameters);\n    }\n\n    return parameters;\n  }\n\n  _extend(obj, src) {\n    for (const key in src) {\n      if (src.hasOwnProperty(key)) {\n        obj[key] = src[key];\n      }\n    }\n    return obj;\n  }\n\n  /**\n   * Checks if hash contains access token or id token or error_description\n   * @param {string} hash  -  Hash passed from redirect page\n   * @param {string} search  -  Search passed from redirect page\n   * @return {boolean} exists if all the parameters exist\n   */\n  isCallback(hash, search) {\n    const parameters = this._getParameters(hash, search);\n\n    return parameters.hasOwnProperty(this.CONSTANTS.ERROR_DESCRIPTION) ||\n      parameters.hasOwnProperty(this.CONSTANTS.ACCESS_TOKEN) ||\n      parameters.hasOwnProperty(this.CONSTANTS.ID_TOKEN);\n  }\n\n  /**\n   * Gets login error\n   * @return {string} error message related to login\n   */\n  getLoginError() {\n    return this._getItem(this.CONSTANTS.STORAGE.LOGIN_ERROR);\n  }\n\n  /**\n   * Gets requestInfo from given hash.\n   * @param {string} hash  -  Hash passed from redirect page\n   * @param {string} search  -  Search passed from redirect page\n   * @return {string} error message related to login\n   */\n  getRequestInfo(hash, search) {\n    const parameters = this._getParameters(hash, search);\n    const requestInfo = {\n      valid: false,\n      parameters: {},\n      stateMatch: false,\n      stateResponse: '',\n      requestType: this.REQUEST_TYPE.UNKNOWN\n    };\n\n    if (parameters) {\n      requestInfo.parameters = parameters;\n      if (parameters.hasOwnProperty(this.CONSTANTS.ERROR_DESCRIPTION) ||\n        parameters.hasOwnProperty(this.CONSTANTS.ACCESS_TOKEN) ||\n        parameters.hasOwnProperty(this.CONSTANTS.ID_TOKEN)) {\n        requestInfo.valid = true;\n\n        // which call\n        let stateResponse = '';\n        if (parameters.hasOwnProperty('state')) {\n          this.verbose('State: ' + parameters.state);\n          stateResponse = parameters.state;\n        } else {\n          this.warn('No state returned');\n          return requestInfo;\n        }\n\n        requestInfo.stateResponse = stateResponse;\n\n        // async calls can fire iframe and login request at the same time if developer does not use the API as expected\n        // incoming callback needs to be looked up to find the request type\n        if (stateResponse === this._getItem(this.CONSTANTS.STORAGE.STATE_LOGIN)) {\n          requestInfo.requestType = this.REQUEST_TYPE.LOGIN;\n          requestInfo.stateMatch = true;\n          return requestInfo;\n        }\n\n        // external api requests may have many renewtoken requests for different resource\n        if (!requestInfo.stateMatch && window.parent && window.parent.AuthenticationContext) {\n          const statesInParentContext = window.parent.AuthenticationContext._renewStates;\n          for (let i = 0; i < statesInParentContext.length; i++) {\n            if (statesInParentContext[i] === requestInfo.stateResponse) {\n              requestInfo.requestType = this.REQUEST_TYPE.RENEW_TOKEN;\n              requestInfo.stateMatch = true;\n              break;\n            }\n          }\n        }\n      }\n    }\n\n    return requestInfo;\n  }\n\n  _getResourceFromState(state) {\n    if (state) {\n      const splitIndex = state.indexOf('|');\n      if (splitIndex > -1 && splitIndex + 1 < state.length) {\n        return state.substring(splitIndex + 1);\n      }\n    }\n\n    return '';\n  }\n\n  /**\n   * Saves token from hash that is received from redirect.\n   * @param {string} requestInfo Hash passed from redirect page\n   */\n  saveTokenFromHash(requestInfo) {\n    this.info('State status:' + requestInfo.stateMatch + '; Request type:' + requestInfo.requestType);\n    this._saveItem(this.CONSTANTS.STORAGE.ERROR, '');\n    this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, '');\n\n    let resource = this._getResourceFromState(requestInfo.stateResponse);\n\n    // Record error\n    if (requestInfo.parameters.hasOwnProperty(this.CONSTANTS.ERROR_DESCRIPTION)) {\n      this.info('Error :' + requestInfo.parameters.error + '; Error description:' + requestInfo.parameters[this.CONSTANTS.ERROR_DESCRIPTION]);\n      this._saveItem(this.CONSTANTS.STORAGE.ERROR, requestInfo.parameters.error);\n      this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, requestInfo.parameters[this.CONSTANTS.ERROR_DESCRIPTION]);\n\n      if (requestInfo.requestType === this.REQUEST_TYPE.LOGIN) {\n        this._loginInProgress = false;\n        this._saveItem(this.CONSTANTS.STORAGE.LOGIN_ERROR, requestInfo.parameters.error_description);\n      }\n    } else if (requestInfo.stateMatch) {\n      // record tokens to storage if exists\n      this.info('State is right');\n      if (requestInfo.parameters.hasOwnProperty(this.CONSTANTS.SESSION_STATE)) {\n        this._saveItem(this.CONSTANTS.STORAGE.SESSION_STATE, requestInfo.parameters[this.CONSTANTS.SESSION_STATE]);\n      }\n\n      let keys;\n\n      if (requestInfo.parameters.hasOwnProperty(this.CONSTANTS.ACCESS_TOKEN)) {\n        this.info('Fragment has access token');\n\n        if (!this._hasResource(resource)) {\n          keys = this._getItem(this.CONSTANTS.STORAGE.TOKEN_KEYS) || '';\n          this._saveItem(this.CONSTANTS.STORAGE.TOKEN_KEYS, keys + resource + this.CONSTANTS.RESOURCE_DELIMETER);\n        }\n        // save token with related resource\n        this._saveItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY + resource, requestInfo.parameters[this.CONSTANTS.ACCESS_TOKEN]);\n        this._saveItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY + resource, this._expiresIn(requestInfo.parameters[this.CONSTANTS.EXPIRES_IN]));\n      }\n\n      if (requestInfo.parameters.hasOwnProperty(this.CONSTANTS.ID_TOKEN)) {\n        this.info('Fragment has id token');\n        this._loginInProgress = false;\n\n        this._user = this._createUser(requestInfo.parameters[this.CONSTANTS.ID_TOKEN]);\n\n        if (this._user && this._user.profile) {\n          if (this._user.profile.nonce === this._getItem(this.CONSTANTS.STORAGE.NONCE_IDTOKEN)) {\n            this._saveItem(this.CONSTANTS.STORAGE.IDTOKEN, requestInfo.parameters[this.CONSTANTS.ID_TOKEN]);\n\n            // Save idtoken as access token for app itself\n            resource = this.config.loginResource ? this.config.loginResource : this.config.clientId;\n\n            if (!this._hasResource(resource)) {\n              keys = this._getItem(this.CONSTANTS.STORAGE.TOKEN_KEYS) || '';\n              this._saveItem(this.CONSTANTS.STORAGE.TOKEN_KEYS, keys + resource + this.CONSTANTS.RESOURCE_DELIMETER);\n            }\n            this._saveItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY + resource, requestInfo.parameters[this.CONSTANTS.ID_TOKEN]);\n            this._saveItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY + resource, this._user.profile.exp);\n          } else {\n            this._user = null;\n            this._saveItem(this.CONSTANTS.STORAGE.LOGIN_ERROR, 'Nonce is not same as ' + this._idTokenNonce);\n          }\n        } else {\n          this._saveItem(this.CONSTANTS.STORAGE.ERROR, 'invalid id_token');\n          this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, 'Invalid id_token. id_token: ' + requestInfo.parameters[this.CONSTANTS.ID_TOKEN]);\n        }\n      }\n    } else {\n      this._saveItem(this.CONSTANTS.STORAGE.ERROR, 'Invalid_state');\n      this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, 'Invalid_state. state: ' + requestInfo.stateResponse);\n    }\n    this._saveItem(this.CONSTANTS.STORAGE.RENEW_STATUS + resource, this.CONSTANTS.TOKEN_RENEW_STATUS_COMPLETED);\n  }\n\n  /**\n   * Gets resource for given endpoint if mapping is provided with config.\n   * @param {string} endpoint API endpoint\n   * @return {string} resource for this API endpoint\n   */\n  getResourceForEndpoint(endpoint) {\n    if (this.config && this.config.endpoints) {\n      for (const configEndpoint in this.config.endpoints) {\n        // configEndpoint is like /api/Todo requested endpoint can be /api/Todo/1\n        if (endpoint.indexOf(configEndpoint) > -1) {\n          return this.config.endpoints[configEndpoint];\n        }\n      }\n    }\n\n    // default resource will be clientid if nothing specified\n    // App will use idtoken for calls to itself\n    // check if it's staring from http or https, needs to match with app host\n    if (endpoint.indexOf('http://') > -1 || endpoint.indexOf('https://') > -1) {\n      if (this._getHostFromUri(endpoint) === this._getHostFromUri(this.config.redirectUri)) {\n        return this.config.loginResource;\n      }\n    } else {\n      // in angular level, the url for $http interceptor call could be relative url,\n      // if it's relative call, we'll treat it as app backend call.\n      // if user specified list of anonymous endpoints, no need to send token to these endpoints, return null.\n      if (this.config && this.config.anonymousEndpoints) {\n        for (let i = 0; i < this.config.anonymousEndpoints.length; i++) {\n          if (endpoint.indexOf(this.config.anonymousEndpoints[i]) > -1) {\n            return null;\n          }\n        }\n      }\n      // all other app's backend calls are secured.\n      return this.config.loginResource;\n    }\n\n    // if not the app's own backend or not a domain listed in the endpoints structure\n    return null;\n  }\n\n  _getHostFromUri(uri) {\n    // remove http:// or https:// from uri\n    let extractedUri = String(uri).replace(/^(https?:)\\/\\//, '');\n\n    extractedUri = extractedUri.split('/')[0];\n    return extractedUri;\n  }\n\n  /* exported  oauth2Callback */\n  handleWindowCallback(hash, search) {\n    // This is for regular javascript usage for redirect handling\n    // need to make sure this is for callback\n    if (!hash) {\n      hash = window.location.hash;\n    }\n\n    if (!search) {\n      search = window.location.search;\n    }\n\n    if (this.isCallback(hash, search)) {\n      const requestInfo = this.getRequestInfo(hash, search);\n      this.info('Returned from redirect url');\n      this.saveTokenFromHash(requestInfo);\n      let callback = null;\n      if ((requestInfo.requestType === this.REQUEST_TYPE.RENEW_TOKEN) && this.isIframe()) {\n        // iframe call but same single page\n        this.verbose('Window is in iframe');\n        callback = window.parent.AuthenticationContext.callBackMappedToRenewStates[requestInfo.stateResponse];\n        if (callback) {\n          callback(this._getItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION), requestInfo.parameters[this.CONSTANTS.ACCESS_TOKEN] || requestInfo.parameters[this.CONSTANTS.ID_TOKEN]);\n        }\n        return;\n      } else if (requestInfo.requestType === this.REQUEST_TYPE.LOGIN) {\n        callback = this.callback;\n        if (callback) {\n          callback(this._getItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION), requestInfo.parameters[this.CONSTANTS.ID_TOKEN]);\n        }\n      }\n      // No need to redirect user in case of popup\n      if (!this.popUp) {\n        this.navigate(this._getItem(this.CONSTANTS.STORAGE.LOGIN_REQUEST));\n      }\n    }\n  }\n\n  _getNavigateUrl(responseType, resource) {\n    let urlNavigate = this.config.instance + 'authorize' + this._serialize(responseType, this.config, resource) + this._addLibMetadata();\n    if (this.config.scope) {\n      urlNavigate += '&scope=' + encodeURIComponent(this.config.scope);\n    }\n    this.info('Navigate url:' + urlNavigate);\n    return urlNavigate;\n  }\n\n  _extractIdToken(encodedIdToken) {\n    // id token will be decoded to get the username\n    const decodedToken = this._decodeJwt(encodedIdToken);\n    if (!decodedToken) {\n      return null;\n    }\n\n    try {\n      const base64IdToken = decodedToken.JWSPayload;\n      const base64Decoded = this._base64DecodeStringUrlSafe(base64IdToken);\n      if (!base64Decoded) {\n        this.info('The returned id_token could not be base64 url safe decoded.');\n        return null;\n      }\n\n      return JSON.parse(base64Decoded);\n    } catch (err) {\n      this.error('The returned id_token could not be decoded', err);\n    }\n\n    return null;\n  }\n\n  _base64DecodeStringUrlSafe(base64IdToken) {\n    base64IdToken = base64IdToken.replace(/-/g, '+').replace(/_/g, '/');\n    return decodeURIComponent(escape(window.atob(base64IdToken)));\n  }\n\n    // Auth.node js crack function\n  _decodeJwt(jwtToken) {\n    if (this._isEmpty(jwtToken)) {\n      return null;\n    }\n\n    const idTokenPartsRegex = /^([^\\.\\s]*)\\.([^\\.\\s]+)\\.([^\\.\\s]*)$/;\n\n    const matches = idTokenPartsRegex.exec(jwtToken);\n    if (!matches || matches.length < 4) {\n      this.warn('The returned id_token is not parseable.');\n      return null;\n    }\n\n    const crackedToken = {\n      header: matches[1],\n      JWSPayload: matches[2],\n      JWSSig: matches[3]\n    };\n\n    return crackedToken;\n  }\n\n  _convertUrlSafeToRegularBase64EncodedString(str) {\n    return str.replace('-', '+').replace('_', '/');\n  }\n\n  _serialize(responseType, obj, resource) {\n    const str = [];\n    if (obj !== null) {\n      str.push('?response_type=' + encodeURIComponent(responseType));\n      str.push('client_id=' + encodeURIComponent(obj.clientId));\n      if (resource) {\n        str.push('resource=' + encodeURIComponent(resource));\n      }\n\n      str.push('redirect_uri=' + encodeURIComponent(obj.redirectUri));\n      str.push('state=' + encodeURIComponent(obj.state));\n\n      if (obj.hasOwnProperty('slice')) {\n        str.push('slice=' + encodeURIComponent(obj.slice));\n      }\n\n      if (obj.hasOwnProperty('extraQueryParameter')) {\n        str.push(obj.extraQueryParameter);\n      }\n\n      const correlationId = obj.correlationId ? obj.correlationId : this._guid();\n      str.push('client-request-id=' + encodeURIComponent(correlationId));\n    }\n\n    return str.join('&');\n  }\n\n  _deserialize(query) {\n    const pl = /\\+/g; // Regex for replacing addition symbol with a space\n    const search = /([^&=]+)=([^&]*)/g;\n    const decode = (s) => {\n      return decodeURIComponent(s.replace(pl, ' '));\n    };\n    const obj = {};\n    let match = search.exec(query);\n    while (match) {\n      obj[decode(match[1])] = decode(match[2]);\n      match = search.exec(query);\n    }\n\n    return obj;\n  }\n\n  _decimalToHex(number) {\n    let hex = number.toString(16);\n    while (hex.length < 2) {\n      hex = '0' + hex;\n    }\n    return hex;\n  }\n\n  _guid() {\n    // RFC4122: The version 4 UUID is meant for generating UUIDs from truly-random or\n    // pseudo-random numbers.\n    // The algorithm is as follows:\n    //     Set the two most significant bits (bits 6 and 7) of the\n    //        clock_seq_hi_and_reserved to zero and one, respectively.\n    //     Set the four most significant bits (bits 12 through 15) of the\n    //        time_hi_and_version field to the 4-bit version number from\n    //        Section 4.1.3. Version4\n    //     Set all the other bits to randomly (or pseudo-randomly) chosen\n    //     values.\n    // UUID                   = time-low \"-\" time-mid \"-\"time-high-and-version \"-\"clock-seq-reserved and low(2hexOctet)\"-\" node\n    // time-low               = 4hexOctet\n    // time-mid               = 2hexOctet\n    // time-high-and-version  = 2hexOctet\n    // clock-seq-and-reserved = hexOctet:\n    // clock-seq-low          = hexOctet\n    // node                   = 6hexOctet\n    // Format: xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\n    // y could be 1000, 1001, 1010, 1011 since most significant two bits needs to be 10\n    // y values are 8, 9, A, B\n    if (this.crypto && this.crypto.getRandomValues) {\n      const buffer = new Uint8Array(16);\n      this.crypto.getRandomValues(buffer);\n      // buffer[6] and buffer[7] represents the time_hi_and_version field. We will set the four most significant bits (4 through 7) of buffer[6] to represent decimal number 4 (UUID version number).\n      buffer[6] |= 0x40; // buffer[6] | 01000000 will set the 6 bit to 1.\n      buffer[6] &= 0x4f; // buffer[6] & 01001111 will set the 4, 5, and 7 bit to 0 such that bits 4-7 == 0100 = \"4\".\n      // buffer[8] represents the clock_seq_hi_and_reserved field. We will set the two most significant bits (6 and 7) of the clock_seq_hi_and_reserved to zero and one, respectively.\n      buffer[8] |= 0x80; // buffer[8] | 10000000 will set the 7 bit to 1.\n      buffer[8] &= 0xbf; // buffer[8] & 10111111 will set the 6 bit to 0.\n      return this._decimalToHex(buffer[0]) + this._decimalToHex(buffer[1]) + this._decimalToHex(buffer[2]) + this._decimalToHex(buffer[3]) + '-' + this._decimalToHex(buffer[4]) + this._decimalToHex(buffer[5]) + '-' + this._decimalToHex(buffer[6]) + this._decimalToHex(buffer[7]) + '-' +\n             this._decimalToHex(buffer[8]) + this._decimalToHex(buffer[9]) + '-' + this._decimalToHex(buffer[10]) + this._decimalToHex(buffer[11]) + this._decimalToHex(buffer[12]) + this._decimalToHex(buffer[13]) + this._decimalToHex(buffer[14]) + this._decimalToHex(buffer[15]);\n    }\n    const guidHolder = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx';\n    const hex = '0123456789abcdef';\n    let r = 0;\n    let guidResponse = '';\n    for (let i = 0; i < 36; i++) {\n      if (guidHolder[i] !== '-' && guidHolder[i] !== '4') {\n                  // each x and y needs to be random\n        r = Math.random() * 16 | 0;\n      }\n      if (guidHolder[i] === 'x') {\n        guidResponse += hex[r];\n      } else if (guidHolder[i] === 'y') {\n                  // clock-seq-and-reserved first hex is filtered and remaining hex values are random\n        r &= 0x3; // bit and with 0011 to set pos 2 to zero ?0??\n        r |= 0x8; // set pos 3 to 1 as 1???\n        guidResponse += hex[r];\n      } else {\n        guidResponse += guidHolder[i];\n      }\n    }\n    return guidResponse;\n  }\n\n  _expiresIn(expires) {\n    return this._now() + parseInt(expires, 10);\n  }\n\n  _now() {\n    return Math.round(new Date().getTime() / 1000.0);\n  }\n\n  _addAuthFrame(iframeId) {\n    if (typeof iframeId === 'undefined') {\n      return;\n    }\n\n    this.info('Add auth frame to document:' + iframeId);\n    let authFrame = document.getElementById(iframeId);\n\n    if (!authFrame) {\n      if (document.createElement && document.documentElement &&\n                (window.opera || window.navigator.userAgent.indexOf('MSIE 5.0') === -1)) {\n        const ifr = document.createElement('iframe');\n        ifr.setAttribute('id', iframeId);\n        ifr.style.visibility = 'hidden';\n        ifr.style.position = 'absolute';\n        ifr.style.width = ifr.style.height = ifr.borderWidth = '0px';\n\n        authFrame = document.getElementsByTagName('body')[0].appendChild(ifr);\n      } else if (document.body && document.body.insertAdjacentHTML) {\n        document.body.insertAdjacentHTML('beforeEnd', '<iframe name=\"' + iframeId + '\" id=\"' + iframeId + '\" style=\"display:none\"></iframe>');\n      }\n      if (window.frames && window.frames[iframeId]) {\n        authFrame = window.frames[iframeId];\n      }\n    }\n\n    return authFrame;\n  }\n\n  _saveItem(key, obj) {\n    if (this.config && this.config.cacheLocation && this.config.cacheLocation === 'localStorage') {\n      if (!this._supportsLocalStorage()) {\n        this.info('Local storage is not supported');\n        return false;\n      }\n\n      localStorage.setItem(key, obj);\n\n      return true;\n    }\n\n    // Default as session storage\n    if (!this._supportsSessionStorage()) {\n      this.info('Session storage is not supported');\n      return false;\n    }\n\n    sessionStorage.setItem(key, obj);\n    return true;\n  }\n\n  _getItem(key) {\n    if (this.config && this.config.cacheLocation && this.config.cacheLocation === 'localStorage') {\n      if (!this._supportsLocalStorage()) {\n        this.info('Local storage is not supported');\n        return null;\n      }\n\n      return localStorage.getItem(key);\n    }\n\n    // Default as session storage\n    if (!this._supportsSessionStorage()) {\n      this.info('Session storage is not supported');\n      return null;\n    }\n\n    return sessionStorage.getItem(key);\n  }\n\n  _supportsLocalStorage() {\n    try {\n      return 'localStorage' in window && window.localStorage;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  _supportsSessionStorage() {\n    try {\n      return 'sessionStorage' in window && window.sessionStorage;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  _cloneConfig(obj) {\n    if (obj === null || typeof obj !== 'object') {\n      return obj;\n    }\n\n    const copy = {};\n    for (const attr in obj) {\n      if (obj.hasOwnProperty(attr)) {\n        copy[attr] = obj[attr];\n      }\n    }\n    return copy;\n  }\n\n  _addLibMetadata() {\n    // x-client-SKU\n    // x-client-Ver\n    return '&x-client-SKU=Js&x-client-Ver=' + this._libVersion();\n  }\n\n  log(level, message, error) {\n    if (level <= Logging.level) {\n      const timestamp = new Date().toUTCString();\n      let formattedMessage = '';\n\n      if (this.config.correlationId) {\n        formattedMessage = timestamp + ':' + this.config.correlationId + '-' + this._libVersion() + '-' + this.CONSTANTS.LEVEL_STRING_MAP[level] + ' ' + message;\n      } else {\n        formattedMessage = timestamp + ':' + this._libVersion() + '-' + this.CONSTANTS.LEVEL_STRING_MAP[level] + ' ' + message;\n      }\n\n      if (error) {\n        formattedMessage += '\\nstack:\\n' + error.stack;\n      }\n\n      Logging.log(formattedMessage);\n    }\n  }\n\n  error(message, error) {\n    this.log(this.CONSTANTS.LOGGING_LEVEL.ERROR, message, error);\n  }\n\n  warn(message) {\n    this.log(this.CONSTANTS.LOGGING_LEVEL.WARN, message, null);\n  }\n\n  info(message) {\n    this.log(this.CONSTANTS.LOGGING_LEVEL.INFO, message, null);\n  }\n\n  verbose(message) {\n    this.log(this.CONSTANTS.LOGGING_LEVEL.VERBOSE, message, null);\n  }\n\n  navigate(url) {\n    window.location.replace(url);\n  }\n\n  isIframe() {\n    return window.parent && window.parent !== window;\n  }\n\n  open(url, name, features) {\n    return window.open(url, name, features);\n  }\n\n  _libVersion() {\n    return '1.0.12';\n  }\n}\n\nglobal.Logging = {\n  level: 0,\n  log: (message) => {}\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./salte-auth.js\n **/"],"sourceRoot":""}