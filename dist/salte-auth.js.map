{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///salte-auth.js","webpack:///webpack/bootstrap 90f988eb93128328e79e","webpack:///./salte-auth.js","webpack:///../~/uuid/lib/rng-browser.js","webpack:///../~/uuid/uuid.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","global","_interopRequireDefault","obj","__esModule","default","_classCallCheck","instance","Constructor","TypeError","Object","defineProperty","value","_typeof","Symbol","iterator","constructor","prototype","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","protoProps","staticProps","_uuid","_uuid2","AuthenticationContext","config","REQUEST_TYPE","LOGIN","RENEW_TOKEN","UNKNOWN","CONSTANTS","ACCESS_TOKEN","EXPIRES_IN","ID_TOKEN","ERROR_DESCRIPTION","SESSION_STATE","STORAGE","TOKEN_KEYS","ACCESS_TOKEN_KEY","EXPIRATION_KEY","STATE_LOGIN","STATE_RENEW","NONCE_IDTOKEN","USERNAME","IDTOKEN","ERROR","LOGIN_REQUEST","LOGIN_ERROR","RENEW_STATUS","RESOURCE_DELIMETER","LOADFRAME_TIMEOUT","TOKEN_RENEW_STATUS_CANCELED","TOKEN_RENEW_STATUS_COMPLETED","TOKEN_RENEW_STATUS_IN_PROGRESS","LOGGING_LEVEL","WARN","INFO","VERBOSE","LEVEL_STRING_MAP","0","1","2","3","POPUP_WIDTH","POPUP_HEIGHT","window","callback","popUp","isAngular","_user","_activeRenewals","_loginInProgress","_renewStates","callBackMappedToRenewStates","callBacksMappedToRenewStates","displayCall","Error","clientId","_cloneConfig","url","match","loginResource","redirectUri","location","href","anonymousEndpoints","setResponseType","responseType","startPage","info","expectedState","v4","state","_idTokenNonce","verbose","_saveItem","urlNavigate","_getNavigateUrl","encodeURIComponent","_loginPopup","promptUser","title","popUpWidth","popUpHeight","winLeft","screenLeft","screenX","winTop","screenTop","screenY","width","innerWidth","document","documentElement","clientWidth","body","height","innerHeight","clientHeight","left","top","popupWindow","open","focus","e","warn","message","_this","_openPopup","_getItem","registeredRedirectUri","indexOf","split","pollTimer","setInterval","closed","undefined","clearInterval","hash","handleWindowCallback","search","close","keys","_isEmpty","resource","_hasResource","token","expired","offset","expireOffsetSeconds","_now","idtoken","_createUser","_this2","push","error","frameHandle","_addAuthFrame","_addHintParameters","registerCallback","src","_loadFrameTimeout","idTokenNonce","name","regex","RegExp","test","urlNavigation","frameName","_this3","_loadFrame","setTimeout","_this4","frameCheck","getCachedToken","_renewIdToken","_renewToken","navigate","clearCache","logout","postLogoutRedirectUri","str","profile","hasOwnProperty","upn","_urlContainsQueryStringParameter","parts","idToken","user","parsedJson","_extractIdToken","audienceMatch","Array","isArray","aud","azp","toLowerCase","userName","email","sub","substring","parameters","_getHash","_deserialize","_getSearch","searchParameters","_extend","_getParameters","requestInfo","valid","stateMatch","stateResponse","requestType","parent","statesInParentContext","splitIndex","_getResourceFromState","error_description","_expiresIn","nonce","exp","endpoint","securedEndpoints","configEndpoint","_getHostFromUri","uri","extractedUri","String","replace","isCallback","getRequestInfo","saveTokenFromHash","isIframe","_serialize","_addLibMetadata","scope","encodedIdToken","decodedToken","_decodeJwt","base64IdToken","JWSPayload","base64Decoded","_base64DecodeStringUrlSafe","JSON","parse","err","decodeURIComponent","escape","atob","jwtToken","idTokenPartsRegex","matches","exec","crackedToken","header","JWSSig","slice","extraQueryParameter","correlationId","join","query","pl","decode","s","number","hex","toString","expires","parseInt","Math","round","Date","getTime","iframeId","authFrame","getElementById","createElement","opera","navigator","userAgent","ifr","setAttribute","style","visibility","position","borderWidth","getElementsByTagName","appendChild","insertAdjacentHTML","frames","cacheLocation","_supportsLocalStorage","localStorage","setItem","_supportsSessionStorage","sessionStorage","getItem","copy","attr","_libVersion","level","Logging","timestamp","toUTCString","formattedMessage","stack","log","features","rng","crypto","msCrypto","getRandomValues","_rnds8","Uint8Array","_rnds","r","random","buff_to_string","buf","bth","_byteToHex","v1","options","b","clockseq","_clockseq","msecs","nsecs","_lastNSecs","dt","_lastMSecs","tl","tmh","node","_nodeId","n","rnds","_rng","ii","_hexToByte","substr","_seedBytes","uuid"],"mappings":"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","file":"salte-auth.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"salte-auth\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"salte-auth\"] = factory();\n\telse\n\t\troot[\"salte-auth\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","/**\n * salte-auth JavaScript Library v1.0.11\n *\n * @license MIT (https://github.com/salte-io/salte-auth/blob/master/LICENSE)\n *\n * Made with â™¥ by Nick Woodward <nick@salte.io>, Dave Woodward <dave@salte.io>\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"salte-auth\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"salte-auth\"] = factory();\n\telse\n\t\troot[\"salte-auth\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @public\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @class Config\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @property {string} url                 Required.  This is the base url for the identity provider's authorize endpoint; not including authorize.\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @property {string} responseType        Optional; defaults to id_token.  OAuth 2.0 Response Type value that determines the authorization processing flow to be used, including what parameters are returned from the endpoints used.\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @property {string} clientId            Required.  OAuth 2.0 Client Identifier valid at the Authorization Server.\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @property {string} scope               Optional.  This may be used to define the specific authorization(s) being requested from the resource owner.\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @property {string} redirectUri         Optional; defaults to current window location.  Redirection URI to which the response will be sent. This URI MUST exactly match one of the Redirection URI values for the Client pre-registered at the OpenID Provider.\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @property {string} loginResource       Optional; defaults to clientId.\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @property {object} securedEndpoints    Optional.  Object containing one or more named endpoints (e.g. { \"Endpoint\": \"ResourceId\" }).  This list is used to identify endpoints to which tokens should be attached.  If \"Endpoint\" exists anywhere within the endpoint being called then it is considered to be a match.  If the endpoint being called doesn't match then either no token will be passed or, if the endpoint's hostname matches the application hostname, then the id_token will be passed.\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @property {Array} anonymousEndpoints   Optional.  Array containing one or more endpoints to which a token need not be attached.  If the endpoint specified exists anywhere within the endpoint being called then it is considered to be a match.\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @property {boolean} isAngular          Optional.  Used to tell this library whether it should handle the callback from the authorization server itself or bubble the response up to the main window's URL and let the Angular http interceptor handle it.\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @property {function} displayCall       Optional.  If specified then this function will be called with the fully-formed authorization url when login is invoked.\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @property {boolean} popUp              Optional; defaults to true.\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @property {function} callback          Optional.  If specified then this function will be called upon receiving a successful response or error from the authorization server.\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */\n\t\n\t/**\n\t * User information from idtoken.\n\t *  @class User\n\t *  @property {string} userName - username assigned from upn, email, or sub (i.e. subject).\n\t *  @property {object} profile - properties parsed from idtoken.\n\t */\n\t\n\tvar _uuid = __webpack_require__(2);\n\t\n\tvar _uuid2 = _interopRequireDefault(_uuid);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar AuthenticationContext = function () {\n\t  /**\n\t   * Creates a new AuthenticationContext object.\n\t   * @constructor\n\t   * @param {object}  config               Configuration options for AuthenticationContext\n\t   */\n\t  function AuthenticationContext(config) {\n\t    _classCallCheck(this, AuthenticationContext);\n\t\n\t    /**\n\t    * Enum for request type\n\t    * @enum {string}\n\t    */\n\t    this.REQUEST_TYPE = {\n\t      LOGIN: 'LOGIN',\n\t      RENEW_TOKEN: 'RENEW_TOKEN',\n\t      UNKNOWN: 'UNKNOWN'\n\t    };\n\t\n\t    /**\n\t    * Enum for storage constants\n\t    * @enum {string}\n\t    */\n\t    this.CONSTANTS = {\n\t      ACCESS_TOKEN: 'access_token',\n\t      EXPIRES_IN: 'expires_in',\n\t      ID_TOKEN: 'id_token',\n\t      ERROR_DESCRIPTION: 'error_description',\n\t      SESSION_STATE: 'session_state',\n\t      STORAGE: {\n\t        TOKEN_KEYS: 'auth.token.keys',\n\t        ACCESS_TOKEN_KEY: 'auth.access.token.key',\n\t        EXPIRATION_KEY: 'auth.expiration.key',\n\t        STATE_LOGIN: 'auth.state.login',\n\t        STATE_RENEW: 'auth.state.renew',\n\t        NONCE_IDTOKEN: 'auth.nonce.idtoken',\n\t        SESSION_STATE: 'auth.session.state',\n\t        USERNAME: 'auth.username',\n\t        IDTOKEN: 'auth.idtoken',\n\t        ERROR: 'auth.error',\n\t        ERROR_DESCRIPTION: 'auth.error.description',\n\t        LOGIN_REQUEST: 'auth.login.request',\n\t        LOGIN_ERROR: 'auth.login.error',\n\t        RENEW_STATUS: 'auth.token.renew.status'\n\t      },\n\t      RESOURCE_DELIMETER: '|',\n\t      LOADFRAME_TIMEOUT: '6000',\n\t      TOKEN_RENEW_STATUS_CANCELED: 'Canceled',\n\t      TOKEN_RENEW_STATUS_COMPLETED: 'Completed',\n\t      TOKEN_RENEW_STATUS_IN_PROGRESS: 'In Progress',\n\t      LOGGING_LEVEL: {\n\t        ERROR: 0,\n\t        WARN: 1,\n\t        INFO: 2,\n\t        VERBOSE: 3\n\t      },\n\t      LEVEL_STRING_MAP: {\n\t        0: 'ERROR:',\n\t        1: 'WARNING:',\n\t        2: 'INFO:',\n\t        3: 'VERBOSE:'\n\t      },\n\t      POPUP_WIDTH: 483,\n\t      POPUP_HEIGHT: 600\n\t    };\n\t\n\t    if (window.AuthenticationContext) {\n\t      return window.AuthenticationContext;\n\t    }\n\t    window.AuthenticationContext = this;\n\t\n\t    // public\n\t    this.config = {};\n\t    this.callback = null;\n\t    this.popUp = false;\n\t    this.isAngular = false;\n\t\n\t    // private\n\t    this._user = null;\n\t    this._activeRenewals = {};\n\t    this._loginInProgress = false;\n\t    this._renewStates = [];\n\t\n\t    this.callBackMappedToRenewStates = {};\n\t    this.callBacksMappedToRenewStates = {};\n\t\n\t    // validate before constructor assignments\n\t    if (config.displayCall && typeof config.displayCall !== 'function') {\n\t      throw new Error('displayCall is not a function');\n\t    }\n\t\n\t    if (!config.clientId) {\n\t      throw new Error('clientId is required');\n\t    }\n\t\n\t    this.config = this._cloneConfig(config);\n\t\n\t    if (this.config.popUp) {\n\t      this.popUp = true;\n\t    }\n\t\n\t    if (this.config.callback && typeof this.config.callback === 'function') {\n\t      this.callback = this.config.callback;\n\t    }\n\t\n\t    if (!this.config.url || !this.config.url.match(/^https:\\/\\/.*\\/$/)) {\n\t      throw new Error('url must be a valid https endpoint that ends in a forward slash.');\n\t    }\n\t\n\t    // App can request idtoken for itself using clientid as resource\n\t    if (!this.config.loginResource) {\n\t      this.config.loginResource = this.config.clientId;\n\t    }\n\t\n\t    if (!this.config.redirectUri) {\n\t      this.config.redirectUri = window.location.href;\n\t    }\n\t\n\t    if (!this.config.anonymousEndpoints) {\n\t      this.config.anonymousEndpoints = [];\n\t    }\n\t\n\t    if (this.config.isAngular) {\n\t      this.isAngular = this.config.isAngular;\n\t    }\n\t\n\t    this.setResponseType(this.config.responseType);\n\t  }\n\t\n\t  _createClass(AuthenticationContext, [{\n\t    key: 'setResponseType',\n\t    value: function setResponseType(responseType) {\n\t      this.config.responseType = responseType || this.CONSTANTS.ID_TOKEN;\n\t    }\n\t\n\t    /**\n\t     * Gets initial Idtoken for the app backend\n\t     * Saves the resulting Idtoken in localStorage.\n\t     * @param {string} startPage the start page\n\t     */\n\t\n\t  }, {\n\t    key: 'login',\n\t    value: function login(startPage) {\n\t      // Token is not present and user needs to login\n\t      if (this._loginInProgress) {\n\t        this.info('Login in progress');\n\t        return;\n\t      }\n\t      var expectedState = _uuid2.default.v4();\n\t      this.config.state = expectedState;\n\t      this._idTokenNonce = _uuid2.default.v4();\n\t      if (!startPage) {\n\t        startPage = window.location;\n\t      }\n\t      this.verbose('Expected state: ' + expectedState + ' startPage:' + startPage);\n\t      this._saveItem(this.CONSTANTS.STORAGE.LOGIN_REQUEST, startPage);\n\t      this._saveItem(this.CONSTANTS.STORAGE.LOGIN_ERROR, '');\n\t      this._saveItem(this.CONSTANTS.STORAGE.STATE_LOGIN, expectedState);\n\t      this._saveItem(this.CONSTANTS.STORAGE.NONCE_IDTOKEN, this._idTokenNonce);\n\t      this._saveItem(this.CONSTANTS.STORAGE.ERROR, '');\n\t      this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, '');\n\t      var urlNavigate = this._getNavigateUrl(this.config.responseType, null) + '&nonce=' + encodeURIComponent(this._idTokenNonce);\n\t      this._loginInProgress = true;\n\t      if (this.popUp) {\n\t        this._loginPopup(urlNavigate);\n\t        return;\n\t      }\n\t      if (this.config.displayCall) {\n\t        // User defined way of handling the navigation\n\t        this.config.displayCall(urlNavigate);\n\t      } else {\n\t        this.promptUser(urlNavigate);\n\t      }\n\t    }\n\t  }, {\n\t    key: '_openPopup',\n\t    value: function _openPopup(urlNavigate, title, popUpWidth, popUpHeight) {\n\t      try {\n\t        /**\n\t        * adding winLeft and winTop to account for dual monitor\n\t        * using screenLeft and screenTop for IE8 and earlier\n\t        */\n\t        var winLeft = window.screenLeft ? window.screenLeft : window.screenX;\n\t        var winTop = window.screenTop ? window.screenTop : window.screenY;\n\t        /**\n\t        * window.innerWidth displays browser window's height and width excluding toolbars\n\t        * using document.documentElement.clientWidth for IE8 and earlier\n\t        */\n\t        var width = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;\n\t        var height = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;\n\t        var left = width / 2 - popUpWidth / 2 + winLeft;\n\t        var top = height / 2 - popUpHeight / 2 + winTop;\n\t\n\t        var popupWindow = this.open(urlNavigate, title, 'width=' + popUpWidth + ', height=' + popUpHeight + ', top=' + top + ', left=' + left);\n\t        if (popupWindow.focus) {\n\t          popupWindow.focus();\n\t        }\n\t        return popupWindow;\n\t      } catch (e) {\n\t        this.warn('Error opening popup, ' + e.message);\n\t        this._loginInProgress = false;\n\t        return null;\n\t      }\n\t    }\n\t  }, {\n\t    key: '_loginPopup',\n\t    value: function _loginPopup(urlNavigate) {\n\t      var _this = this;\n\t\n\t      var popupWindow = this._openPopup(urlNavigate, 'login', this.CONSTANTS.POPUP_WIDTH, this.CONSTANTS.POPUP_HEIGHT);\n\t      if (popupWindow === null) {\n\t        this.warn('Popup Window is null. This can happen if you are using IE');\n\t        this._saveItem(this.CONSTANTS.STORAGE.ERROR, 'Error opening popup');\n\t        this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, 'Popup Window is null. This can happen if you are using IE');\n\t        this._saveItem(this.CONSTANTS.STORAGE.LOGIN_ERROR, 'Popup Window is null. This can happen if you are using IE');\n\t        if (this.callback) {\n\t          this.callback(this._getItem(this.CONSTANTS.STORAGE.LOGIN_ERROR), null);\n\t        }\n\t        return;\n\t      }\n\t      var registeredRedirectUri = void 0;\n\t      if (this.config.redirectUri.indexOf('#') === -1) {\n\t        registeredRedirectUri = this.config.redirectUri;\n\t      } else {\n\t        registeredRedirectUri = this.config.redirectUri.split('#')[0];\n\t      }\n\t      var pollTimer = window.setInterval(function () {\n\t        if (!popupWindow || popupWindow.closed || popupWindow.closed === undefined) {\n\t          _this._loginInProgress = false;\n\t          window.clearInterval(pollTimer);\n\t        }\n\t        try {\n\t          if (popupWindow.location.href.indexOf(registeredRedirectUri) !== -1) {\n\t            if (_this.isAngular) {\n\t              window.location.hash = popupWindow.location.hash;\n\t            } else {\n\t              _this.handleWindowCallback(popupWindow.location.hash, popupWindow.location.search);\n\t            }\n\t            window.clearInterval(pollTimer);\n\t            _this._loginInProgress = false;\n\t            _this.info('Closing popup window');\n\t            popupWindow.close();\n\t          }\n\t        } catch (e) {}\n\t      }, 20);\n\t    }\n\t  }, {\n\t    key: 'loginInProgress',\n\t    value: function loginInProgress() {\n\t      return this._loginInProgress;\n\t    }\n\t  }, {\n\t    key: '_hasResource',\n\t    value: function _hasResource(key) {\n\t      var keys = this._getItem(this.CONSTANTS.STORAGE.TOKEN_KEYS);\n\t      return keys && !this._isEmpty(keys) && keys.indexOf(key + this.CONSTANTS.RESOURCE_DELIMETER) > -1;\n\t    }\n\t\n\t    /**\n\t     * Gets token for the specified resource from local storage cache\n\t     * @param {string}   resource A URI that identifies the resource for which the token is valid.\n\t     * @return {string} token if exists and not expired or null\n\t     */\n\t\n\t  }, {\n\t    key: 'getCachedToken',\n\t    value: function getCachedToken(resource) {\n\t      if (!this._hasResource(resource)) {\n\t        return null;\n\t      }\n\t\n\t      var token = this._getItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY + resource);\n\t      var expired = this._getItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY + resource);\n\t\n\t      // If expiration is within offset, it will force renew\n\t      var offset = this.config.expireOffsetSeconds || 120;\n\t\n\t      if (expired && expired > this._now() + offset) {\n\t        return token;\n\t      }\n\t      this._saveItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY + resource, '');\n\t      this._saveItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY + resource, 0);\n\t      return null;\n\t    }\n\t\n\t    /**\n\t     * Retrieves and parse idToken from localstorage\n\t     * @return {User} user object\n\t     */\n\t\n\t  }, {\n\t    key: 'getCachedUser',\n\t    value: function getCachedUser() {\n\t      if (this._user) {\n\t        return this._user;\n\t      }\n\t\n\t      var idtoken = this._getItem(this.CONSTANTS.STORAGE.IDTOKEN);\n\t      this._user = this._createUser(idtoken);\n\t      return this._user;\n\t    }\n\t  }, {\n\t    key: 'registerCallback',\n\t    value: function registerCallback(expectedState, resource, callback) {\n\t      var _this2 = this;\n\t\n\t      this._activeRenewals[resource] = expectedState;\n\t      if (!this.callBacksMappedToRenewStates[expectedState]) {\n\t        this.callBacksMappedToRenewStates[expectedState] = [];\n\t      }\n\t      this.callBacksMappedToRenewStates[expectedState].push(callback);\n\t      if (!this.callBackMappedToRenewStates[expectedState]) {\n\t        this.callBackMappedToRenewStates[expectedState] = function (message, token) {\n\t          for (var i = 0; i < _this2.callBacksMappedToRenewStates[expectedState].length; ++i) {\n\t            try {\n\t              _this2.callBacksMappedToRenewStates[expectedState][i](message, token);\n\t            } catch (error) {\n\t              _this2.warn(error);\n\t            }\n\t          }\n\t          _this2._activeRenewals[resource] = null;\n\t          _this2.callBacksMappedToRenewStates[expectedState] = null;\n\t          _this2.callBackMappedToRenewStates[expectedState] = null;\n\t        };\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Acquires access token with hidden iframe\n\t     * @param {string} resource  ResourceUri identifying the target resource\n\t     * @param {string} callback  ResourceUri identifying the target resource\n\t     */\n\t\n\t  }, {\n\t    key: '_renewToken',\n\t    value: function _renewToken(resource, callback) {\n\t      // use iframe to try refresh token\n\t      // use given resource to create new authz url\n\t      this.info('renewToken is called for resource:' + resource);\n\t      var frameHandle = this._addAuthFrame('authRenewFrame' + resource);\n\t      var expectedState = _uuid2.default.v4() + '|' + resource;\n\t      this.config.state = expectedState;\n\t      // renew happens in iframe, so it keeps javascript context\n\t      this._renewStates.push(expectedState);\n\t\n\t      this.verbose('Renew token Expected state: ' + expectedState);\n\t      var urlNavigate = this._getNavigateUrl('token', resource) + '&prompt=none';\n\t      urlNavigate = this._addHintParameters(urlNavigate);\n\t\n\t      this.registerCallback(expectedState, resource, callback);\n\t      this.verbose('Navigate to:' + urlNavigate);\n\t      this._saveItem(this.CONSTANTS.STORAGE.LOGIN_REQUEST, '');\n\t      frameHandle.src = 'about:blank';\n\t      this._loadFrameTimeout(urlNavigate, 'authRenewFrame' + resource, resource);\n\t    }\n\t  }, {\n\t    key: '_renewIdToken',\n\t    value: function _renewIdToken(callback) {\n\t      // use iframe to try refresh token\n\t      this.info('renewIdToken is called');\n\t      var frameHandle = this._addAuthFrame('authIdTokenFrame');\n\t      var expectedState = _uuid2.default.v4() + '|' + this.config.clientId;\n\t      this._idTokenNonce = _uuid2.default.v4();\n\t      this._saveItem(this.CONSTANTS.STORAGE.NONCE_IDTOKEN, this._idTokenNonce);\n\t      this.config.state = expectedState;\n\t      // renew happens in iframe, so it keeps javascript context\n\t      this._renewStates.push(expectedState);\n\t\n\t      this.verbose('Renew Idtoken Expected state: ' + expectedState);\n\t      var urlNavigate = this._getNavigateUrl(this.config.responseType, null) + '&prompt=none';\n\t      urlNavigate = this._addHintParameters(urlNavigate);\n\t\n\t      urlNavigate += '&nonce=' + encodeURIComponent(this._idTokenNonce);\n\t      this.registerCallback(expectedState, this.config.clientId, callback);\n\t      this.idTokenNonce = null;\n\t      this.verbose('Navigate to:' + urlNavigate);\n\t      this._saveItem(this.CONSTANTS.STORAGE.LOGIN_REQUEST, '');\n\t      frameHandle.src = 'about:blank';\n\t      this._loadFrameTimeout(urlNavigate, 'authIdTokenFrame', this.config.clientId);\n\t    }\n\t  }, {\n\t    key: '_urlContainsQueryStringParameter',\n\t    value: function _urlContainsQueryStringParameter(name, url) {\n\t      // regex to detect pattern of a ? or & followed by the name parameter and an equals character\n\t      var regex = new RegExp('[\\\\?&]' + name + '=');\n\t      return regex.test(url);\n\t    }\n\t\n\t    // Calling _loadFrame but with a timeout to signal failure in loadframeStatus. Callbacks are left\n\t    // registered when network errors occur and subsequent token requests for same resource are registered to the pending request\n\t\n\t  }, {\n\t    key: '_loadFrameTimeout',\n\t    value: function _loadFrameTimeout(urlNavigation, frameName, resource) {\n\t      var _this3 = this;\n\t\n\t      // set iframe session to pending\n\t      this.verbose('Set loading state to pending for: ' + resource);\n\t      this._saveItem(this.CONSTANTS.STORAGE.RENEW_STATUS + resource, this.CONSTANTS.TOKEN_RENEW_STATUS_IN_PROGRESS);\n\t      this._loadFrame(urlNavigation, frameName);\n\t      setTimeout(function () {\n\t        if (_this3._getItem(_this3.CONSTANTS.STORAGE.RENEW_STATUS + resource) === _this3.CONSTANTS.TOKEN_RENEW_STATUS_IN_PROGRESS) {\n\t          // fail the iframe session if it's in pending state\n\t          _this3.verbose('Loading frame has timed out after: ' + _this3.CONSTANTS.LOADFRAME_TIMEOUT / 1000 + ' seconds for resource ' + resource);\n\t          var expectedState = _this3._activeRenewals[resource];\n\t\n\t          _this3._saveItem(_this3.CONSTANTS.STORAGE.RENEW_STATUS + resource, _this3.CONSTANTS.TOKEN_RENEW_STATUS_CANCELED);\n\t\n\t          if (expectedState && _this3.callBackMappedToRenewStates[expectedState]) {\n\t            _this3.callBackMappedToRenewStates[expectedState]('Token renewal operation failed due to timeout', null);\n\t          }\n\t        }\n\t      }, this.CONSTANTS.LOADFRAME_TIMEOUT);\n\t    }\n\t  }, {\n\t    key: '_loadFrame',\n\t    value: function _loadFrame(urlNavigate, frameName) {\n\t      var _this4 = this;\n\t\n\t      // This trick overcomes iframe navigation in IE\n\t      // IE does not load the page consistently in iframe\n\t      this.info('LoadFrame: ' + frameName);\n\t      var frameCheck = frameName;\n\t      setTimeout(function () {\n\t        var frameHandle = _this4._addAuthFrame(frameCheck);\n\t        if (frameHandle.src === '' || frameHandle.src === 'about:blank') {\n\t          frameHandle.src = urlNavigate;\n\t          _this4._loadFrame(urlNavigate, frameCheck);\n\t        }\n\t      }, 500);\n\t    }\n\t\n\t    /**\n\t     * Acquire token from cache if not expired and available. Acquires token from iframe if expired.\n\t     * @param {string} resource  ResourceUri identifying the target resource\n\t     * @param {function} callback The callback function\n\t     */\n\t\n\t  }, {\n\t    key: 'acquireToken',\n\t    value: function acquireToken(resource, callback) {\n\t      if (this._isEmpty(resource)) {\n\t        this.warn('resource is required');\n\t        callback('resource is required', null);\n\t        return;\n\t      }\n\t\n\t      var token = this.getCachedToken(resource);\n\t      if (token) {\n\t        this.info('Token is already in cache for resource:' + resource);\n\t        callback(null, token);\n\t        return;\n\t      }\n\t\n\t      if (!this._user) {\n\t        this.warn('User login is required');\n\t        callback('User login is required', null);\n\t        return;\n\t      }\n\t\n\t      // refresh attept with iframe\n\t      // Already renewing for this resource, callback when we get the token.\n\t      if (this._activeRenewals[resource]) {\n\t        // Active renewals contains the state for each renewal.\n\t        this.registerCallback(this._activeRenewals[resource], resource, callback);\n\t      } else if (resource === this.config.clientId) {\n\t        // App uses idtoken to send to api endpoints\n\t        // Default resource is tracked as clientid to store this token\n\t        this.verbose('renewing idtoken');\n\t        this._renewIdToken(callback);\n\t      } else {\n\t        this._renewToken(resource, callback);\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Redirect the Browser to Azure AD Authorization endpoint\n\t     * @param {string} urlNavigate The authorization request url\n\t     */\n\t\n\t  }, {\n\t    key: 'promptUser',\n\t    value: function promptUser(urlNavigate) {\n\t      if (urlNavigate) {\n\t        this.info('Navigate to:' + urlNavigate);\n\t        this.navigate(urlNavigate);\n\t      } else {\n\t        this.info('Navigate url is empty');\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Clear cache items.\n\t     */\n\t\n\t  }, {\n\t    key: 'clearCache',\n\t    value: function clearCache() {\n\t      this._saveItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY, '');\n\t      this._saveItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY, 0);\n\t      this._saveItem(this.CONSTANTS.STORAGE.SESSION_STATE, '');\n\t      this._saveItem(this.CONSTANTS.STORAGE.STATE_LOGIN, '');\n\t      this._renewStates = [];\n\t      this._saveItem(this.CONSTANTS.STORAGE.USERNAME, '');\n\t      this._saveItem(this.CONSTANTS.STORAGE.IDTOKEN, '');\n\t      this._saveItem(this.CONSTANTS.STORAGE.ERROR, '');\n\t      this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, '');\n\t      var keys = this._getItem(this.CONSTANTS.STORAGE.TOKEN_KEYS);\n\t\n\t      if (!this._isEmpty(keys)) {\n\t        keys = keys.split(this.CONSTANTS.RESOURCE_DELIMETER);\n\t        for (var i = 0; i < keys.length; i++) {\n\t          this._saveItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY + keys[i], '');\n\t          this._saveItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY + keys[i], 0);\n\t        }\n\t      }\n\t      this._saveItem(this.CONSTANTS.STORAGE.TOKEN_KEYS, '');\n\t    }\n\t\n\t    /**\n\t     * Clear cache items for a resource.\n\t     * @param {string} resource The resource\n\t     */\n\t\n\t  }, {\n\t    key: 'clearCacheForResource',\n\t    value: function clearCacheForResource(resource) {\n\t      this._saveItem(this.CONSTANTS.STORAGE.STATE_RENEW, '');\n\t      this._saveItem(this.CONSTANTS.STORAGE.ERROR, '');\n\t      this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, '');\n\t      if (this._hasResource(resource)) {\n\t        this._saveItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY + resource, '');\n\t        this._saveItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY + resource, 0);\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Logout user will redirect page to logout endpoint.\n\t     * After logout, it will redirect to post_logout page if provided.\n\t     */\n\t\n\t  }, {\n\t    key: 'logOut',\n\t    value: function logOut() {\n\t      this.clearCache();\n\t      var logout = '';\n\t      this._user = null;\n\t\n\t      if (this.config.postLogoutRedirectUri) {\n\t        logout = 'post_logout_redirect_uri=' + encodeURIComponent(this.config.postLogoutRedirectUri);\n\t      }\n\t\n\t      var urlNavigate = this.config.url + 'logout?' + logout;\n\t      this.info('Logout navigate to: ' + urlNavigate);\n\t      this.promptUser(urlNavigate);\n\t    }\n\t  }, {\n\t    key: '_isEmpty',\n\t    value: function _isEmpty(str) {\n\t      return typeof str === 'undefined' || !str || str.length === 0;\n\t    }\n\t\n\t    /**\n\t     * Gets a user profile\n\t     * @param {requestCallback} callback The callback that handles the response.\n\t     */\n\t\n\t  }, {\n\t    key: 'getUser',\n\t    value: function getUser(callback) {\n\t      // IDToken is first call\n\t      if (typeof callback !== 'function') {\n\t        throw new Error('callback is not a function');\n\t      }\n\t\n\t      // user in memory\n\t      if (this._user) {\n\t        callback(null, this._user);\n\t        return;\n\t      }\n\t\n\t      // frame is used to get idtoken\n\t      var idtoken = this._getItem(this.CONSTANTS.STORAGE.IDTOKEN);\n\t      if (this._isEmpty(idtoken)) {\n\t        this.warn('User information is not available');\n\t        callback('User information is not available');\n\t      } else {\n\t        this.info('User exists in cache: ');\n\t        this._user = this._createUser(idtoken);\n\t        callback(null, this._user);\n\t      }\n\t    }\n\t  }, {\n\t    key: '_addHintParameters',\n\t    value: function _addHintParameters(urlNavigate) {\n\t      // include hint params only if upn is present\n\t      if (this._user && this._user.profile && this._user.profile.hasOwnProperty('upn')) {\n\t        // add login_hint\n\t        urlNavigate += '&login_hint=' + encodeURIComponent(this._user.profile.upn);\n\t\n\t        // don't add domain_hint twice if user provided it in the extraQueryParameter value\n\t        if (!this._urlContainsQueryStringParameter('domain_hint', urlNavigate) && this._user.profile.upn.indexOf('@') > -1) {\n\t          var parts = this._user.profile.upn.split('@');\n\t          // local part can include @ in quotes. Sending last part handles that.\n\t          urlNavigate += '&domain_hint=' + encodeURIComponent(parts[parts.length - 1]);\n\t        }\n\t      }\n\t\n\t      return urlNavigate;\n\t    }\n\t  }, {\n\t    key: '_createUser',\n\t    value: function _createUser(idToken) {\n\t      var user = null;\n\t      var parsedJson = this._extractIdToken(idToken);\n\t      if (parsedJson && parsedJson.hasOwnProperty('aud')) {\n\t        var audienceMatch = false;\n\t\n\t        if (Array.isArray(parsedJson.aud)) {\n\t          // If the ID Token contains multiple audiences then an azp claim must be present and equal to the client id.\n\t          if (parsedJson.hasOwnProperty('azp') && parsedJson.azp.toLowerCase() === this.config.clientId.toLowerCase()) {\n\t            for (var i = 0; i < parsedJson.aud.length; i++) {\n\t              if (parsedJson.aud[i].toLowerCase() === this.config.clientId.toLowerCase()) {\n\t                audienceMatch = true;\n\t                break;\n\t              }\n\t            }\n\t          }\n\t        } else {\n\t          audienceMatch = parsedJson.aud.toLowerCase() === this.config.clientId.toLowerCase();\n\t        }\n\t\n\t        if (audienceMatch) {\n\t          user = {\n\t            userName: '',\n\t            profile: parsedJson\n\t          };\n\t\n\t          if (parsedJson.hasOwnProperty('upn')) {\n\t            user.userName = parsedJson.upn;\n\t          } else if (parsedJson.hasOwnProperty('email')) {\n\t            user.userName = parsedJson.email;\n\t          } else if (parsedJson.hasOwnProperty('sub')) {\n\t            user.userName = parsedJson.sub;\n\t          }\n\t        } else {\n\t          this.warn('IdToken has invalid aud/azp field');\n\t        }\n\t      }\n\t\n\t      return user;\n\t    }\n\t  }, {\n\t    key: '_getHash',\n\t    value: function _getHash(hash) {\n\t      if (hash.indexOf('#/') > -1) {\n\t        hash = hash.substring(hash.indexOf('#/') + 2);\n\t      } else if (hash.indexOf('#') > -1) {\n\t        hash = hash.substring(1);\n\t      }\n\t\n\t      return hash;\n\t    }\n\t  }, {\n\t    key: '_getSearch',\n\t    value: function _getSearch(search) {\n\t      if (search.indexOf('?') > -1) {\n\t        search = search.substring(1);\n\t      }\n\t\n\t      return search;\n\t    }\n\t  }, {\n\t    key: '_getParameters',\n\t    value: function _getParameters(hash, search) {\n\t      var parameters = {};\n\t\n\t      if (hash) {\n\t        hash = this._getHash(hash);\n\t        parameters = this._deserialize(hash);\n\t      }\n\t\n\t      if (search) {\n\t        search = this._getSearch(search);\n\t        var searchParameters = this._deserialize(search);\n\t        parameters = this._extend(parameters, searchParameters);\n\t      }\n\t\n\t      return parameters;\n\t    }\n\t  }, {\n\t    key: '_extend',\n\t    value: function _extend(obj, src) {\n\t      for (var key in src) {\n\t        if (src.hasOwnProperty(key)) {\n\t          obj[key] = src[key];\n\t        }\n\t      }\n\t      return obj;\n\t    }\n\t\n\t    /**\n\t     * Checks if hash contains access token or id token or error_description\n\t     * @param {string} hash  -  Hash passed from redirect page\n\t     * @param {string} search  -  Search passed from redirect page\n\t     * @return {boolean} exists if all the parameters exist\n\t     */\n\t\n\t  }, {\n\t    key: 'isCallback',\n\t    value: function isCallback(hash, search) {\n\t      var parameters = this._getParameters(hash, search);\n\t\n\t      return parameters.hasOwnProperty(this.CONSTANTS.ERROR_DESCRIPTION) || parameters.hasOwnProperty(this.CONSTANTS.ACCESS_TOKEN) || parameters.hasOwnProperty(this.CONSTANTS.ID_TOKEN);\n\t    }\n\t\n\t    /**\n\t     * Gets login error\n\t     * @return {string} error message related to login\n\t     */\n\t\n\t  }, {\n\t    key: 'getLoginError',\n\t    value: function getLoginError() {\n\t      return this._getItem(this.CONSTANTS.STORAGE.LOGIN_ERROR);\n\t    }\n\t\n\t    /**\n\t     * Gets requestInfo from given hash.\n\t     * @param {string} hash  -  Hash passed from redirect page\n\t     * @param {string} search  -  Search passed from redirect page\n\t     * @return {string} error message related to login\n\t     */\n\t\n\t  }, {\n\t    key: 'getRequestInfo',\n\t    value: function getRequestInfo(hash, search) {\n\t      var parameters = this._getParameters(hash, search);\n\t      var requestInfo = {\n\t        valid: false,\n\t        parameters: {},\n\t        stateMatch: false,\n\t        stateResponse: '',\n\t        requestType: this.REQUEST_TYPE.UNKNOWN\n\t      };\n\t\n\t      if (parameters) {\n\t        requestInfo.parameters = parameters;\n\t        if (parameters.hasOwnProperty(this.CONSTANTS.ERROR_DESCRIPTION) || parameters.hasOwnProperty(this.CONSTANTS.ACCESS_TOKEN) || parameters.hasOwnProperty(this.CONSTANTS.ID_TOKEN)) {\n\t          requestInfo.valid = true;\n\t\n\t          // which call\n\t          var stateResponse = '';\n\t          if (parameters.hasOwnProperty('state')) {\n\t            this.verbose('State: ' + parameters.state);\n\t            stateResponse = parameters.state;\n\t          } else {\n\t            this.warn('No state returned');\n\t            return requestInfo;\n\t          }\n\t\n\t          requestInfo.stateResponse = stateResponse;\n\t\n\t          // async calls can fire iframe and login request at the same time if developer does not use the API as expected\n\t          // incoming callback needs to be looked up to find the request type\n\t          if (stateResponse === this._getItem(this.CONSTANTS.STORAGE.STATE_LOGIN)) {\n\t            requestInfo.requestType = this.REQUEST_TYPE.LOGIN;\n\t            requestInfo.stateMatch = true;\n\t            return requestInfo;\n\t          }\n\t\n\t          // external api requests may have many renewtoken requests for different resource\n\t          if (!requestInfo.stateMatch && window.parent && window.parent.AuthenticationContext) {\n\t            var statesInParentContext = window.parent.AuthenticationContext._renewStates;\n\t            for (var i = 0; i < statesInParentContext.length; i++) {\n\t              if (statesInParentContext[i] === requestInfo.stateResponse) {\n\t                requestInfo.requestType = this.REQUEST_TYPE.RENEW_TOKEN;\n\t                requestInfo.stateMatch = true;\n\t                break;\n\t              }\n\t            }\n\t          }\n\t        }\n\t      }\n\t\n\t      return requestInfo;\n\t    }\n\t  }, {\n\t    key: '_getResourceFromState',\n\t    value: function _getResourceFromState(state) {\n\t      if (state) {\n\t        var splitIndex = state.indexOf('|');\n\t        if (splitIndex > -1 && splitIndex + 1 < state.length) {\n\t          return state.substring(splitIndex + 1);\n\t        }\n\t      }\n\t\n\t      return '';\n\t    }\n\t\n\t    /**\n\t     * Saves token from hash that is received from redirect.\n\t     * @param {string} requestInfo Hash passed from redirect page\n\t     */\n\t\n\t  }, {\n\t    key: 'saveTokenFromHash',\n\t    value: function saveTokenFromHash(requestInfo) {\n\t      this.info('State status:' + requestInfo.stateMatch + '; Request type:' + requestInfo.requestType);\n\t      this._saveItem(this.CONSTANTS.STORAGE.ERROR, '');\n\t      this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, '');\n\t\n\t      var resource = this._getResourceFromState(requestInfo.stateResponse);\n\t\n\t      // Record error\n\t      if (requestInfo.parameters.hasOwnProperty(this.CONSTANTS.ERROR_DESCRIPTION)) {\n\t        this.info('Error :' + requestInfo.parameters.error + '; Error description:' + requestInfo.parameters[this.CONSTANTS.ERROR_DESCRIPTION]);\n\t        this._saveItem(this.CONSTANTS.STORAGE.ERROR, requestInfo.parameters.error);\n\t        this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, requestInfo.parameters[this.CONSTANTS.ERROR_DESCRIPTION]);\n\t\n\t        if (requestInfo.requestType === this.REQUEST_TYPE.LOGIN) {\n\t          this._loginInProgress = false;\n\t          this._saveItem(this.CONSTANTS.STORAGE.LOGIN_ERROR, requestInfo.parameters.error_description);\n\t        }\n\t      } else if (requestInfo.stateMatch) {\n\t        // record tokens to storage if exists\n\t        this.info('State is right');\n\t        if (requestInfo.parameters.hasOwnProperty(this.CONSTANTS.SESSION_STATE)) {\n\t          this._saveItem(this.CONSTANTS.STORAGE.SESSION_STATE, requestInfo.parameters[this.CONSTANTS.SESSION_STATE]);\n\t        }\n\t\n\t        var keys = void 0;\n\t\n\t        if (requestInfo.parameters.hasOwnProperty(this.CONSTANTS.ACCESS_TOKEN)) {\n\t          this.info('Fragment has access token');\n\t\n\t          if (!this._hasResource(resource)) {\n\t            keys = this._getItem(this.CONSTANTS.STORAGE.TOKEN_KEYS) || '';\n\t            this._saveItem(this.CONSTANTS.STORAGE.TOKEN_KEYS, keys + resource + this.CONSTANTS.RESOURCE_DELIMETER);\n\t          }\n\t          // save token with related resource\n\t          this._saveItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY + resource, requestInfo.parameters[this.CONSTANTS.ACCESS_TOKEN]);\n\t          this._saveItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY + resource, this._expiresIn(requestInfo.parameters[this.CONSTANTS.EXPIRES_IN]));\n\t        }\n\t\n\t        if (requestInfo.parameters.hasOwnProperty(this.CONSTANTS.ID_TOKEN)) {\n\t          this.info('Fragment has id token');\n\t          this._loginInProgress = false;\n\t\n\t          this._user = this._createUser(requestInfo.parameters[this.CONSTANTS.ID_TOKEN]);\n\t\n\t          if (this._user && this._user.profile) {\n\t            if (this._user.profile.nonce === this._getItem(this.CONSTANTS.STORAGE.NONCE_IDTOKEN)) {\n\t              this._saveItem(this.CONSTANTS.STORAGE.IDTOKEN, requestInfo.parameters[this.CONSTANTS.ID_TOKEN]);\n\t\n\t              // Save idtoken as access token for app itself\n\t              resource = this.config.loginResource ? this.config.loginResource : this.config.clientId;\n\t\n\t              if (!this._hasResource(resource)) {\n\t                keys = this._getItem(this.CONSTANTS.STORAGE.TOKEN_KEYS) || '';\n\t                this._saveItem(this.CONSTANTS.STORAGE.TOKEN_KEYS, keys + resource + this.CONSTANTS.RESOURCE_DELIMETER);\n\t              }\n\t              this._saveItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY + resource, requestInfo.parameters[this.CONSTANTS.ID_TOKEN]);\n\t              this._saveItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY + resource, this._user.profile.exp);\n\t            } else {\n\t              this._user = null;\n\t              this._saveItem(this.CONSTANTS.STORAGE.LOGIN_ERROR, 'Nonce is not same as ' + this._idTokenNonce);\n\t            }\n\t          } else {\n\t            this._saveItem(this.CONSTANTS.STORAGE.ERROR, 'invalid id_token');\n\t            this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, 'Invalid id_token. id_token: ' + requestInfo.parameters[this.CONSTANTS.ID_TOKEN]);\n\t          }\n\t        }\n\t      } else {\n\t        this._saveItem(this.CONSTANTS.STORAGE.ERROR, 'Invalid_state');\n\t        this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, 'Invalid_state. state: ' + requestInfo.stateResponse);\n\t      }\n\t      this._saveItem(this.CONSTANTS.STORAGE.RENEW_STATUS + resource, this.CONSTANTS.TOKEN_RENEW_STATUS_COMPLETED);\n\t    }\n\t\n\t    /**\n\t     * Gets resource for given endpoint if mapping is provided with config.\n\t     * @param {string} endpoint API endpoint\n\t     * @return {string} resource for this API endpoint\n\t     */\n\t\n\t  }, {\n\t    key: 'getResourceForEndpoint',\n\t    value: function getResourceForEndpoint(endpoint) {\n\t      if (this.config && this.config.securedEndpoints) {\n\t        for (var configEndpoint in this.config.securedEndpoints) {\n\t          // configEndpoint is like /api/Todo requested endpoint can be /api/Todo/1\n\t          if (endpoint.indexOf(configEndpoint) > -1) {\n\t            return this.config.securedEndpoints[configEndpoint];\n\t          }\n\t        }\n\t      }\n\t\n\t      // default resource will be clientid if nothing specified\n\t      // App will use idtoken for calls to itself\n\t      // check if it's staring from http or https, needs to match with app host\n\t      if (endpoint.indexOf('http://') > -1 || endpoint.indexOf('https://') > -1) {\n\t        if (this._getHostFromUri(endpoint) === this._getHostFromUri(this.config.redirectUri)) {\n\t          return this.config.loginResource;\n\t        }\n\t      } else {\n\t        // in angular level, the url for $http interceptor call could be relative url,\n\t        // if it's relative call, we'll treat it as app backend call.\n\t        // if user specified list of anonymous endpoints, no need to send token to these endpoints, return null.\n\t        if (this.config && this.config.anonymousEndpoints) {\n\t          for (var i = 0; i < this.config.anonymousEndpoints.length; i++) {\n\t            if (endpoint.indexOf(this.config.anonymousEndpoints[i]) > -1) {\n\t              return null;\n\t            }\n\t          }\n\t        }\n\t        // all other app's backend calls are secured.\n\t        return this.config.loginResource;\n\t      }\n\t\n\t      // if not the app's own backend or not a domain listed in the endpoints structure\n\t      return null;\n\t    }\n\t  }, {\n\t    key: '_getHostFromUri',\n\t    value: function _getHostFromUri(uri) {\n\t      // remove http:// or https:// from uri\n\t      var extractedUri = String(uri).replace(/^(https?:)\\/\\//, '');\n\t\n\t      extractedUri = extractedUri.split('/')[0];\n\t      return extractedUri;\n\t    }\n\t\n\t    /* exported  oauth2Callback */\n\t\n\t  }, {\n\t    key: 'handleWindowCallback',\n\t    value: function handleWindowCallback(hash, search) {\n\t      // This is for regular javascript usage for redirect handling\n\t      // need to make sure this is for callback\n\t      if (!hash) {\n\t        hash = window.location.hash;\n\t      }\n\t\n\t      if (!search) {\n\t        search = window.location.search;\n\t      }\n\t\n\t      if (this.isCallback(hash, search)) {\n\t        var requestInfo = this.getRequestInfo(hash, search);\n\t        this.info('Returned from redirect url');\n\t        this.saveTokenFromHash(requestInfo);\n\t        var callback = null;\n\t        if (requestInfo.requestType === this.REQUEST_TYPE.RENEW_TOKEN && this.isIframe()) {\n\t          // iframe call but same single page\n\t          this.verbose('Window is in iframe');\n\t          callback = window.parent.AuthenticationContext.callBackMappedToRenewStates[requestInfo.stateResponse];\n\t          if (callback) {\n\t            callback(this._getItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION), requestInfo.parameters[this.CONSTANTS.ACCESS_TOKEN] || requestInfo.parameters[this.CONSTANTS.ID_TOKEN]);\n\t          }\n\t          return;\n\t        } else if (requestInfo.requestType === this.REQUEST_TYPE.LOGIN) {\n\t          callback = this.callback;\n\t          if (callback) {\n\t            callback(this._getItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION), requestInfo.parameters[this.CONSTANTS.ID_TOKEN]);\n\t          }\n\t        }\n\t        // No need to redirect user in case of popup\n\t        if (!this.popUp) {\n\t          this.navigate(this._getItem(this.CONSTANTS.STORAGE.LOGIN_REQUEST));\n\t        }\n\t      }\n\t    }\n\t  }, {\n\t    key: '_getNavigateUrl',\n\t    value: function _getNavigateUrl(responseType, resource) {\n\t      var urlNavigate = this.config.url + 'authorize' + this._serialize(responseType, this.config, resource) + this._addLibMetadata();\n\t      if (this.config.scope) {\n\t        urlNavigate += '&scope=' + encodeURIComponent(this.config.scope);\n\t      }\n\t      this.info('Navigate url:' + urlNavigate);\n\t      return urlNavigate;\n\t    }\n\t  }, {\n\t    key: '_extractIdToken',\n\t    value: function _extractIdToken(encodedIdToken) {\n\t      // id token will be decoded to get the username\n\t      var decodedToken = this._decodeJwt(encodedIdToken);\n\t      if (!decodedToken) {\n\t        return null;\n\t      }\n\t\n\t      try {\n\t        var base64IdToken = decodedToken.JWSPayload;\n\t        var base64Decoded = this._base64DecodeStringUrlSafe(base64IdToken);\n\t        if (!base64Decoded) {\n\t          this.info('The returned id_token could not be base64 url safe decoded.');\n\t          return null;\n\t        }\n\t\n\t        return JSON.parse(base64Decoded);\n\t      } catch (err) {\n\t        this.error('The returned id_token could not be decoded', err);\n\t      }\n\t\n\t      return null;\n\t    }\n\t  }, {\n\t    key: '_base64DecodeStringUrlSafe',\n\t    value: function _base64DecodeStringUrlSafe(base64IdToken) {\n\t      base64IdToken = base64IdToken.replace(/-/g, '+').replace(/_/g, '/');\n\t      return decodeURIComponent(escape(window.atob(base64IdToken)));\n\t    }\n\t\n\t    // Auth.node js crack function\n\t\n\t  }, {\n\t    key: '_decodeJwt',\n\t    value: function _decodeJwt(jwtToken) {\n\t      if (this._isEmpty(jwtToken)) {\n\t        return null;\n\t      }\n\t\n\t      var idTokenPartsRegex = /^([^\\.\\s]*)\\.([^\\.\\s]+)\\.([^\\.\\s]*)$/;\n\t\n\t      var matches = idTokenPartsRegex.exec(jwtToken);\n\t      if (!matches || matches.length < 4) {\n\t        this.warn('The returned id_token is not parseable.');\n\t        return null;\n\t      }\n\t\n\t      var crackedToken = {\n\t        header: matches[1],\n\t        JWSPayload: matches[2],\n\t        JWSSig: matches[3]\n\t      };\n\t\n\t      return crackedToken;\n\t    }\n\t  }, {\n\t    key: '_convertUrlSafeToRegularBase64EncodedString',\n\t    value: function _convertUrlSafeToRegularBase64EncodedString(str) {\n\t      return str.replace('-', '+').replace('_', '/');\n\t    }\n\t  }, {\n\t    key: '_serialize',\n\t    value: function _serialize(responseType, obj, resource) {\n\t      var str = [];\n\t      if (obj !== null) {\n\t        str.push('?response_type=' + encodeURIComponent(responseType));\n\t        str.push('client_id=' + encodeURIComponent(obj.clientId));\n\t        if (resource) {\n\t          str.push('resource=' + encodeURIComponent(resource));\n\t        }\n\t\n\t        str.push('redirect_uri=' + encodeURIComponent(obj.redirectUri));\n\t        str.push('state=' + encodeURIComponent(obj.state));\n\t\n\t        if (obj.hasOwnProperty('slice')) {\n\t          str.push('slice=' + encodeURIComponent(obj.slice));\n\t        }\n\t\n\t        if (obj.hasOwnProperty('extraQueryParameter')) {\n\t          str.push(obj.extraQueryParameter);\n\t        }\n\t\n\t        var correlationId = obj.correlationId ? obj.correlationId : _uuid2.default.v4();\n\t        str.push('client-request-id=' + encodeURIComponent(correlationId));\n\t      }\n\t\n\t      return str.join('&');\n\t    }\n\t  }, {\n\t    key: '_deserialize',\n\t    value: function _deserialize(query) {\n\t      var pl = /\\+/g; // Regex for replacing addition symbol with a space\n\t      var search = /([^&=]+)=([^&]*)/g;\n\t      var decode = function decode(s) {\n\t        return decodeURIComponent(s.replace(pl, ' '));\n\t      };\n\t      var obj = {};\n\t      var match = search.exec(query);\n\t      while (match) {\n\t        obj[decode(match[1])] = decode(match[2]);\n\t        match = search.exec(query);\n\t      }\n\t\n\t      return obj;\n\t    }\n\t  }, {\n\t    key: '_decimalToHex',\n\t    value: function _decimalToHex(number) {\n\t      var hex = number.toString(16);\n\t      while (hex.length < 2) {\n\t        hex = '0' + hex;\n\t      }\n\t      return hex;\n\t    }\n\t  }, {\n\t    key: '_expiresIn',\n\t    value: function _expiresIn(expires) {\n\t      return this._now() + parseInt(expires, 10);\n\t    }\n\t  }, {\n\t    key: '_now',\n\t    value: function _now() {\n\t      return Math.round(new Date().getTime() / 1000.0);\n\t    }\n\t  }, {\n\t    key: '_addAuthFrame',\n\t    value: function _addAuthFrame(iframeId) {\n\t      if (typeof iframeId === 'undefined') {\n\t        return;\n\t      }\n\t\n\t      this.info('Add auth frame to document:' + iframeId);\n\t      var authFrame = document.getElementById(iframeId);\n\t\n\t      if (!authFrame) {\n\t        if (document.createElement && document.documentElement && (window.opera || window.navigator.userAgent.indexOf('MSIE 5.0') === -1)) {\n\t          var ifr = document.createElement('iframe');\n\t          ifr.setAttribute('id', iframeId);\n\t          ifr.style.visibility = 'hidden';\n\t          ifr.style.position = 'absolute';\n\t          ifr.style.width = ifr.style.height = ifr.borderWidth = '0px';\n\t\n\t          authFrame = document.getElementsByTagName('body')[0].appendChild(ifr);\n\t        } else if (document.body && document.body.insertAdjacentHTML) {\n\t          document.body.insertAdjacentHTML('beforeEnd', '<iframe name=\"' + iframeId + '\" id=\"' + iframeId + '\" style=\"display:none\"></iframe>');\n\t        }\n\t        if (window.frames && window.frames[iframeId]) {\n\t          authFrame = window.frames[iframeId];\n\t        }\n\t      }\n\t\n\t      return authFrame;\n\t    }\n\t  }, {\n\t    key: '_saveItem',\n\t    value: function _saveItem(key, obj) {\n\t      if (this.config && this.config.cacheLocation && this.config.cacheLocation === 'localStorage') {\n\t        if (!this._supportsLocalStorage()) {\n\t          this.info('Local storage is not supported');\n\t          return false;\n\t        }\n\t\n\t        localStorage.setItem(key, obj);\n\t\n\t        return true;\n\t      }\n\t\n\t      // Default as session storage\n\t      if (!this._supportsSessionStorage()) {\n\t        this.info('Session storage is not supported');\n\t        return false;\n\t      }\n\t\n\t      sessionStorage.setItem(key, obj);\n\t      return true;\n\t    }\n\t  }, {\n\t    key: '_getItem',\n\t    value: function _getItem(key) {\n\t      if (this.config && this.config.cacheLocation && this.config.cacheLocation === 'localStorage') {\n\t        if (!this._supportsLocalStorage()) {\n\t          this.info('Local storage is not supported');\n\t          return null;\n\t        }\n\t\n\t        return localStorage.getItem(key);\n\t      }\n\t\n\t      // Default as session storage\n\t      if (!this._supportsSessionStorage()) {\n\t        this.info('Session storage is not supported');\n\t        return null;\n\t      }\n\t\n\t      return sessionStorage.getItem(key);\n\t    }\n\t  }, {\n\t    key: '_supportsLocalStorage',\n\t    value: function _supportsLocalStorage() {\n\t      try {\n\t        return 'localStorage' in window && window.localStorage;\n\t      } catch (e) {\n\t        return false;\n\t      }\n\t    }\n\t  }, {\n\t    key: '_supportsSessionStorage',\n\t    value: function _supportsSessionStorage() {\n\t      try {\n\t        return 'sessionStorage' in window && window.sessionStorage;\n\t      } catch (e) {\n\t        return false;\n\t      }\n\t    }\n\t  }, {\n\t    key: '_cloneConfig',\n\t    value: function _cloneConfig(obj) {\n\t      if (obj === null || (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object') {\n\t        return obj;\n\t      }\n\t\n\t      var copy = {};\n\t      for (var attr in obj) {\n\t        if (obj.hasOwnProperty(attr)) {\n\t          copy[attr] = obj[attr];\n\t        }\n\t      }\n\t      return copy;\n\t    }\n\t  }, {\n\t    key: '_addLibMetadata',\n\t    value: function _addLibMetadata() {\n\t      // x-client-SKU\n\t      // x-client-Ver\n\t      return '&x-client-SKU=Js&x-client-Ver=' + this._libVersion();\n\t    }\n\t  }, {\n\t    key: 'log',\n\t    value: function log(level, message, error) {\n\t      if (level <= Logging.level) {\n\t        var timestamp = new Date().toUTCString();\n\t        var formattedMessage = '';\n\t\n\t        if (this.config.correlationId) {\n\t          formattedMessage = timestamp + ':' + this.config.correlationId + '-' + this._libVersion() + '-' + this.CONSTANTS.LEVEL_STRING_MAP[level] + ' ' + message;\n\t        } else {\n\t          formattedMessage = timestamp + ':' + this._libVersion() + '-' + this.CONSTANTS.LEVEL_STRING_MAP[level] + ' ' + message;\n\t        }\n\t\n\t        if (error) {\n\t          formattedMessage += '\\nstack:\\n' + error.stack;\n\t        }\n\t\n\t        Logging.log(formattedMessage);\n\t      }\n\t    }\n\t  }, {\n\t    key: 'error',\n\t    value: function error(message, _error) {\n\t      this.log(this.CONSTANTS.LOGGING_LEVEL.ERROR, message, _error);\n\t    }\n\t  }, {\n\t    key: 'warn',\n\t    value: function warn(message) {\n\t      this.log(this.CONSTANTS.LOGGING_LEVEL.WARN, message, null);\n\t    }\n\t  }, {\n\t    key: 'info',\n\t    value: function info(message) {\n\t      this.log(this.CONSTANTS.LOGGING_LEVEL.INFO, message, null);\n\t    }\n\t  }, {\n\t    key: 'verbose',\n\t    value: function verbose(message) {\n\t      this.log(this.CONSTANTS.LOGGING_LEVEL.VERBOSE, message, null);\n\t    }\n\t  }, {\n\t    key: 'navigate',\n\t    value: function navigate(url) {\n\t      window.location.replace(url);\n\t    }\n\t  }, {\n\t    key: 'isIframe',\n\t    value: function isIframe() {\n\t      return window.parent && window.parent !== window;\n\t    }\n\t  }, {\n\t    key: 'open',\n\t    value: function open(url, name, features) {\n\t      return window.open(url, name, features);\n\t    }\n\t  }, {\n\t    key: '_libVersion',\n\t    value: function _libVersion() {\n\t      return '1.0.12';\n\t    }\n\t  }]);\n\t\n\t  return AuthenticationContext;\n\t}();\n\t\n\texports.default = AuthenticationContext;\n\t\n\t\n\tglobal.Logging = {\n\t  level: 0,\n\t  log: function log(message) {}\n\t};\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {\n\tvar rng;\n\t\n\tvar crypto = global.crypto || global.msCrypto; // for IE 11\n\tif (crypto && crypto.getRandomValues) {\n\t  // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto\n\t  // Moderately fast, high quality\n\t  var _rnds8 = new Uint8Array(16);\n\t  rng = function whatwgRNG() {\n\t    crypto.getRandomValues(_rnds8);\n\t    return _rnds8;\n\t  };\n\t}\n\t\n\tif (!rng) {\n\t  // Math.random()-based (RNG)\n\t  //\n\t  // If all else fails, use Math.random().  It's fast, but is of unspecified\n\t  // quality.\n\t  var  _rnds = new Array(16);\n\t  rng = function() {\n\t    for (var i = 0, r; i < 16; i++) {\n\t      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n\t      _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n\t    }\n\t\n\t    return _rnds;\n\t  };\n\t}\n\t\n\tmodule.exports = rng;\n\t\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// Unique ID creation requires a high quality random # generator.  We feature\n\t// detect to determine the best RNG source, normalizing to a function that\n\t// returns 128-bits of randomness, since that's what's usually required\n\tvar _rng = __webpack_require__(1);\n\t\n\t// Maps for number <-> hex string conversion\n\tvar _byteToHex = [];\n\tvar _hexToByte = {};\n\tfor (var i = 0; i < 256; ++i) {\n\t  _byteToHex[i] = (i + 0x100).toString(16).substr(1);\n\t  _hexToByte[_byteToHex[i]] = i;\n\t}\n\t\n\tfunction buff_to_string(buf, offset) {\n\t  var i = offset || 0;\n\t  var bth = _byteToHex;\n\t  return  bth[buf[i++]] + bth[buf[i++]] +\n\t          bth[buf[i++]] + bth[buf[i++]] + '-' +\n\t          bth[buf[i++]] + bth[buf[i++]] + '-' +\n\t          bth[buf[i++]] + bth[buf[i++]] + '-' +\n\t          bth[buf[i++]] + bth[buf[i++]] + '-' +\n\t          bth[buf[i++]] + bth[buf[i++]] +\n\t          bth[buf[i++]] + bth[buf[i++]] +\n\t          bth[buf[i++]] + bth[buf[i++]];\n\t}\n\t\n\t// **`v1()` - Generate time-based UUID**\n\t//\n\t// Inspired by https://github.com/LiosK/UUID.js\n\t// and http://docs.python.org/library/uuid.html\n\t\n\t// random #'s we need to init node and clockseq\n\tvar _seedBytes = _rng();\n\t\n\t// Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n\tvar _nodeId = [\n\t  _seedBytes[0] | 0x01,\n\t  _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]\n\t];\n\t\n\t// Per 4.2.2, randomize (14 bit) clockseq\n\tvar _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;\n\t\n\t// Previous uuid creation time\n\tvar _lastMSecs = 0, _lastNSecs = 0;\n\t\n\t// See https://github.com/broofa/node-uuid for API details\n\tfunction v1(options, buf, offset) {\n\t  var i = buf && offset || 0;\n\t  var b = buf || [];\n\t\n\t  options = options || {};\n\t\n\t  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;\n\t\n\t  // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n\t  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n\t  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n\t  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n\t  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();\n\t\n\t  // Per 4.2.1.2, use count of uuid's generated during the current clock\n\t  // cycle to simulate higher resolution clock\n\t  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;\n\t\n\t  // Time since last uuid creation (in msecs)\n\t  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;\n\t\n\t  // Per 4.2.1.2, Bump clockseq on clock regression\n\t  if (dt < 0 && options.clockseq === undefined) {\n\t    clockseq = clockseq + 1 & 0x3fff;\n\t  }\n\t\n\t  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n\t  // time interval\n\t  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n\t    nsecs = 0;\n\t  }\n\t\n\t  // Per 4.2.1.2 Throw error if too many uuids are requested\n\t  if (nsecs >= 10000) {\n\t    throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n\t  }\n\t\n\t  _lastMSecs = msecs;\n\t  _lastNSecs = nsecs;\n\t  _clockseq = clockseq;\n\t\n\t  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n\t  msecs += 12219292800000;\n\t\n\t  // `time_low`\n\t  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n\t  b[i++] = tl >>> 24 & 0xff;\n\t  b[i++] = tl >>> 16 & 0xff;\n\t  b[i++] = tl >>> 8 & 0xff;\n\t  b[i++] = tl & 0xff;\n\t\n\t  // `time_mid`\n\t  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;\n\t  b[i++] = tmh >>> 8 & 0xff;\n\t  b[i++] = tmh & 0xff;\n\t\n\t  // `time_high_and_version`\n\t  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n\t  b[i++] = tmh >>> 16 & 0xff;\n\t\n\t  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n\t  b[i++] = clockseq >>> 8 | 0x80;\n\t\n\t  // `clock_seq_low`\n\t  b[i++] = clockseq & 0xff;\n\t\n\t  // `node`\n\t  var node = options.node || _nodeId;\n\t  for (var n = 0; n < 6; ++n) {\n\t    b[i + n] = node[n];\n\t  }\n\t\n\t  return buf ? buf : buff_to_string(b);\n\t}\n\t\n\t// **`v4()` - Generate random UUID**\n\t\n\t// See https://github.com/broofa/node-uuid for API details\n\tfunction v4(options, buf, offset) {\n\t  // Deprecated - 'format' argument, as supported in v1.2\n\t  var i = buf && offset || 0;\n\t\n\t  if (typeof(options) == 'string') {\n\t    buf = options == 'binary' ? new Array(16) : null;\n\t    options = null;\n\t  }\n\t  options = options || {};\n\t\n\t  var rnds = options.random || (options.rng || _rng)();\n\t\n\t  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\t  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n\t  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\t\n\t  // Copy bytes to buffer, if provided\n\t  if (buf) {\n\t    for (var ii = 0; ii < 16; ++ii) {\n\t      buf[i + ii] = rnds[ii];\n\t    }\n\t  }\n\t\n\t  return buf || buff_to_string(rnds);\n\t}\n\t\n\t// Export public API\n\tvar uuid = v4;\n\tuuid.v1 = v1;\n\tuuid.v4 = v4;\n\t\n\tmodule.exports = uuid;\n\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** salte-auth.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 90f988eb93128328e79e\n **/","/**\n * @public\n * @class Config\n * @property {string} url                 Required.  This is the base url for the identity provider's authorize endpoint; not including authorize.\n * @property {string} responseType        Optional; defaults to id_token.  OAuth 2.0 Response Type value that determines the authorization processing flow to be used, including what parameters are returned from the endpoints used.\n * @property {string} clientId            Required.  OAuth 2.0 Client Identifier valid at the Authorization Server.\n * @property {string} scope               Optional.  This may be used to define the specific authorization(s) being requested from the resource owner.\n * @property {string} redirectUri         Optional; defaults to current window location.  Redirection URI to which the response will be sent. This URI MUST exactly match one of the Redirection URI values for the Client pre-registered at the OpenID Provider.\n * @property {string} loginResource       Optional; defaults to clientId.\n * @property {object} securedEndpoints    Optional.  Object containing one or more named endpoints (e.g. { \"Endpoint\": \"ResourceId\" }).  This list is used to identify endpoints to which tokens should be attached.  If \"Endpoint\" exists anywhere within the endpoint being called then it is considered to be a match.  If the endpoint being called doesn't match then either no token will be passed or, if the endpoint's hostname matches the application hostname, then the id_token will be passed.\n * @property {Array} anonymousEndpoints   Optional.  Array containing one or more endpoints to which a token need not be attached.  If the endpoint specified exists anywhere within the endpoint being called then it is considered to be a match.\n * @property {boolean} isAngular          Optional.  Used to tell this library whether it should handle the callback from the authorization server itself or bubble the response up to the main window's URL and let the Angular http interceptor handle it.\n * @property {function} displayCall       Optional.  If specified then this function will be called with the fully-formed authorization url when login is invoked.\n * @property {boolean} popUp              Optional; defaults to true.\n * @property {function} callback          Optional.  If specified then this function will be called upon receiving a successful response or error from the authorization server.\n */\n\n/**\n * User information from idtoken.\n *  @class User\n *  @property {string} userName - username assigned from upn, email, or sub (i.e. subject).\n *  @property {object} profile - properties parsed from idtoken.\n */\n\nimport uuid from 'uuid';\n\nexport default class AuthenticationContext {\n  /**\n   * Creates a new AuthenticationContext object.\n   * @constructor\n   * @param {object}  config               Configuration options for AuthenticationContext\n   */\n  constructor(config) {\n    /**\n    * Enum for request type\n    * @enum {string}\n    */\n    this.REQUEST_TYPE = {\n      LOGIN: 'LOGIN',\n      RENEW_TOKEN: 'RENEW_TOKEN',\n      UNKNOWN: 'UNKNOWN'\n    };\n\n    /**\n    * Enum for storage constants\n    * @enum {string}\n    */\n    this.CONSTANTS = {\n      ACCESS_TOKEN: 'access_token',\n      EXPIRES_IN: 'expires_in',\n      ID_TOKEN: 'id_token',\n      ERROR_DESCRIPTION: 'error_description',\n      SESSION_STATE: 'session_state',\n      STORAGE: {\n        TOKEN_KEYS: 'auth.token.keys',\n        ACCESS_TOKEN_KEY: 'auth.access.token.key',\n        EXPIRATION_KEY: 'auth.expiration.key',\n        STATE_LOGIN: 'auth.state.login',\n        STATE_RENEW: 'auth.state.renew',\n        NONCE_IDTOKEN: 'auth.nonce.idtoken',\n        SESSION_STATE: 'auth.session.state',\n        USERNAME: 'auth.username',\n        IDTOKEN: 'auth.idtoken',\n        ERROR: 'auth.error',\n        ERROR_DESCRIPTION: 'auth.error.description',\n        LOGIN_REQUEST: 'auth.login.request',\n        LOGIN_ERROR: 'auth.login.error',\n        RENEW_STATUS: 'auth.token.renew.status'\n      },\n      RESOURCE_DELIMETER: '|',\n      LOADFRAME_TIMEOUT: '6000',\n      TOKEN_RENEW_STATUS_CANCELED: 'Canceled',\n      TOKEN_RENEW_STATUS_COMPLETED: 'Completed',\n      TOKEN_RENEW_STATUS_IN_PROGRESS: 'In Progress',\n      LOGGING_LEVEL: {\n        ERROR: 0,\n        WARN: 1,\n        INFO: 2,\n        VERBOSE: 3\n      },\n      LEVEL_STRING_MAP: {\n        0: 'ERROR:',\n        1: 'WARNING:',\n        2: 'INFO:',\n        3: 'VERBOSE:'\n      },\n      POPUP_WIDTH: 483,\n      POPUP_HEIGHT: 600\n    };\n\n    if (window.AuthenticationContext) {\n      return window.AuthenticationContext;\n    }\n    window.AuthenticationContext = this;\n\n    // public\n    this.config = {};\n    this.callback = null;\n    this.popUp = false;\n    this.isAngular = false;\n\n    // private\n    this._user = null;\n    this._activeRenewals = {};\n    this._loginInProgress = false;\n    this._renewStates = [];\n\n    this.callBackMappedToRenewStates = {};\n    this.callBacksMappedToRenewStates = {};\n\n    // validate before constructor assignments\n    if (config.displayCall && typeof config.displayCall !== 'function') {\n      throw new Error('displayCall is not a function');\n    }\n\n    if (!config.clientId) {\n      throw new Error('clientId is required');\n    }\n\n    this.config = this._cloneConfig(config);\n\n    if (this.config.popUp) {\n      this.popUp = true;\n    }\n\n    if (this.config.callback && typeof this.config.callback === 'function') {\n      this.callback = this.config.callback;\n    }\n\n    if (!this.config.url || !this.config.url.match(/^https:\\/\\/.*\\/$/)) {\n      throw new Error('url must be a valid https endpoint that ends in a forward slash.');\n    }\n\n    // App can request idtoken for itself using clientid as resource\n    if (!this.config.loginResource) {\n      this.config.loginResource = this.config.clientId;\n    }\n\n    if (!this.config.redirectUri) {\n      this.config.redirectUri = window.location.href;\n    }\n\n    if (!this.config.anonymousEndpoints) {\n      this.config.anonymousEndpoints = [];\n    }\n\n    if (this.config.isAngular) {\n      this.isAngular = this.config.isAngular;\n    }\n\n    this.setResponseType(this.config.responseType);\n  }\n\n  setResponseType(responseType) {\n    this.config.responseType = responseType || this.CONSTANTS.ID_TOKEN;\n  }\n\n  /**\n   * Gets initial Idtoken for the app backend\n   * Saves the resulting Idtoken in localStorage.\n   * @param {string} startPage the start page\n   */\n  login(startPage) {\n    // Token is not present and user needs to login\n    if (this._loginInProgress) {\n      this.info('Login in progress');\n      return;\n    }\n    const expectedState = uuid.v4();\n    this.config.state = expectedState;\n    this._idTokenNonce = uuid.v4();\n    if (!startPage) {\n      startPage = window.location;\n    }\n    this.verbose('Expected state: ' + expectedState + ' startPage:' + startPage);\n    this._saveItem(this.CONSTANTS.STORAGE.LOGIN_REQUEST, startPage);\n    this._saveItem(this.CONSTANTS.STORAGE.LOGIN_ERROR, '');\n    this._saveItem(this.CONSTANTS.STORAGE.STATE_LOGIN, expectedState);\n    this._saveItem(this.CONSTANTS.STORAGE.NONCE_IDTOKEN, this._idTokenNonce);\n    this._saveItem(this.CONSTANTS.STORAGE.ERROR, '');\n    this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, '');\n    const urlNavigate = this._getNavigateUrl(this.config.responseType, null) + '&nonce=' + encodeURIComponent(this._idTokenNonce);\n    this._loginInProgress = true;\n    if (this.popUp) {\n      this._loginPopup(urlNavigate);\n      return;\n    }\n    if (this.config.displayCall) {\n      // User defined way of handling the navigation\n      this.config.displayCall(urlNavigate);\n    } else {\n      this.promptUser(urlNavigate);\n    }\n  }\n\n  _openPopup(urlNavigate, title, popUpWidth, popUpHeight) {\n    try {\n      /**\n      * adding winLeft and winTop to account for dual monitor\n      * using screenLeft and screenTop for IE8 and earlier\n      */\n      const winLeft = window.screenLeft ? window.screenLeft : window.screenX;\n      const winTop = window.screenTop ? window.screenTop : window.screenY;\n      /**\n      * window.innerWidth displays browser window's height and width excluding toolbars\n      * using document.documentElement.clientWidth for IE8 and earlier\n      */\n      const width = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;\n      const height = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;\n      const left = ((width / 2) - (popUpWidth / 2)) + winLeft;\n      const top = ((height / 2) - (popUpHeight / 2)) + winTop;\n\n      const popupWindow = this.open(urlNavigate, title, 'width=' + popUpWidth + ', height=' + popUpHeight + ', top=' + top + ', left=' + left);\n      if (popupWindow.focus) {\n        popupWindow.focus();\n      }\n      return popupWindow;\n    } catch (e) {\n      this.warn('Error opening popup, ' + e.message);\n      this._loginInProgress = false;\n      return null;\n    }\n  }\n\n  _loginPopup(urlNavigate) {\n    const popupWindow = this._openPopup(urlNavigate, 'login', this.CONSTANTS.POPUP_WIDTH, this.CONSTANTS.POPUP_HEIGHT);\n    if (popupWindow === null) {\n      this.warn('Popup Window is null. This can happen if you are using IE');\n      this._saveItem(this.CONSTANTS.STORAGE.ERROR, 'Error opening popup');\n      this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, 'Popup Window is null. This can happen if you are using IE');\n      this._saveItem(this.CONSTANTS.STORAGE.LOGIN_ERROR, 'Popup Window is null. This can happen if you are using IE');\n      if (this.callback) {\n        this.callback(this._getItem(this.CONSTANTS.STORAGE.LOGIN_ERROR), null);\n      }\n      return;\n    }\n    let registeredRedirectUri;\n    if (this.config.redirectUri.indexOf('#') === -1) {\n      registeredRedirectUri = this.config.redirectUri;\n    } else {\n      registeredRedirectUri = this.config.redirectUri.split('#')[0];\n    }\n    const pollTimer = window.setInterval(() => {\n      if (!popupWindow || popupWindow.closed || popupWindow.closed === undefined) {\n        this._loginInProgress = false;\n        window.clearInterval(pollTimer);\n      }\n      try {\n        if (popupWindow.location.href.indexOf(registeredRedirectUri) !== -1) {\n          if (this.isAngular) {\n            window.location.hash = popupWindow.location.hash;\n          } else {\n            this.handleWindowCallback(popupWindow.location.hash, popupWindow.location.search);\n          }\n          window.clearInterval(pollTimer);\n          this._loginInProgress = false;\n          this.info('Closing popup window');\n          popupWindow.close();\n        }\n      } catch (e) {\n      }\n    }, 20);\n  }\n\n  loginInProgress() {\n    return this._loginInProgress;\n  }\n\n  _hasResource(key) {\n    const keys = this._getItem(this.CONSTANTS.STORAGE.TOKEN_KEYS);\n    return keys && !this._isEmpty(keys) && (keys.indexOf(key + this.CONSTANTS.RESOURCE_DELIMETER) > -1);\n  }\n\n  /**\n   * Gets token for the specified resource from local storage cache\n   * @param {string}   resource A URI that identifies the resource for which the token is valid.\n   * @return {string} token if exists and not expired or null\n   */\n  getCachedToken(resource) {\n    if (!this._hasResource(resource)) {\n      return null;\n    }\n\n    const token = this._getItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY + resource);\n    const expired = this._getItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY + resource);\n\n    // If expiration is within offset, it will force renew\n    const offset = this.config.expireOffsetSeconds || 120;\n\n    if (expired && (expired > this._now() + offset)) {\n      return token;\n    }\n    this._saveItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY + resource, '');\n    this._saveItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY + resource, 0);\n    return null;\n  }\n\n  /**\n   * Retrieves and parse idToken from localstorage\n   * @return {User} user object\n   */\n  getCachedUser() {\n    if (this._user) {\n      return this._user;\n    }\n\n    const idtoken = this._getItem(this.CONSTANTS.STORAGE.IDTOKEN);\n    this._user = this._createUser(idtoken);\n    return this._user;\n  }\n\n  registerCallback(expectedState, resource, callback) {\n    this._activeRenewals[resource] = expectedState;\n    if (!this.callBacksMappedToRenewStates[expectedState]) {\n      this.callBacksMappedToRenewStates[expectedState] = [];\n    }\n    this.callBacksMappedToRenewStates[expectedState].push(callback);\n    if (!this.callBackMappedToRenewStates[expectedState]) {\n      this.callBackMappedToRenewStates[expectedState] = (message, token) => {\n        for (let i = 0; i < this.callBacksMappedToRenewStates[expectedState].length; ++i) {\n          try {\n            this.callBacksMappedToRenewStates[expectedState][i](message, token);\n          } catch (error) {\n            this.warn(error);\n          }\n        }\n        this._activeRenewals[resource] = null;\n        this.callBacksMappedToRenewStates[expectedState] = null;\n        this.callBackMappedToRenewStates[expectedState] = null;\n      };\n    }\n  }\n\n  /**\n   * Acquires access token with hidden iframe\n   * @param {string} resource  ResourceUri identifying the target resource\n   * @param {string} callback  ResourceUri identifying the target resource\n   */\n  _renewToken(resource, callback) {\n    // use iframe to try refresh token\n    // use given resource to create new authz url\n    this.info('renewToken is called for resource:' + resource);\n    const frameHandle = this._addAuthFrame('authRenewFrame' + resource);\n    const expectedState = uuid.v4() + '|' + resource;\n    this.config.state = expectedState;\n    // renew happens in iframe, so it keeps javascript context\n    this._renewStates.push(expectedState);\n\n    this.verbose('Renew token Expected state: ' + expectedState);\n    let urlNavigate = this._getNavigateUrl('token', resource) + '&prompt=none';\n    urlNavigate = this._addHintParameters(urlNavigate);\n\n    this.registerCallback(expectedState, resource, callback);\n    this.verbose('Navigate to:' + urlNavigate);\n    this._saveItem(this.CONSTANTS.STORAGE.LOGIN_REQUEST, '');\n    frameHandle.src = 'about:blank';\n    this._loadFrameTimeout(urlNavigate, 'authRenewFrame' + resource, resource);\n  }\n\n  _renewIdToken(callback) {\n    // use iframe to try refresh token\n    this.info('renewIdToken is called');\n    const frameHandle = this._addAuthFrame('authIdTokenFrame');\n    const expectedState = uuid.v4() + '|' + this.config.clientId;\n    this._idTokenNonce = uuid.v4();\n    this._saveItem(this.CONSTANTS.STORAGE.NONCE_IDTOKEN, this._idTokenNonce);\n    this.config.state = expectedState;\n    // renew happens in iframe, so it keeps javascript context\n    this._renewStates.push(expectedState);\n\n    this.verbose('Renew Idtoken Expected state: ' + expectedState);\n    let urlNavigate = this._getNavigateUrl(this.config.responseType, null) + '&prompt=none';\n    urlNavigate = this._addHintParameters(urlNavigate);\n\n    urlNavigate += '&nonce=' + encodeURIComponent(this._idTokenNonce);\n    this.registerCallback(expectedState, this.config.clientId, callback);\n    this.idTokenNonce = null;\n    this.verbose('Navigate to:' + urlNavigate);\n    this._saveItem(this.CONSTANTS.STORAGE.LOGIN_REQUEST, '');\n    frameHandle.src = 'about:blank';\n    this._loadFrameTimeout(urlNavigate, 'authIdTokenFrame', this.config.clientId);\n  }\n\n  _urlContainsQueryStringParameter(name, url) {\n    // regex to detect pattern of a ? or & followed by the name parameter and an equals character\n    const regex = new RegExp('[\\\\?&]' + name + '=');\n    return regex.test(url);\n  }\n\n  // Calling _loadFrame but with a timeout to signal failure in loadframeStatus. Callbacks are left\n  // registered when network errors occur and subsequent token requests for same resource are registered to the pending request\n  _loadFrameTimeout(urlNavigation, frameName, resource) {\n    // set iframe session to pending\n    this.verbose('Set loading state to pending for: ' + resource);\n    this._saveItem(this.CONSTANTS.STORAGE.RENEW_STATUS + resource, this.CONSTANTS.TOKEN_RENEW_STATUS_IN_PROGRESS);\n    this._loadFrame(urlNavigation, frameName);\n    setTimeout(() => {\n      if (this._getItem(this.CONSTANTS.STORAGE.RENEW_STATUS + resource) === this.CONSTANTS.TOKEN_RENEW_STATUS_IN_PROGRESS) {\n        // fail the iframe session if it's in pending state\n        this.verbose('Loading frame has timed out after: ' + (this.CONSTANTS.LOADFRAME_TIMEOUT / 1000) + ' seconds for resource ' + resource);\n        const expectedState = this._activeRenewals[resource];\n\n        this._saveItem(this.CONSTANTS.STORAGE.RENEW_STATUS + resource, this.CONSTANTS.TOKEN_RENEW_STATUS_CANCELED);\n\n        if (expectedState && this.callBackMappedToRenewStates[expectedState]) {\n          this.callBackMappedToRenewStates[expectedState]('Token renewal operation failed due to timeout', null);\n        }\n      }\n    }, this.CONSTANTS.LOADFRAME_TIMEOUT);\n  }\n\n  _loadFrame(urlNavigate, frameName) {\n    // This trick overcomes iframe navigation in IE\n    // IE does not load the page consistently in iframe\n    this.info('LoadFrame: ' + frameName);\n    const frameCheck = frameName;\n    setTimeout(() => {\n      const frameHandle = this._addAuthFrame(frameCheck);\n      if (frameHandle.src === '' || frameHandle.src === 'about:blank') {\n        frameHandle.src = urlNavigate;\n        this._loadFrame(urlNavigate, frameCheck);\n      }\n    }, 500);\n  }\n\n  /**\n   * Acquire token from cache if not expired and available. Acquires token from iframe if expired.\n   * @param {string} resource  ResourceUri identifying the target resource\n   * @param {function} callback The callback function\n   */\n  acquireToken(resource, callback) {\n    if (this._isEmpty(resource)) {\n      this.warn('resource is required');\n      callback('resource is required', null);\n      return;\n    }\n\n    const token = this.getCachedToken(resource);\n    if (token) {\n      this.info('Token is already in cache for resource:' + resource);\n      callback(null, token);\n      return;\n    }\n\n    if (!this._user) {\n      this.warn('User login is required');\n      callback('User login is required', null);\n      return;\n    }\n\n    // refresh attept with iframe\n    // Already renewing for this resource, callback when we get the token.\n    if (this._activeRenewals[resource]) {\n      // Active renewals contains the state for each renewal.\n      this.registerCallback(this._activeRenewals[resource], resource, callback);\n    } else if (resource === this.config.clientId) {\n      // App uses idtoken to send to api endpoints\n      // Default resource is tracked as clientid to store this token\n      this.verbose('renewing idtoken');\n      this._renewIdToken(callback);\n    } else {\n      this._renewToken(resource, callback);\n    }\n  }\n\n  /**\n   * Redirect the Browser to Azure AD Authorization endpoint\n   * @param {string} urlNavigate The authorization request url\n   */\n  promptUser(urlNavigate) {\n    if (urlNavigate) {\n      this.info('Navigate to:' + urlNavigate);\n      this.navigate(urlNavigate);\n    } else {\n      this.info('Navigate url is empty');\n    }\n  }\n\n  /**\n   * Clear cache items.\n   */\n  clearCache() {\n    this._saveItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY, '');\n    this._saveItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY, 0);\n    this._saveItem(this.CONSTANTS.STORAGE.SESSION_STATE, '');\n    this._saveItem(this.CONSTANTS.STORAGE.STATE_LOGIN, '');\n    this._renewStates = [];\n    this._saveItem(this.CONSTANTS.STORAGE.USERNAME, '');\n    this._saveItem(this.CONSTANTS.STORAGE.IDTOKEN, '');\n    this._saveItem(this.CONSTANTS.STORAGE.ERROR, '');\n    this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, '');\n    let keys = this._getItem(this.CONSTANTS.STORAGE.TOKEN_KEYS);\n\n    if (!this._isEmpty(keys)) {\n      keys = keys.split(this.CONSTANTS.RESOURCE_DELIMETER);\n      for (let i = 0; i < keys.length; i++) {\n        this._saveItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY + keys[i], '');\n        this._saveItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY + keys[i], 0);\n      }\n    }\n    this._saveItem(this.CONSTANTS.STORAGE.TOKEN_KEYS, '');\n  }\n\n  /**\n   * Clear cache items for a resource.\n   * @param {string} resource The resource\n   */\n  clearCacheForResource(resource) {\n    this._saveItem(this.CONSTANTS.STORAGE.STATE_RENEW, '');\n    this._saveItem(this.CONSTANTS.STORAGE.ERROR, '');\n    this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, '');\n    if (this._hasResource(resource)) {\n      this._saveItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY + resource, '');\n      this._saveItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY + resource, 0);\n    }\n  }\n\n  /**\n   * Logout user will redirect page to logout endpoint.\n   * After logout, it will redirect to post_logout page if provided.\n   */\n  logOut() {\n    this.clearCache();\n    let logout = '';\n    this._user = null;\n\n    if (this.config.postLogoutRedirectUri) {\n      logout = 'post_logout_redirect_uri=' + encodeURIComponent(this.config.postLogoutRedirectUri);\n    }\n\n    const urlNavigate = this.config.url + 'logout?' + logout;\n    this.info('Logout navigate to: ' + urlNavigate);\n    this.promptUser(urlNavigate);\n  }\n\n  _isEmpty(str) {\n    return (typeof str === 'undefined' || !str || str.length === 0);\n  }\n\n  /**\n   * Gets a user profile\n   * @param {requestCallback} callback The callback that handles the response.\n   */\n  getUser(callback) {\n    // IDToken is first call\n    if (typeof callback !== 'function') {\n      throw new Error('callback is not a function');\n    }\n\n    // user in memory\n    if (this._user) {\n      callback(null, this._user);\n      return;\n    }\n\n    // frame is used to get idtoken\n    const idtoken = this._getItem(this.CONSTANTS.STORAGE.IDTOKEN);\n    if (this._isEmpty(idtoken)) {\n      this.warn('User information is not available');\n      callback('User information is not available');\n    } else {\n      this.info('User exists in cache: ');\n      this._user = this._createUser(idtoken);\n      callback(null, this._user);\n    }\n  }\n\n  _addHintParameters(urlNavigate) {\n    // include hint params only if upn is present\n    if (this._user && this._user.profile && this._user.profile.hasOwnProperty('upn')) {\n      // add login_hint\n      urlNavigate += '&login_hint=' + encodeURIComponent(this._user.profile.upn);\n\n      // don't add domain_hint twice if user provided it in the extraQueryParameter value\n      if (!this._urlContainsQueryStringParameter('domain_hint', urlNavigate) && this._user.profile.upn.indexOf('@') > -1) {\n        const parts = this._user.profile.upn.split('@');\n        // local part can include @ in quotes. Sending last part handles that.\n        urlNavigate += '&domain_hint=' + encodeURIComponent(parts[parts.length - 1]);\n      }\n    }\n\n    return urlNavigate;\n  }\n\n  _createUser(idToken) {\n    let user = null;\n    const parsedJson = this._extractIdToken(idToken);\n    if (parsedJson && parsedJson.hasOwnProperty('aud')) {\n      let audienceMatch = false;\n\n      if (Array.isArray(parsedJson.aud)) {\n        // If the ID Token contains multiple audiences then an azp claim must be present and equal to the client id.\n        if (parsedJson.hasOwnProperty('azp') && parsedJson.azp.toLowerCase() === this.config.clientId.toLowerCase()) {\n          for (let i = 0; i < parsedJson.aud.length; i++) {\n            if (parsedJson.aud[i].toLowerCase() === this.config.clientId.toLowerCase()) {\n              audienceMatch = true;\n              break;\n            }\n          }\n        }\n      } else {\n        audienceMatch = (parsedJson.aud.toLowerCase() === this.config.clientId.toLowerCase());\n      }\n\n      if (audienceMatch) {\n        user = {\n          userName: '',\n          profile: parsedJson\n        };\n\n        if (parsedJson.hasOwnProperty('upn')) {\n          user.userName = parsedJson.upn;\n        } else if (parsedJson.hasOwnProperty('email')) {\n          user.userName = parsedJson.email;\n        } else if (parsedJson.hasOwnProperty('sub')) {\n          user.userName = parsedJson.sub;\n        }\n      } else {\n        this.warn('IdToken has invalid aud/azp field');\n      }\n    }\n\n    return user;\n  }\n\n  _getHash(hash) {\n    if (hash.indexOf('#/') > -1) {\n      hash = hash.substring(hash.indexOf('#/') + 2);\n    } else if (hash.indexOf('#') > -1) {\n      hash = hash.substring(1);\n    }\n\n    return hash;\n  }\n\n  _getSearch(search) {\n    if (search.indexOf('?') > -1) {\n      search = search.substring(1);\n    }\n\n    return search;\n  }\n\n  _getParameters(hash, search) {\n    let parameters = {};\n\n    if (hash) {\n      hash = this._getHash(hash);\n      parameters = this._deserialize(hash);\n    }\n\n    if (search) {\n      search = this._getSearch(search);\n      const searchParameters = this._deserialize(search);\n      parameters = this._extend(parameters, searchParameters);\n    }\n\n    return parameters;\n  }\n\n  _extend(obj, src) {\n    for (const key in src) {\n      if (src.hasOwnProperty(key)) {\n        obj[key] = src[key];\n      }\n    }\n    return obj;\n  }\n\n  /**\n   * Checks if hash contains access token or id token or error_description\n   * @param {string} hash  -  Hash passed from redirect page\n   * @param {string} search  -  Search passed from redirect page\n   * @return {boolean} exists if all the parameters exist\n   */\n  isCallback(hash, search) {\n    const parameters = this._getParameters(hash, search);\n\n    return parameters.hasOwnProperty(this.CONSTANTS.ERROR_DESCRIPTION) ||\n      parameters.hasOwnProperty(this.CONSTANTS.ACCESS_TOKEN) ||\n      parameters.hasOwnProperty(this.CONSTANTS.ID_TOKEN);\n  }\n\n  /**\n   * Gets login error\n   * @return {string} error message related to login\n   */\n  getLoginError() {\n    return this._getItem(this.CONSTANTS.STORAGE.LOGIN_ERROR);\n  }\n\n  /**\n   * Gets requestInfo from given hash.\n   * @param {string} hash  -  Hash passed from redirect page\n   * @param {string} search  -  Search passed from redirect page\n   * @return {string} error message related to login\n   */\n  getRequestInfo(hash, search) {\n    const parameters = this._getParameters(hash, search);\n    const requestInfo = {\n      valid: false,\n      parameters: {},\n      stateMatch: false,\n      stateResponse: '',\n      requestType: this.REQUEST_TYPE.UNKNOWN\n    };\n\n    if (parameters) {\n      requestInfo.parameters = parameters;\n      if (parameters.hasOwnProperty(this.CONSTANTS.ERROR_DESCRIPTION) ||\n        parameters.hasOwnProperty(this.CONSTANTS.ACCESS_TOKEN) ||\n        parameters.hasOwnProperty(this.CONSTANTS.ID_TOKEN)) {\n        requestInfo.valid = true;\n\n        // which call\n        let stateResponse = '';\n        if (parameters.hasOwnProperty('state')) {\n          this.verbose('State: ' + parameters.state);\n          stateResponse = parameters.state;\n        } else {\n          this.warn('No state returned');\n          return requestInfo;\n        }\n\n        requestInfo.stateResponse = stateResponse;\n\n        // async calls can fire iframe and login request at the same time if developer does not use the API as expected\n        // incoming callback needs to be looked up to find the request type\n        if (stateResponse === this._getItem(this.CONSTANTS.STORAGE.STATE_LOGIN)) {\n          requestInfo.requestType = this.REQUEST_TYPE.LOGIN;\n          requestInfo.stateMatch = true;\n          return requestInfo;\n        }\n\n        // external api requests may have many renewtoken requests for different resource\n        if (!requestInfo.stateMatch && window.parent && window.parent.AuthenticationContext) {\n          const statesInParentContext = window.parent.AuthenticationContext._renewStates;\n          for (let i = 0; i < statesInParentContext.length; i++) {\n            if (statesInParentContext[i] === requestInfo.stateResponse) {\n              requestInfo.requestType = this.REQUEST_TYPE.RENEW_TOKEN;\n              requestInfo.stateMatch = true;\n              break;\n            }\n          }\n        }\n      }\n    }\n\n    return requestInfo;\n  }\n\n  _getResourceFromState(state) {\n    if (state) {\n      const splitIndex = state.indexOf('|');\n      if (splitIndex > -1 && splitIndex + 1 < state.length) {\n        return state.substring(splitIndex + 1);\n      }\n    }\n\n    return '';\n  }\n\n  /**\n   * Saves token from hash that is received from redirect.\n   * @param {string} requestInfo Hash passed from redirect page\n   */\n  saveTokenFromHash(requestInfo) {\n    this.info('State status:' + requestInfo.stateMatch + '; Request type:' + requestInfo.requestType);\n    this._saveItem(this.CONSTANTS.STORAGE.ERROR, '');\n    this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, '');\n\n    let resource = this._getResourceFromState(requestInfo.stateResponse);\n\n    // Record error\n    if (requestInfo.parameters.hasOwnProperty(this.CONSTANTS.ERROR_DESCRIPTION)) {\n      this.info('Error :' + requestInfo.parameters.error + '; Error description:' + requestInfo.parameters[this.CONSTANTS.ERROR_DESCRIPTION]);\n      this._saveItem(this.CONSTANTS.STORAGE.ERROR, requestInfo.parameters.error);\n      this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, requestInfo.parameters[this.CONSTANTS.ERROR_DESCRIPTION]);\n\n      if (requestInfo.requestType === this.REQUEST_TYPE.LOGIN) {\n        this._loginInProgress = false;\n        this._saveItem(this.CONSTANTS.STORAGE.LOGIN_ERROR, requestInfo.parameters.error_description);\n      }\n    } else if (requestInfo.stateMatch) {\n      // record tokens to storage if exists\n      this.info('State is right');\n      if (requestInfo.parameters.hasOwnProperty(this.CONSTANTS.SESSION_STATE)) {\n        this._saveItem(this.CONSTANTS.STORAGE.SESSION_STATE, requestInfo.parameters[this.CONSTANTS.SESSION_STATE]);\n      }\n\n      let keys;\n\n      if (requestInfo.parameters.hasOwnProperty(this.CONSTANTS.ACCESS_TOKEN)) {\n        this.info('Fragment has access token');\n\n        if (!this._hasResource(resource)) {\n          keys = this._getItem(this.CONSTANTS.STORAGE.TOKEN_KEYS) || '';\n          this._saveItem(this.CONSTANTS.STORAGE.TOKEN_KEYS, keys + resource + this.CONSTANTS.RESOURCE_DELIMETER);\n        }\n        // save token with related resource\n        this._saveItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY + resource, requestInfo.parameters[this.CONSTANTS.ACCESS_TOKEN]);\n        this._saveItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY + resource, this._expiresIn(requestInfo.parameters[this.CONSTANTS.EXPIRES_IN]));\n      }\n\n      if (requestInfo.parameters.hasOwnProperty(this.CONSTANTS.ID_TOKEN)) {\n        this.info('Fragment has id token');\n        this._loginInProgress = false;\n\n        this._user = this._createUser(requestInfo.parameters[this.CONSTANTS.ID_TOKEN]);\n\n        if (this._user && this._user.profile) {\n          if (this._user.profile.nonce === this._getItem(this.CONSTANTS.STORAGE.NONCE_IDTOKEN)) {\n            this._saveItem(this.CONSTANTS.STORAGE.IDTOKEN, requestInfo.parameters[this.CONSTANTS.ID_TOKEN]);\n\n            // Save idtoken as access token for app itself\n            resource = this.config.loginResource ? this.config.loginResource : this.config.clientId;\n\n            if (!this._hasResource(resource)) {\n              keys = this._getItem(this.CONSTANTS.STORAGE.TOKEN_KEYS) || '';\n              this._saveItem(this.CONSTANTS.STORAGE.TOKEN_KEYS, keys + resource + this.CONSTANTS.RESOURCE_DELIMETER);\n            }\n            this._saveItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY + resource, requestInfo.parameters[this.CONSTANTS.ID_TOKEN]);\n            this._saveItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY + resource, this._user.profile.exp);\n          } else {\n            this._user = null;\n            this._saveItem(this.CONSTANTS.STORAGE.LOGIN_ERROR, 'Nonce is not same as ' + this._idTokenNonce);\n          }\n        } else {\n          this._saveItem(this.CONSTANTS.STORAGE.ERROR, 'invalid id_token');\n          this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, 'Invalid id_token. id_token: ' + requestInfo.parameters[this.CONSTANTS.ID_TOKEN]);\n        }\n      }\n    } else {\n      this._saveItem(this.CONSTANTS.STORAGE.ERROR, 'Invalid_state');\n      this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, 'Invalid_state. state: ' + requestInfo.stateResponse);\n    }\n    this._saveItem(this.CONSTANTS.STORAGE.RENEW_STATUS + resource, this.CONSTANTS.TOKEN_RENEW_STATUS_COMPLETED);\n  }\n\n  /**\n   * Gets resource for given endpoint if mapping is provided with config.\n   * @param {string} endpoint API endpoint\n   * @return {string} resource for this API endpoint\n   */\n  getResourceForEndpoint(endpoint) {\n    if (this.config && this.config.securedEndpoints) {\n      for (const configEndpoint in this.config.securedEndpoints) {\n        // configEndpoint is like /api/Todo requested endpoint can be /api/Todo/1\n        if (endpoint.indexOf(configEndpoint) > -1) {\n          return this.config.securedEndpoints[configEndpoint];\n        }\n      }\n    }\n\n    // default resource will be clientid if nothing specified\n    // App will use idtoken for calls to itself\n    // check if it's staring from http or https, needs to match with app host\n    if (endpoint.indexOf('http://') > -1 || endpoint.indexOf('https://') > -1) {\n      if (this._getHostFromUri(endpoint) === this._getHostFromUri(this.config.redirectUri)) {\n        return this.config.loginResource;\n      }\n    } else {\n      // in angular level, the url for $http interceptor call could be relative url,\n      // if it's relative call, we'll treat it as app backend call.\n      // if user specified list of anonymous endpoints, no need to send token to these endpoints, return null.\n      if (this.config && this.config.anonymousEndpoints) {\n        for (let i = 0; i < this.config.anonymousEndpoints.length; i++) {\n          if (endpoint.indexOf(this.config.anonymousEndpoints[i]) > -1) {\n            return null;\n          }\n        }\n      }\n      // all other app's backend calls are secured.\n      return this.config.loginResource;\n    }\n\n    // if not the app's own backend or not a domain listed in the endpoints structure\n    return null;\n  }\n\n  _getHostFromUri(uri) {\n    // remove http:// or https:// from uri\n    let extractedUri = String(uri).replace(/^(https?:)\\/\\//, '');\n\n    extractedUri = extractedUri.split('/')[0];\n    return extractedUri;\n  }\n\n  /* exported  oauth2Callback */\n  handleWindowCallback(hash, search) {\n    // This is for regular javascript usage for redirect handling\n    // need to make sure this is for callback\n    if (!hash) {\n      hash = window.location.hash;\n    }\n\n    if (!search) {\n      search = window.location.search;\n    }\n\n    if (this.isCallback(hash, search)) {\n      const requestInfo = this.getRequestInfo(hash, search);\n      this.info('Returned from redirect url');\n      this.saveTokenFromHash(requestInfo);\n      let callback = null;\n      if ((requestInfo.requestType === this.REQUEST_TYPE.RENEW_TOKEN) && this.isIframe()) {\n        // iframe call but same single page\n        this.verbose('Window is in iframe');\n        callback = window.parent.AuthenticationContext.callBackMappedToRenewStates[requestInfo.stateResponse];\n        if (callback) {\n          callback(this._getItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION), requestInfo.parameters[this.CONSTANTS.ACCESS_TOKEN] || requestInfo.parameters[this.CONSTANTS.ID_TOKEN]);\n        }\n        return;\n      } else if (requestInfo.requestType === this.REQUEST_TYPE.LOGIN) {\n        callback = this.callback;\n        if (callback) {\n          callback(this._getItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION), requestInfo.parameters[this.CONSTANTS.ID_TOKEN]);\n        }\n      }\n      // No need to redirect user in case of popup\n      if (!this.popUp) {\n        this.navigate(this._getItem(this.CONSTANTS.STORAGE.LOGIN_REQUEST));\n      }\n    }\n  }\n\n  _getNavigateUrl(responseType, resource) {\n    let urlNavigate = this.config.url + 'authorize' + this._serialize(responseType, this.config, resource) + this._addLibMetadata();\n    if (this.config.scope) {\n      urlNavigate += '&scope=' + encodeURIComponent(this.config.scope);\n    }\n    this.info('Navigate url:' + urlNavigate);\n    return urlNavigate;\n  }\n\n  _extractIdToken(encodedIdToken) {\n    // id token will be decoded to get the username\n    const decodedToken = this._decodeJwt(encodedIdToken);\n    if (!decodedToken) {\n      return null;\n    }\n\n    try {\n      const base64IdToken = decodedToken.JWSPayload;\n      const base64Decoded = this._base64DecodeStringUrlSafe(base64IdToken);\n      if (!base64Decoded) {\n        this.info('The returned id_token could not be base64 url safe decoded.');\n        return null;\n      }\n\n      return JSON.parse(base64Decoded);\n    } catch (err) {\n      this.error('The returned id_token could not be decoded', err);\n    }\n\n    return null;\n  }\n\n  _base64DecodeStringUrlSafe(base64IdToken) {\n    base64IdToken = base64IdToken.replace(/-/g, '+').replace(/_/g, '/');\n    return decodeURIComponent(escape(window.atob(base64IdToken)));\n  }\n\n    // Auth.node js crack function\n  _decodeJwt(jwtToken) {\n    if (this._isEmpty(jwtToken)) {\n      return null;\n    }\n\n    const idTokenPartsRegex = /^([^\\.\\s]*)\\.([^\\.\\s]+)\\.([^\\.\\s]*)$/;\n\n    const matches = idTokenPartsRegex.exec(jwtToken);\n    if (!matches || matches.length < 4) {\n      this.warn('The returned id_token is not parseable.');\n      return null;\n    }\n\n    const crackedToken = {\n      header: matches[1],\n      JWSPayload: matches[2],\n      JWSSig: matches[3]\n    };\n\n    return crackedToken;\n  }\n\n  _convertUrlSafeToRegularBase64EncodedString(str) {\n    return str.replace('-', '+').replace('_', '/');\n  }\n\n  _serialize(responseType, obj, resource) {\n    const str = [];\n    if (obj !== null) {\n      str.push('?response_type=' + encodeURIComponent(responseType));\n      str.push('client_id=' + encodeURIComponent(obj.clientId));\n      if (resource) {\n        str.push('resource=' + encodeURIComponent(resource));\n      }\n\n      str.push('redirect_uri=' + encodeURIComponent(obj.redirectUri));\n      str.push('state=' + encodeURIComponent(obj.state));\n\n      if (obj.hasOwnProperty('slice')) {\n        str.push('slice=' + encodeURIComponent(obj.slice));\n      }\n\n      if (obj.hasOwnProperty('extraQueryParameter')) {\n        str.push(obj.extraQueryParameter);\n      }\n\n      const correlationId = obj.correlationId ? obj.correlationId : uuid.v4();\n      str.push('client-request-id=' + encodeURIComponent(correlationId));\n    }\n\n    return str.join('&');\n  }\n\n  _deserialize(query) {\n    const pl = /\\+/g; // Regex for replacing addition symbol with a space\n    const search = /([^&=]+)=([^&]*)/g;\n    const decode = (s) => {\n      return decodeURIComponent(s.replace(pl, ' '));\n    };\n    const obj = {};\n    let match = search.exec(query);\n    while (match) {\n      obj[decode(match[1])] = decode(match[2]);\n      match = search.exec(query);\n    }\n\n    return obj;\n  }\n\n  _decimalToHex(number) {\n    let hex = number.toString(16);\n    while (hex.length < 2) {\n      hex = '0' + hex;\n    }\n    return hex;\n  }\n\n  _expiresIn(expires) {\n    return this._now() + parseInt(expires, 10);\n  }\n\n  _now() {\n    return Math.round(new Date().getTime() / 1000.0);\n  }\n\n  _addAuthFrame(iframeId) {\n    if (typeof iframeId === 'undefined') {\n      return;\n    }\n\n    this.info('Add auth frame to document:' + iframeId);\n    let authFrame = document.getElementById(iframeId);\n\n    if (!authFrame) {\n      if (document.createElement && document.documentElement &&\n                (window.opera || window.navigator.userAgent.indexOf('MSIE 5.0') === -1)) {\n        const ifr = document.createElement('iframe');\n        ifr.setAttribute('id', iframeId);\n        ifr.style.visibility = 'hidden';\n        ifr.style.position = 'absolute';\n        ifr.style.width = ifr.style.height = ifr.borderWidth = '0px';\n\n        authFrame = document.getElementsByTagName('body')[0].appendChild(ifr);\n      } else if (document.body && document.body.insertAdjacentHTML) {\n        document.body.insertAdjacentHTML('beforeEnd', '<iframe name=\"' + iframeId + '\" id=\"' + iframeId + '\" style=\"display:none\"></iframe>');\n      }\n      if (window.frames && window.frames[iframeId]) {\n        authFrame = window.frames[iframeId];\n      }\n    }\n\n    return authFrame;\n  }\n\n  _saveItem(key, obj) {\n    if (this.config && this.config.cacheLocation && this.config.cacheLocation === 'localStorage') {\n      if (!this._supportsLocalStorage()) {\n        this.info('Local storage is not supported');\n        return false;\n      }\n\n      localStorage.setItem(key, obj);\n\n      return true;\n    }\n\n    // Default as session storage\n    if (!this._supportsSessionStorage()) {\n      this.info('Session storage is not supported');\n      return false;\n    }\n\n    sessionStorage.setItem(key, obj);\n    return true;\n  }\n\n  _getItem(key) {\n    if (this.config && this.config.cacheLocation && this.config.cacheLocation === 'localStorage') {\n      if (!this._supportsLocalStorage()) {\n        this.info('Local storage is not supported');\n        return null;\n      }\n\n      return localStorage.getItem(key);\n    }\n\n    // Default as session storage\n    if (!this._supportsSessionStorage()) {\n      this.info('Session storage is not supported');\n      return null;\n    }\n\n    return sessionStorage.getItem(key);\n  }\n\n  _supportsLocalStorage() {\n    try {\n      return 'localStorage' in window && window.localStorage;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  _supportsSessionStorage() {\n    try {\n      return 'sessionStorage' in window && window.sessionStorage;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  _cloneConfig(obj) {\n    if (obj === null || typeof obj !== 'object') {\n      return obj;\n    }\n\n    const copy = {};\n    for (const attr in obj) {\n      if (obj.hasOwnProperty(attr)) {\n        copy[attr] = obj[attr];\n      }\n    }\n    return copy;\n  }\n\n  _addLibMetadata() {\n    // x-client-SKU\n    // x-client-Ver\n    return '&x-client-SKU=Js&x-client-Ver=' + this._libVersion();\n  }\n\n  log(level, message, error) {\n    if (level <= Logging.level) {\n      const timestamp = new Date().toUTCString();\n      let formattedMessage = '';\n\n      if (this.config.correlationId) {\n        formattedMessage = timestamp + ':' + this.config.correlationId + '-' + this._libVersion() + '-' + this.CONSTANTS.LEVEL_STRING_MAP[level] + ' ' + message;\n      } else {\n        formattedMessage = timestamp + ':' + this._libVersion() + '-' + this.CONSTANTS.LEVEL_STRING_MAP[level] + ' ' + message;\n      }\n\n      if (error) {\n        formattedMessage += '\\nstack:\\n' + error.stack;\n      }\n\n      Logging.log(formattedMessage);\n    }\n  }\n\n  error(message, error) {\n    this.log(this.CONSTANTS.LOGGING_LEVEL.ERROR, message, error);\n  }\n\n  warn(message) {\n    this.log(this.CONSTANTS.LOGGING_LEVEL.WARN, message, null);\n  }\n\n  info(message) {\n    this.log(this.CONSTANTS.LOGGING_LEVEL.INFO, message, null);\n  }\n\n  verbose(message) {\n    this.log(this.CONSTANTS.LOGGING_LEVEL.VERBOSE, message, null);\n  }\n\n  navigate(url) {\n    window.location.replace(url);\n  }\n\n  isIframe() {\n    return window.parent && window.parent !== window;\n  }\n\n  open(url, name, features) {\n    return window.open(url, name, features);\n  }\n\n  _libVersion() {\n    return '1.0.12';\n  }\n}\n\nglobal.Logging = {\n  level: 0,\n  log: (message) => {}\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./salte-auth.js\n **/","\nvar rng;\n\nvar crypto = global.crypto || global.msCrypto; // for IE 11\nif (crypto && crypto.getRandomValues) {\n  // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto\n  // Moderately fast, high quality\n  var _rnds8 = new Uint8Array(16);\n  rng = function whatwgRNG() {\n    crypto.getRandomValues(_rnds8);\n    return _rnds8;\n  };\n}\n\nif (!rng) {\n  // Math.random()-based (RNG)\n  //\n  // If all else fails, use Math.random().  It's fast, but is of unspecified\n  // quality.\n  var  _rnds = new Array(16);\n  rng = function() {\n    for (var i = 0, r; i < 16; i++) {\n      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n      _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return _rnds;\n  };\n}\n\nmodule.exports = rng;\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/uuid/lib/rng-browser.js\n ** module id = 1\n ** module chunks = 0\n **/","// Unique ID creation requires a high quality random # generator.  We feature\n// detect to determine the best RNG source, normalizing to a function that\n// returns 128-bits of randomness, since that's what's usually required\nvar _rng = require('./lib/rng');\n\n// Maps for number <-> hex string conversion\nvar _byteToHex = [];\nvar _hexToByte = {};\nfor (var i = 0; i < 256; ++i) {\n  _byteToHex[i] = (i + 0x100).toString(16).substr(1);\n  _hexToByte[_byteToHex[i]] = i;\n}\n\nfunction buff_to_string(buf, offset) {\n  var i = offset || 0;\n  var bth = _byteToHex;\n  return  bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]];\n}\n\n// **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\n// random #'s we need to init node and clockseq\nvar _seedBytes = _rng();\n\n// Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\nvar _nodeId = [\n  _seedBytes[0] | 0x01,\n  _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]\n];\n\n// Per 4.2.2, randomize (14 bit) clockseq\nvar _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;\n\n// Previous uuid creation time\nvar _lastMSecs = 0, _lastNSecs = 0;\n\n// See https://github.com/broofa/node-uuid for API details\nfunction v1(options, buf, offset) {\n  var i = buf && offset || 0;\n  var b = buf || [];\n\n  options = options || {};\n\n  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;\n\n  // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();\n\n  // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;\n\n  // Time since last uuid creation (in msecs)\n  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;\n\n  // Per 4.2.1.2, Bump clockseq on clock regression\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  }\n\n  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  }\n\n  // Per 4.2.1.2 Throw error if too many uuids are requested\n  if (nsecs >= 10000) {\n    throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq;\n\n  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n  msecs += 12219292800000;\n\n  // `time_low`\n  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff;\n\n  // `time_mid`\n  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff;\n\n  // `time_high_and_version`\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n  b[i++] = tmh >>> 16 & 0xff;\n\n  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n  b[i++] = clockseq >>> 8 | 0x80;\n\n  // `clock_seq_low`\n  b[i++] = clockseq & 0xff;\n\n  // `node`\n  var node = options.node || _nodeId;\n  for (var n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf ? buf : buff_to_string(b);\n}\n\n// **`v4()` - Generate random UUID**\n\n// See https://github.com/broofa/node-uuid for API details\nfunction v4(options, buf, offset) {\n  // Deprecated - 'format' argument, as supported in v1.2\n  var i = buf && offset || 0;\n\n  if (typeof(options) == 'string') {\n    buf = options == 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || _rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || buff_to_string(rnds);\n}\n\n// Export public API\nvar uuid = v4;\nuuid.v1 = v1;\nuuid.v4 = v4;\n\nmodule.exports = uuid;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/uuid/uuid.js\n ** module id = 2\n ** module chunks = 0\n **/"],"sourceRoot":""}