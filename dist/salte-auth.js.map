{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///salte-auth.js","webpack:///webpack/bootstrap 969d1e2a37cdd5b5302a","webpack:///./salte-auth.js","webpack:///external {\"root\":\"uuid\",\"commonjs2\":\"uuid\",\"commonjs\":\"uuid\",\"amd\":\"uuid\"}"],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_1__","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","global","_interopRequireDefault","obj","__esModule","default","_classCallCheck","instance","Constructor","TypeError","Object","defineProperty","value","_typeof","Symbol","iterator","constructor","prototype","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","protoProps","staticProps","_uuid","_uuid2","AuthenticationContext","config","REQUEST_TYPE","LOGIN","RENEW_TOKEN","UNKNOWN","CONSTANTS","ACCESS_TOKEN","EXPIRES_IN","ID_TOKEN","ERROR_DESCRIPTION","SESSION_STATE","STORAGE","TOKEN_KEYS","ACCESS_TOKEN_KEY","EXPIRATION_KEY","STATE_LOGIN","STATE_RENEW","NONCE_IDTOKEN","USERNAME","IDTOKEN","ERROR","LOGIN_REQUEST","LOGIN_ERROR","RENEW_STATUS","RESOURCE_DELIMETER","LOADFRAME_TIMEOUT","TOKEN_RENEW_STATUS_CANCELED","TOKEN_RENEW_STATUS_COMPLETED","TOKEN_RENEW_STATUS_IN_PROGRESS","LOGGING_LEVEL","WARN","INFO","VERBOSE","LEVEL_STRING_MAP","0","1","2","3","POPUP_WIDTH","POPUP_HEIGHT","window","callback","popUp","isAngular","_user","_activeRenewals","_loginInProgress","_renewStates","callBackMappedToRenewStates","callBacksMappedToRenewStates","displayCall","Error","clientId","_cloneConfig","match","loginResource","redirectUri","location","href","anonymousEndpoints","setResponseType","responseType","startPage","info","expectedState","v4","state","_idTokenNonce","verbose","_saveItem","urlNavigate","_getNavigateUrl","encodeURIComponent","_loginPopup","promptUser","title","popUpWidth","popUpHeight","winLeft","screenLeft","screenX","winTop","screenTop","screenY","width","innerWidth","document","documentElement","clientWidth","body","height","innerHeight","clientHeight","left","top","popupWindow","open","focus","e","warn","message","_this","_openPopup","_getItem","registeredRedirectUri","indexOf","split","pollTimer","setInterval","closed","undefined","clearInterval","hash","handleWindowCallback","search","close","keys","_isEmpty","resource","_hasResource","token","expired","offset","expireOffsetSeconds","_now","idtoken","_createUser","_this2","push","error","frameHandle","_addAuthFrame","_addHintParameters","registerCallback","src","_loadFrameTimeout","idTokenNonce","name","url","regex","RegExp","test","urlNavigation","frameName","_this3","_loadFrame","setTimeout","_this4","frameCheck","getCachedToken","_renewIdToken","_renewToken","navigate","clearCache","logout","postLogoutRedirectUri","str","profile","hasOwnProperty","upn","_urlContainsQueryStringParameter","parts","idToken","user","parsedJson","_extractIdToken","audienceMatch","Array","isArray","aud","azp","toLowerCase","userName","email","sub","substring","parameters","_getHash","_deserialize","_getSearch","searchParameters","_extend","_getParameters","requestInfo","valid","stateMatch","stateResponse","requestType","parent","statesInParentContext","splitIndex","_getResourceFromState","error_description","_expiresIn","nonce","exp","endpoint","endpoints","configEndpoint","_getHostFromUri","uri","extractedUri","String","replace","isCallback","getRequestInfo","saveTokenFromHash","isIframe","_serialize","_addLibMetadata","scope","encodedIdToken","decodedToken","_decodeJwt","base64IdToken","JWSPayload","base64Decoded","_base64DecodeStringUrlSafe","JSON","parse","err","decodeURIComponent","escape","atob","jwtToken","idTokenPartsRegex","matches","exec","crackedToken","header","JWSSig","slice","extraQueryParameter","correlationId","join","query","pl","decode","s","number","hex","toString","expires","parseInt","Math","round","Date","getTime","iframeId","authFrame","getElementById","createElement","opera","navigator","userAgent","ifr","setAttribute","style","visibility","position","borderWidth","getElementsByTagName","appendChild","insertAdjacentHTML","frames","cacheLocation","_supportsLocalStorage","localStorage","setItem","_supportsSessionStorage","sessionStorage","getItem","copy","attr","_libVersion","level","Logging","timestamp","toUTCString","formattedMessage","stack","log","features"],"mappings":";;;;;;;CAAA,SAAAA,EAAAC,GACA,gBAAAC,UAAA,gBAAAC,QACAA,OAAAD,QAAAD,EAAAG,QAAA,SACA,kBAAAC,gBAAAC,IACAD,OAAA,sBAAAJ,GACA,gBAAAC,SACAA,QAAA,cAAAD,EAAAG,QAAA,SAEAJ,EAAA,cAAAC,EAAAD,EAAA,OACCO,KAAA,SAAAC,GACD,MCOgB,UAAUC,GCb1B,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAT,OAGA,IAAAC,GAAAS,EAAAD,IACAT,WACAW,GAAAF,EACAG,QAAA,EAUA,OANAL,GAAAE,GAAAI,KAAAZ,EAAAD,QAAAC,IAAAD,QAAAQ,GAGAP,EAAAW,QAAA,EAGAX,EAAAD,QAvBA,GAAAU,KAqCA,OATAF,GAAAM,EAAAP,EAGAC,EAAAO,EAAAL,EAGAF,EAAAQ,EAAA,GAGAR,EAAA,KDuBM,SAASP,EAAQD,EAASQ,IAEH,SAASS,GAAS,YAmC9C,SAASC,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,UAASF,GAEvF,QAASG,GAAgBC,EAAUC,GAAe,KAAMD,YAAoBC,IAAgB,KAAM,IAAIC,WAAU,qCAnChHC,OAAOC,eAAe3B,EAAS,cAC7B4B,OAAO,GAGT,IAAIC,GAA4B,kBAAXC,SAAoD,gBAApBA,QAAOC,SAAwB,SAAUZ,GAAO,aAAcA,IAAS,SAAUA,GAAO,MAAOA,IAAyB,kBAAXW,SAAyBX,EAAIa,cAAgBF,QAAUX,IAAQW,OAAOG,UAAY,eAAkBd,IAElQe,EAAe,WAAc,QAASC,GAAiBC,EAAQC,GAAS,IAAK,GAAIC,GAAI,EAAGA,EAAID,EAAME,OAAQD,IAAK,CAAE,GAAIE,GAAaH,EAAMC,EAAIE,GAAWC,WAAaD,EAAWC,aAAc,EAAOD,EAAWE,cAAe,EAAU,SAAWF,KAAYA,EAAWG,UAAW,GAAMjB,OAAOC,eAAeS,EAAQI,EAAWI,IAAKJ,IAAiB,MAAO,UAAUhB,EAAaqB,EAAYC,GAAiJ,MAA9HD,IAAYV,EAAiBX,EAAYS,UAAWY,GAAiBC,GAAaX,EAAiBX,EAAasB,GAAqBtB,MEhDjiBuB,EAAAvC,EAAA,GFyEKwC,EAAS9B,EAAuB6B,GEvEhBE,EF6EQ,WE5E3B,QAAAA,GAAYC,GA0DV,GA1DkB5B,EAAAjB,KAAA4C,GAKlB5C,KAAK8C,cACHC,MAAO,QACPC,YAAa,cACbC,QAAS,WAOXjD,KAAKkD,WACHC,aAAc,eACdC,WAAY,aACZC,SAAU,WACVC,kBAAmB,oBACnBC,cAAe,gBACfC,SACEC,WAAY,kBACZC,iBAAkB,wBAClBC,eAAgB,sBAChBC,YAAa,mBACbC,YAAa,mBACbC,cAAe,qBACfP,cAAe,qBACfQ,SAAU,gBACVC,QAAS,eACTC,MAAO,aACPX,kBAAmB,yBACnBY,cAAe,qBACfC,YAAa,mBACbC,aAAc,2BAEhBC,mBAAoB,IACpBC,kBAAmB,OACnBC,4BAA6B,WAC7BC,6BAA8B,YAC9BC,+BAAgC,cAChCC,eACET,MAAO,EACPU,KAAM,EACNC,KAAM,EACNC,QAAS,GAEXC,kBACEC,EAAG,SACHC,EAAG,WACHC,EAAG,QACHC,EAAG,YAELC,YAAa,IACbC,aAAc,KAGZC,OAAOzC,sBACT,MAAOyC,QAAOzC,qBAoBhB,IAlBAyC,OAAOzC,sBAAwB5C,KAG/BA,KAAK6C,UACL7C,KAAKsF,SAAW,KAChBtF,KAAKuF,OAAQ,EACbvF,KAAKwF,WAAY,EAGjBxF,KAAKyF,MAAQ,KACbzF,KAAK0F,mBACL1F,KAAK2F,kBAAmB,EACxB3F,KAAK4F,gBAEL5F,KAAK6F,+BACL7F,KAAK8F,gCAGDjD,EAAOkD,aAA6C,kBAAvBlD,GAAOkD,YACtC,KAAM,IAAIC,OAAM,gCAGlB,KAAKnD,EAAOoD,SACV,KAAM,IAAID,OAAM,uBAalB,IAVAhG,KAAK6C,OAAS7C,KAAKkG,aAAarD,GAE5B7C,KAAK6C,OAAO0C,QACdvF,KAAKuF,OAAQ,GAGXvF,KAAK6C,OAAOyC,UAA4C,kBAAzBtF,MAAK6C,OAAOyC,WAC7CtF,KAAKsF,SAAWtF,KAAK6C,OAAOyC,WAGzBtF,KAAK6C,OAAO3B,WAAalB,KAAK6C,OAAO3B,SAASiF,MAAM,oBACvD,KAAM,IAAIH,OAAM,wEAIbhG,MAAK6C,OAAOuD,gBACfpG,KAAK6C,OAAOuD,cAAgBpG,KAAK6C,OAAOoD,UAGrCjG,KAAK6C,OAAOwD,cACfrG,KAAK6C,OAAOwD,YAAchB,OAAOiB,SAASC,MAGvCvG,KAAK6C,OAAO2D,qBACfxG,KAAK6C,OAAO2D,uBAGVxG,KAAK6C,OAAO2C,YACdxF,KAAKwF,UAAYxF,KAAK6C,OAAO2C,WAG/BxF,KAAKyG,gBAAgBzG,KAAK6C,OAAO6D,cFotClC,MAloCA7E,GAAae,IACXL,IAAK,kBACLhB,MAAO,SEjFMmF,GACd1G,KAAK6C,OAAO6D,aAAeA,GAAgB1G,KAAKkD,UAAUG,YF2FzDd,IAAK,QACLhB,MAAO,SEpFJoF,GAEJ,GAAI3G,KAAK2F,iBAEP,WADA3F,MAAK4G,KAAK,oBAGZ,IAAMC,GAAgBlE,aAAKmE,IAC3B9G,MAAK6C,OAAOkE,MAAQF,EACpB7G,KAAKgH,cAAgBrE,aAAKmE,KACrBH,IACHA,EAAYtB,OAAOiB,UAErBtG,KAAKiH,QAAQ,mBAAqBJ,EAAgB,cAAgBF,GAClE3G,KAAKkH,UAAUlH,KAAKkD,UAAUM,QAAQU,cAAeyC,GACrD3G,KAAKkH,UAAUlH,KAAKkD,UAAUM,QAAQW,YAAa,IACnDnE,KAAKkH,UAAUlH,KAAKkD,UAAUM,QAAQI,YAAaiD,GACnD7G,KAAKkH,UAAUlH,KAAKkD,UAAUM,QAAQM,cAAe9D,KAAKgH,eAC1DhH,KAAKkH,UAAUlH,KAAKkD,UAAUM,QAAQS,MAAO,IAC7CjE,KAAKkH,UAAUlH,KAAKkD,UAAUM,QAAQF,kBAAmB,GACzD,IAAM6D,GAAcnH,KAAKoH,gBAAgBpH,KAAK6C,OAAO6D,aAAc,MAAQ,UAAYW,mBAAmBrH,KAAKgH,cAE/G,OADAhH,MAAK2F,kBAAmB,EACpB3F,KAAKuF,UACPvF,MAAKsH,YAAYH,QAGfnH,KAAK6C,OAAOkD,YAEd/F,KAAK6C,OAAOkD,YAAYoB,GAExBnH,KAAKuH,WAAWJ,OFwFjB5E,IAAK,aACLhB,MAAO,SErFC4F,EAAaK,EAAOC,EAAYC,GACzC,IAKE,GAAMC,GAAUtC,OAAOuC,WAAavC,OAAOuC,WAAavC,OAAOwC,QACzDC,EAASzC,OAAO0C,UAAY1C,OAAO0C,UAAY1C,OAAO2C,QAKtDC,EAAQ5C,OAAO6C,YAAcC,SAASC,gBAAgBC,aAAeF,SAASG,KAAKD,YACnFE,EAASlD,OAAOmD,aAAeL,SAASC,gBAAgBK,cAAgBN,SAASG,KAAKG,aACtFC,EAAST,EAAQ,EAAMR,EAAa,EAAME,EAC1CgB,EAAQJ,EAAS,EAAMb,EAAc,EAAMI,EAE3Cc,EAAc5I,KAAK6I,KAAK1B,EAAaK,EAAO,SAAWC,EAAa,YAAcC,EAAc,SAAWiB,EAAM,UAAYD,EAInI,OAHIE,GAAYE,OACdF,EAAYE,QAEPF,EACP,MAAOG,GAGP,MAFA/I,MAAKgJ,KAAK,wBAA0BD,EAAEE,SACtCjJ,KAAK2F,kBAAmB,EACjB,SFyFRpD,IAAK,cACLhB,MAAO,SEtFE4F,GAAa,GAAA+B,GAAAlJ,KACjB4I,EAAc5I,KAAKmJ,WAAWhC,EAAa,QAASnH,KAAKkD,UAAUiC,YAAanF,KAAKkD,UAAUkC,aACrG,IAAoB,OAAhBwD,EAQF,MAPA5I,MAAKgJ,KAAK,6DACVhJ,KAAKkH,UAAUlH,KAAKkD,UAAUM,QAAQS,MAAO,uBAC7CjE,KAAKkH,UAAUlH,KAAKkD,UAAUM,QAAQF,kBAAmB,6DACzDtD,KAAKkH,UAAUlH,KAAKkD,UAAUM,QAAQW,YAAa,kEAC/CnE,KAAKsF,UACPtF,KAAKsF,SAAStF,KAAKoJ,SAASpJ,KAAKkD,UAAUM,QAAQW,aAAc,MAIrE,IAAIkF,SAEFA,GADErJ,KAAK6C,OAAOwD,YAAYiD,QAAQ,UACVtJ,KAAK6C,OAAOwD,YAEZrG,KAAK6C,OAAOwD,YAAYkD,MAAM,KAAK,EAE7D,IAAMC,GAAYnE,OAAOoE,YAAY,WAC9Bb,IAAeA,EAAYc,QAAiCC,SAAvBf,EAAYc,SACpDR,EAAKvD,kBAAmB,EACxBN,OAAOuE,cAAcJ,GAEvB,KACMZ,EAAYtC,SAASC,KAAK+C,QAAQD,UAChCH,EAAK1D,UACPH,OAAOiB,SAASuD,KAAOjB,EAAYtC,SAASuD,KAE5CX,EAAKY,qBAAqBlB,EAAYtC,SAASuD,KAAMjB,EAAYtC,SAASyD,QAE5E1E,OAAOuE,cAAcJ,GACrBN,EAAKvD,kBAAmB,EACxBuD,EAAKtC,KAAK,wBACVgC,EAAYoB,SAEd,MAAOjB,MAER,OF0FFxG,IAAK,kBACLhB,MAAO,WEvFR,MAAOvB,MAAK2F,oBF2FXpD,IAAK,eACLhB,MAAO,SEzFGgB,GACX,GAAM0H,GAAOjK,KAAKoJ,SAASpJ,KAAKkD,UAAUM,QAAQC,WAClD,OAAOwG,KAASjK,KAAKkK,SAASD,IAAUA,EAAKX,QAAQ/G,EAAMvC,KAAKkD,UAAUmB,0BFmGzE9B,IAAK,iBACLhB,MAAO,SE5FK4I,GACb,IAAKnK,KAAKoK,aAAaD,GACrB,MAAO,KAGT,IAAME,GAAQrK,KAAKoJ,SAASpJ,KAAKkD,UAAUM,QAAQE,iBAAmByG,GAChEG,EAAUtK,KAAKoJ,SAASpJ,KAAKkD,UAAUM,QAAQG,eAAiBwG,GAGhEI,EAASvK,KAAK6C,OAAO2H,qBAAuB,GAElD,OAAIF,IAAYA,EAAUtK,KAAKyK,OAASF,EAC/BF,GAETrK,KAAKkH,UAAUlH,KAAKkD,UAAUM,QAAQE,iBAAmByG,EAAU,IACnEnK,KAAKkH,UAAUlH,KAAKkD,UAAUM,QAAQG,eAAiBwG,EAAU,GAC1D,SFqGN5H,IAAK,gBACLhB,MAAO,WE9FR,GAAIvB,KAAKyF,MACP,MAAOzF,MAAKyF,KAGd,IAAMiF,GAAU1K,KAAKoJ,SAASpJ,KAAKkD,UAAUM,QAAQQ,QAErD,OADAhE,MAAKyF,MAAQzF,KAAK2K,YAAYD,GACvB1K,KAAKyF,SFkGXlD,IAAK,mBACLhB,MAAO,SEhGOsF,EAAesD,EAAU7E,GAAU,GAAAsF,GAAA5K,IAClDA,MAAK0F,gBAAgByE,GAAYtD,EAC5B7G,KAAK8F,6BAA6Be,KACrC7G,KAAK8F,6BAA6Be,OAEpC7G,KAAK8F,6BAA6Be,GAAegE,KAAKvF,GACjDtF,KAAK6F,4BAA4BgB,KACpC7G,KAAK6F,4BAA4BgB,GAAiB,SAACoC,EAASoB,GAC1D,IAAK,GAAIpI,GAAI,EAAGA,EAAI2I,EAAK9E,6BAA6Be,GAAe3E,SAAUD,EAC7E,IACE2I,EAAK9E,6BAA6Be,GAAe5E,GAAGgH,EAASoB,GAC7D,MAAOS,GACPF,EAAK5B,KAAK8B,GAGdF,EAAKlF,gBAAgByE,GAAY,KACjCS,EAAK9E,6BAA6Be,GAAiB,KACnD+D,EAAK/E,4BAA4BgB,GAAiB,UF8GrDtE,IAAK,cACLhB,MAAO,SErGE4I,EAAU7E,GAGpBtF,KAAK4G,KAAK,qCAAuCuD,EACjD,IAAMY,GAAc/K,KAAKgL,cAAc,iBAAmBb,GACpDtD,EAAgBlE,aAAKmE,KAAO,IAAMqD,CACxCnK,MAAK6C,OAAOkE,MAAQF,EAEpB7G,KAAK4F,aAAaiF,KAAKhE,GAEvB7G,KAAKiH,QAAQ,+BAAiCJ,EAC9C,IAAIM,GAAcnH,KAAKoH,gBAAgB,QAAS+C,GAAY,cAC5DhD,GAAcnH,KAAKiL,mBAAmB9D,GAEtCnH,KAAKkL,iBAAiBrE,EAAesD,EAAU7E,GAC/CtF,KAAKiH,QAAQ,eAAiBE,GAC9BnH,KAAKkH,UAAUlH,KAAKkD,UAAUM,QAAQU,cAAe,IACrD6G,EAAYI,IAAM,cAClBnL,KAAKoL,kBAAkBjE,EAAa,iBAAmBgD,EAAUA,MFwGhE5H,IAAK,gBACLhB,MAAO,SEtGI+D,GAEZtF,KAAK4G,KAAK,yBACV,IAAMmE,GAAc/K,KAAKgL,cAAc,oBACjCnE,EAAgBlE,aAAKmE,KAAO,IAAM9G,KAAK6C,OAAOoD,QACpDjG,MAAKgH,cAAgBrE,aAAKmE,KAC1B9G,KAAKkH,UAAUlH,KAAKkD,UAAUM,QAAQM,cAAe9D,KAAKgH,eAC1DhH,KAAK6C,OAAOkE,MAAQF,EAEpB7G,KAAK4F,aAAaiF,KAAKhE,GAEvB7G,KAAKiH,QAAQ,iCAAmCJ,EAChD,IAAIM,GAAcnH,KAAKoH,gBAAgBpH,KAAK6C,OAAO6D,aAAc,MAAQ,cACzES,GAAcnH,KAAKiL,mBAAmB9D,GAEtCA,GAAe,UAAYE,mBAAmBrH,KAAKgH,eACnDhH,KAAKkL,iBAAiBrE,EAAe7G,KAAK6C,OAAOoD,SAAUX,GAC3DtF,KAAKqL,aAAe,KACpBrL,KAAKiH,QAAQ,eAAiBE,GAC9BnH,KAAKkH,UAAUlH,KAAKkD,UAAUM,QAAQU,cAAe,IACrD6G,EAAYI,IAAM,cAClBnL,KAAKoL,kBAAkBjE,EAAa,mBAAoBnH,KAAK6C,OAAOoD,aFyGnE1D,IAAK,mCACLhB,MAAO,SEvGuB+J,EAAMC,GAErC,GAAMC,GAAQ,GAAIC,QAAO,SAAWH,EAAO,IAC3C,OAAOE,GAAME,KAAKH,MF8GjBhJ,IAAK,oBACLhB,MAAO,SE1GQoK,EAAeC,EAAWzB,GAAU,GAAA0B,GAAA7L,IAEpDA,MAAKiH,QAAQ,qCAAuCkD,GACpDnK,KAAKkH,UAAUlH,KAAKkD,UAAUM,QAAQY,aAAe+F,EAAUnK,KAAKkD,UAAUuB,gCAC9EzE,KAAK8L,WAAWH,EAAeC,GAC/BG,WAAW,WACT,GAAIF,EAAKzC,SAASyC,EAAK3I,UAAUM,QAAQY,aAAe+F,KAAc0B,EAAK3I,UAAUuB,+BAAgC,CAEnHoH,EAAK5E,QAAQ,sCAAyC4E,EAAK3I,UAAUoB,kBAAoB,IAAQ,yBAA2B6F,EAC5H,IAAMtD,GAAgBgF,EAAKnG,gBAAgByE,EAE3C0B,GAAK3E,UAAU2E,EAAK3I,UAAUM,QAAQY,aAAe+F,EAAU0B,EAAK3I,UAAUqB,6BAE1EsC,GAAiBgF,EAAKhG,4BAA4BgB,IACpDgF,EAAKhG,4BAA4BgB,GAAe,gDAAiD,QAGpG7G,KAAKkD,UAAUoB,sBF+GjB/B,IAAK,aACLhB,MAAO,SE7GC4F,EAAayE,GAAW,GAAAI,GAAAhM,IAGjCA,MAAK4G,KAAK,cAAgBgF,EAC1B,IAAMK,GAAaL,CACnBG,YAAW,WACT,GAAMhB,GAAciB,EAAKhB,cAAciB,EACf,MAApBlB,EAAYI,KAAkC,gBAApBJ,EAAYI,MACxCJ,EAAYI,IAAMhE,EAClB6E,EAAKF,WAAW3E,EAAa8E,KAE9B,QFyHF1J,IAAK,eACLhB,MAAO,SElHG4I,EAAU7E,GACrB,GAAItF,KAAKkK,SAASC,GAGhB,MAFAnK,MAAKgJ,KAAK,4BACV1D,GAAS,uBAAwB,KAInC,IAAM+E,GAAQrK,KAAKkM,eAAe/B,EAClC,OAAIE,IACFrK,KAAK4G,KAAK,0CAA4CuD,OACtD7E,GAAS,KAAM+E,IAIZrK,KAAKyF,WAQNzF,KAAK0F,gBAAgByE,GAEvBnK,KAAKkL,iBAAiBlL,KAAK0F,gBAAgByE,GAAWA,EAAU7E,GACvD6E,IAAanK,KAAK6C,OAAOoD,UAGlCjG,KAAKiH,QAAQ,oBACbjH,KAAKmM,cAAc7G,IAEnBtF,KAAKoM,YAAYjC,EAAU7E,KAhB3BtF,KAAKgJ,KAAK,8BACV1D,GAAS,yBAA0B,UF2IpC/C,IAAK,aACLhB,MAAO,SErHC4F,GACLA,GACFnH,KAAK4G,KAAK,eAAiBO,GAC3BnH,KAAKqM,SAASlF,IAEdnH,KAAK4G,KAAK,4BF8HXrE,IAAK,aACLhB,MAAO,WEvHRvB,KAAKkH,UAAUlH,KAAKkD,UAAUM,QAAQE,iBAAkB,IACxD1D,KAAKkH,UAAUlH,KAAKkD,UAAUM,QAAQG,eAAgB,GACtD3D,KAAKkH,UAAUlH,KAAKkD,UAAUM,QAAQD,cAAe,IACrDvD,KAAKkH,UAAUlH,KAAKkD,UAAUM,QAAQI,YAAa,IACnD5D,KAAK4F,gBACL5F,KAAKkH,UAAUlH,KAAKkD,UAAUM,QAAQO,SAAU,IAChD/D,KAAKkH,UAAUlH,KAAKkD,UAAUM,QAAQQ,QAAS,IAC/ChE,KAAKkH,UAAUlH,KAAKkD,UAAUM,QAAQS,MAAO,IAC7CjE,KAAKkH,UAAUlH,KAAKkD,UAAUM,QAAQF,kBAAmB,GACzD,IAAI2G,GAAOjK,KAAKoJ,SAASpJ,KAAKkD,UAAUM,QAAQC,WAEhD,KAAKzD,KAAKkK,SAASD,GAAO,CACxBA,EAAOA,EAAKV,MAAMvJ,KAAKkD,UAAUmB,mBACjC,KAAK,GAAIpC,GAAI,EAAGA,EAAIgI,EAAK/H,OAAQD,IAC/BjC,KAAKkH,UAAUlH,KAAKkD,UAAUM,QAAQE,iBAAmBuG,EAAKhI,GAAI,IAClEjC,KAAKkH,UAAUlH,KAAKkD,UAAUM,QAAQG,eAAiBsG,EAAKhI,GAAI,GAGpEjC,KAAKkH,UAAUlH,KAAKkD,UAAUM,QAAQC,WAAY,OFiIjDlB,IAAK,wBACLhB,MAAO,SE3HY4I,GACpBnK,KAAKkH,UAAUlH,KAAKkD,UAAUM,QAAQK,YAAa,IACnD7D,KAAKkH,UAAUlH,KAAKkD,UAAUM,QAAQS,MAAO,IAC7CjE,KAAKkH,UAAUlH,KAAKkD,UAAUM,QAAQF,kBAAmB,IACrDtD,KAAKoK,aAAaD,KACpBnK,KAAKkH,UAAUlH,KAAKkD,UAAUM,QAAQE,iBAAmByG,EAAU,IACnEnK,KAAKkH,UAAUlH,KAAKkD,UAAUM,QAAQG,eAAiBwG,EAAU,OFqIlE5H,IAAK,SACLhB,MAAO,WE7HRvB,KAAKsM,YACL,IAAIC,GAAS,EACbvM,MAAKyF,MAAQ,KAETzF,KAAK6C,OAAO2J,wBACdD,EAAS,4BAA8BlF,mBAAmBrH,KAAK6C,OAAO2J,uBAGxE,IAAMrF,GAAcnH,KAAK6C,OAAO3B,SAAW,UAAYqL,CACvDvM,MAAK4G,KAAK,uBAAyBO,GACnCnH,KAAKuH,WAAWJ,MFiIf5E,IAAK,WACLhB,MAAO,SE/HDkL,GACP,MAAuB,mBAARA,KAAwBA,GAAsB,IAAfA,EAAIvK,UFwIjDK,IAAK,UACLhB,MAAO,SElIF+D,GAEN,GAAwB,kBAAbA,GACT,KAAM,IAAIU,OAAM,6BAIlB,IAAIhG,KAAKyF,MAEP,WADAH,GAAS,KAAMtF,KAAKyF,MAKtB,IAAMiF,GAAU1K,KAAKoJ,SAASpJ,KAAKkD,UAAUM,QAAQQ,QACjDhE,MAAKkK,SAASQ,IAChB1K,KAAKgJ,KAAK,qCACV1D,EAAS,uCAETtF,KAAK4G,KAAK,0BACV5G,KAAKyF,MAAQzF,KAAK2K,YAAYD,GAC9BpF,EAAS,KAAMtF,KAAKyF,WFsIrBlD,IAAK,qBACLhB,MAAO,SEnIS4F,GAEjB,GAAInH,KAAKyF,OAASzF,KAAKyF,MAAMiH,SAAW1M,KAAKyF,MAAMiH,QAAQC,eAAe,SAExExF,GAAe,eAAiBE,mBAAmBrH,KAAKyF,MAAMiH,QAAQE,MAGjE5M,KAAK6M,iCAAiC,cAAe1F,IAAgBnH,KAAKyF,MAAMiH,QAAQE,IAAItD,QAAQ,SAAW,CAClH,GAAMwD,GAAQ9M,KAAKyF,MAAMiH,QAAQE,IAAIrD,MAAM,IAE3CpC,IAAe,gBAAkBE,mBAAmByF,EAAMA,EAAM5K,OAAS,IAI7E,MAAOiF,MFsIN5E,IAAK,cACLhB,MAAO,SEpIEwL,GACV,GAAIC,GAAO,KACLC,EAAajN,KAAKkN,gBAAgBH,EACxC,IAAIE,GAAcA,EAAWN,eAAe,OAAQ,CAClD,GAAIQ,IAAgB,CAEpB,IAAIC,MAAMC,QAAQJ,EAAWK,MAE3B,GAAIL,EAAWN,eAAe,QAAUM,EAAWM,IAAIC,gBAAkBxN,KAAK6C,OAAOoD,SAASuH,cAC5F,IAAK,GAAIvL,GAAI,EAAGA,EAAIgL,EAAWK,IAAIpL,OAAQD,IACzC,GAAIgL,EAAWK,IAAIrL,GAAGuL,gBAAkBxN,KAAK6C,OAAOoD,SAASuH,cAAe,CAC1EL,GAAgB,CAChB,YAKNA,GAAiBF,EAAWK,IAAIE,gBAAkBxN,KAAK6C,OAAOoD,SAASuH,aAGrEL,IACFH,GACES,SAAU,GACVf,QAASO,GAGPA,EAAWN,eAAe,OAC5BK,EAAKS,SAAWR,EAAWL,IAClBK,EAAWN,eAAe,SACnCK,EAAKS,SAAWR,EAAWS,MAClBT,EAAWN,eAAe,SACnCK,EAAKS,SAAWR,EAAWU,MAG7B3N,KAAKgJ,KAAK,qCAId,MAAOgE,MFuINzK,IAAK,WACLhB,MAAO,SErIDsI,GAOP,MANIA,GAAKP,QAAQ,SACfO,EAAOA,EAAK+D,UAAU/D,EAAKP,QAAQ,MAAQ,GAClCO,EAAKP,QAAQ,UACtBO,EAAOA,EAAK+D,UAAU,IAGjB/D,KFwINtH,IAAK,aACLhB,MAAO,SEtICwI,GAKT,MAJIA,GAAOT,QAAQ,UACjBS,EAASA,EAAO6D,UAAU,IAGrB7D,KFyINxH,IAAK,iBACLhB,MAAO,SEvIKsI,EAAME,GACnB,GAAI8D,KAOJ,IALIhE,IACFA,EAAO7J,KAAK8N,SAASjE,GACrBgE,EAAa7N,KAAK+N,aAAalE,IAG7BE,EAAQ,CACVA,EAAS/J,KAAKgO,WAAWjE,EACzB,IAAMkE,GAAmBjO,KAAK+N,aAAahE,EAC3C8D,GAAa7N,KAAKkO,QAAQL,EAAYI,GAGxC,MAAOJ,MF0INtL,IAAK,UACLhB,MAAO,SExIFT,EAAKqK,GACX,IAAK,GAAM5I,KAAO4I,GACZA,EAAIwB,eAAepK,KACrBzB,EAAIyB,GAAO4I,EAAI5I,GAGnB,OAAOzB,MFmJNyB,IAAK,aACLhB,MAAO,SE3ICsI,EAAME,GACf,GAAM8D,GAAa7N,KAAKmO,eAAetE,EAAME,EAE7C,OAAO8D,GAAWlB,eAAe3M,KAAKkD,UAAUI,oBAC9CuK,EAAWlB,eAAe3M,KAAKkD,UAAUC,eACzC0K,EAAWlB,eAAe3M,KAAKkD,UAAUG,aFkJ1Cd,IAAK,gBACLhB,MAAO,WE3IR,MAAOvB,MAAKoJ,SAASpJ,KAAKkD,UAAUM,QAAQW,gBFuJ3C5B,IAAK,iBACLhB,MAAO,SE/IKsI,EAAME,GACnB,GAAM8D,GAAa7N,KAAKmO,eAAetE,EAAME,GACvCqE,GACJC,OAAO,EACPR,cACAS,YAAY,EACZC,cAAe,GACfC,YAAaxO,KAAK8C,aAAaG,QAGjC,IAAI4K,IACFO,EAAYP,WAAaA,EACrBA,EAAWlB,eAAe3M,KAAKkD,UAAUI,oBAC3CuK,EAAWlB,eAAe3M,KAAKkD,UAAUC,eACzC0K,EAAWlB,eAAe3M,KAAKkD,UAAUG,WAAW,CACpD+K,EAAYC,OAAQ,CAGpB,IAAIE,GAAgB,EACpB,KAAIV,EAAWlB,eAAe,SAK5B,MADA3M,MAAKgJ,KAAK,qBACHoF,CAOT,IAXEpO,KAAKiH,QAAQ,UAAY4G,EAAW9G,OACpCwH,EAAgBV,EAAW9G,MAM7BqH,EAAYG,cAAgBA,EAIxBA,IAAkBvO,KAAKoJ,SAASpJ,KAAKkD,UAAUM,QAAQI,aAGzD,MAFAwK,GAAYI,YAAcxO,KAAK8C,aAAaC,MAC5CqL,EAAYE,YAAa,EAClBF,CAIT,KAAKA,EAAYE,YAAcjJ,OAAOoJ,QAAUpJ,OAAOoJ,OAAO7L,sBAE5D,IAAK,GADC8L,GAAwBrJ,OAAOoJ,OAAO7L,sBAAsBgD,aACzD3D,EAAI,EAAGA,EAAIyM,EAAsBxM,OAAQD,IAChD,GAAIyM,EAAsBzM,KAAOmM,EAAYG,cAAe,CAC1DH,EAAYI,YAAcxO,KAAK8C,aAAaE,YAC5CoL,EAAYE,YAAa,CACzB,QAOV,MAAOF,MFgJN7L,IAAK,wBACLhB,MAAO,SE9IYwF,GACpB,GAAIA,EAAO,CACT,GAAM4H,GAAa5H,EAAMuC,QAAQ,IACjC,IAAIqF,MAAmBA,EAAa,EAAI5H,EAAM7E,OAC5C,MAAO6E,GAAM6G,UAAUe,EAAa,GAIxC,MAAO,MFuJNpM,IAAK,oBACLhB,MAAO,SEjJQ6M,GAChBpO,KAAK4G,KAAK,gBAAkBwH,EAAYE,WAAa,kBAAoBF,EAAYI,aACrFxO,KAAKkH,UAAUlH,KAAKkD,UAAUM,QAAQS,MAAO,IAC7CjE,KAAKkH,UAAUlH,KAAKkD,UAAUM,QAAQF,kBAAmB,GAEzD,IAAI6G,GAAWnK,KAAK4O,sBAAsBR,EAAYG,cAGtD,IAAIH,EAAYP,WAAWlB,eAAe3M,KAAKkD,UAAUI,mBACvDtD,KAAK4G,KAAK,UAAYwH,EAAYP,WAAW/C,MAAQ,uBAAyBsD,EAAYP,WAAW7N,KAAKkD,UAAUI,oBACpHtD,KAAKkH,UAAUlH,KAAKkD,UAAUM,QAAQS,MAAOmK,EAAYP,WAAW/C,OACpE9K,KAAKkH,UAAUlH,KAAKkD,UAAUM,QAAQF,kBAAmB8K,EAAYP,WAAW7N,KAAKkD,UAAUI,oBAE3F8K,EAAYI,cAAgBxO,KAAK8C,aAAaC,QAChD/C,KAAK2F,kBAAmB,EACxB3F,KAAKkH,UAAUlH,KAAKkD,UAAUM,QAAQW,YAAaiK,EAAYP,WAAWgB,wBAEvE,IAAIT,EAAYE,WAAY,CAEjCtO,KAAK4G,KAAK,kBACNwH,EAAYP,WAAWlB,eAAe3M,KAAKkD,UAAUK,gBACvDvD,KAAKkH,UAAUlH,KAAKkD,UAAUM,QAAQD,cAAe6K,EAAYP,WAAW7N,KAAKkD,UAAUK,eAG7F,IAAI0G,SAEAmE,GAAYP,WAAWlB,eAAe3M,KAAKkD,UAAUC,gBACvDnD,KAAK4G,KAAK,6BAEL5G,KAAKoK,aAAaD,KACrBF,EAAOjK,KAAKoJ,SAASpJ,KAAKkD,UAAUM,QAAQC,aAAe,GAC3DzD,KAAKkH,UAAUlH,KAAKkD,UAAUM,QAAQC,WAAYwG,EAAOE,EAAWnK,KAAKkD,UAAUmB,qBAGrFrE,KAAKkH,UAAUlH,KAAKkD,UAAUM,QAAQE,iBAAmByG,EAAUiE,EAAYP,WAAW7N,KAAKkD,UAAUC,eACzGnD,KAAKkH,UAAUlH,KAAKkD,UAAUM,QAAQG,eAAiBwG,EAAUnK,KAAK8O,WAAWV,EAAYP,WAAW7N,KAAKkD,UAAUE,eAGrHgL,EAAYP,WAAWlB,eAAe3M,KAAKkD,UAAUG,YACvDrD,KAAK4G,KAAK,yBACV5G,KAAK2F,kBAAmB,EAExB3F,KAAKyF,MAAQzF,KAAK2K,YAAYyD,EAAYP,WAAW7N,KAAKkD,UAAUG,WAEhErD,KAAKyF,OAASzF,KAAKyF,MAAMiH,QACvB1M,KAAKyF,MAAMiH,QAAQqC,QAAU/O,KAAKoJ,SAASpJ,KAAKkD,UAAUM,QAAQM,gBACpE9D,KAAKkH,UAAUlH,KAAKkD,UAAUM,QAAQQ,QAASoK,EAAYP,WAAW7N,KAAKkD,UAAUG,WAGrF8G,EAAWnK,KAAK6C,OAAOuD,cAAgBpG,KAAK6C,OAAOuD,cAAgBpG,KAAK6C,OAAOoD,SAE1EjG,KAAKoK,aAAaD,KACrBF,EAAOjK,KAAKoJ,SAASpJ,KAAKkD,UAAUM,QAAQC,aAAe,GAC3DzD,KAAKkH,UAAUlH,KAAKkD,UAAUM,QAAQC,WAAYwG,EAAOE,EAAWnK,KAAKkD,UAAUmB,qBAErFrE,KAAKkH,UAAUlH,KAAKkD,UAAUM,QAAQE,iBAAmByG,EAAUiE,EAAYP,WAAW7N,KAAKkD,UAAUG,WACzGrD,KAAKkH,UAAUlH,KAAKkD,UAAUM,QAAQG,eAAiBwG,EAAUnK,KAAKyF,MAAMiH,QAAQsC,OAEpFhP,KAAKyF,MAAQ,KACbzF,KAAKkH,UAAUlH,KAAKkD,UAAUM,QAAQW,YAAa,wBAA0BnE,KAAKgH,iBAGpFhH,KAAKkH,UAAUlH,KAAKkD,UAAUM,QAAQS,MAAO,oBAC7CjE,KAAKkH,UAAUlH,KAAKkD,UAAUM,QAAQF,kBAAmB,+BAAiC8K,EAAYP,WAAW7N,KAAKkD,UAAUG,iBAIpIrD,MAAKkH,UAAUlH,KAAKkD,UAAUM,QAAQS,MAAO,iBAC7CjE,KAAKkH,UAAUlH,KAAKkD,UAAUM,QAAQF,kBAAmB,yBAA2B8K,EAAYG,cAElGvO,MAAKkH,UAAUlH,KAAKkD,UAAUM,QAAQY,aAAe+F,EAAUnK,KAAKkD,UAAUsB,iCF2J7EjC,IAAK,yBACLhB,MAAO,SEpJa0N,GACrB,GAAIjP,KAAK6C,QAAU7C,KAAK6C,OAAOqM,UAC7B,IAAK,GAAMC,KAAkBnP,MAAK6C,OAAOqM,UAEvC,GAAID,EAAS3F,QAAQ6F,MACnB,MAAOnP,MAAK6C,OAAOqM,UAAUC,EAQnC,MAAIF,EAAS3F,QAAQ,eAAmB2F,EAAS3F,QAAQ,gBAIlD,CAIL,GAAItJ,KAAK6C,QAAU7C,KAAK6C,OAAO2D,mBAC7B,IAAK,GAAIvE,GAAI,EAAGA,EAAIjC,KAAK6C,OAAO2D,mBAAmBtE,OAAQD,IACzD,GAAIgN,EAAS3F,QAAQtJ,KAAK6C,OAAO2D,mBAAmBvE,OAClD,MAAO,KAKb,OAAOjC,MAAK6C,OAAOuD,cAfnB,MAAIpG,MAAKoP,gBAAgBH,KAAcjP,KAAKoP,gBAAgBpP,KAAK6C,OAAOwD,aAC/DrG,KAAK6C,OAAOuD,cAkBhB,QFuJN7D,IAAK,kBACLhB,MAAO,SErJM8N,GAEd,GAAIC,GAAeC,OAAOF,GAAKG,QAAQ,iBAAkB,GAGzD,OADAF,GAAeA,EAAa/F,MAAM,KAAK,MF4JtChH,IAAK,uBACLhB,MAAO,SExJWsI,EAAME,GAWzB,GARKF,IACHA,EAAOxE,OAAOiB,SAASuD,MAGpBE,IACHA,EAAS1E,OAAOiB,SAASyD,QAGvB/J,KAAKyP,WAAW5F,EAAME,GAAS,CACjC,GAAMqE,GAAcpO,KAAK0P,eAAe7F,EAAME,EAC9C/J,MAAK4G,KAAK,8BACV5G,KAAK2P,kBAAkBvB,EACvB,IAAI9I,GAAW,IACf,IAAK8I,EAAYI,cAAgBxO,KAAK8C,aAAaE,aAAgBhD,KAAK4P,WAOtE,MALA5P,MAAKiH,QAAQ,uBACb3B,EAAWD,OAAOoJ,OAAO7L,sBAAsBiD,4BAA4BuI,EAAYG,oBACnFjJ,GACFA,EAAStF,KAAKoJ,SAASpJ,KAAKkD,UAAUM,QAAQF,mBAAoB8K,EAAYP,WAAW7N,KAAKkD,UAAUC,eAAiBiL,EAAYP,WAAW7N,KAAKkD,UAAUG,WAGxJ+K,GAAYI,cAAgBxO,KAAK8C,aAAaC,QACvDuC,EAAWtF,KAAKsF,SACZA,GACFA,EAAStF,KAAKoJ,SAASpJ,KAAKkD,UAAUM,QAAQF,mBAAoB8K,EAAYP,WAAW7N,KAAKkD,UAAUG,YAIvGrD,KAAKuF,OACRvF,KAAKqM,SAASrM,KAAKoJ,SAASpJ,KAAKkD,UAAUM,QAAQU,oBF6JtD3B,IAAK,kBACLhB,MAAO,SEzJMmF,EAAcyD,GAC5B,GAAIhD,GAAcnH,KAAK6C,OAAO3B,SAAW,YAAclB,KAAK6P,WAAWnJ,EAAc1G,KAAK6C,OAAQsH,GAAYnK,KAAK8P,iBAKnH,OAJI9P,MAAK6C,OAAOkN,QACd5I,GAAe,UAAYE,mBAAmBrH,KAAK6C,OAAOkN,QAE5D/P,KAAK4G,KAAK,gBAAkBO,GACrBA,KF4JN5E,IAAK,kBACLhB,MAAO,SE1JMyO,GAEd,GAAMC,GAAejQ,KAAKkQ,WAAWF,EACrC,KAAKC,EACH,MAAO,KAGT,KACE,GAAME,GAAgBF,EAAaG,WAC7BC,EAAgBrQ,KAAKsQ,2BAA2BH,EACtD,OAAKE,GAKEE,KAAKC,MAAMH,IAJhBrQ,KAAK4G,KAAK,+DACH,MAIT,MAAO6J,GACPzQ,KAAK8K,MAAM,6CAA8C2F,GAG3D,MAAO,SF6JNlO,IAAK,6BACLhB,MAAO,SE3JiB4O,GAEzB,MADAA,GAAgBA,EAAcX,QAAQ,KAAM,KAAKA,QAAQ,KAAM,KACxDkB,mBAAmBC,OAAOtL,OAAOuL,KAAKT,QFiK5C5N,IAAK,aACLhB,MAAO,SE9JCsP,GACT,GAAI7Q,KAAKkK,SAAS2G,GAChB,MAAO,KAGT,IAAMC,GAAoB,uCAEpBC,EAAUD,EAAkBE,KAAKH,EACvC,KAAKE,GAAWA,EAAQ7O,OAAS,EAE/B,MADAlC,MAAKgJ,KAAK,2CACH,IAGT,IAAMiI,IACJC,OAAQH,EAAQ,GAChBX,WAAYW,EAAQ,GACpBI,OAAQJ,EAAQ,GAGlB,OAAOE,MFiKN1O,IAAK,8CACLhB,MAAO,SE/JkCkL,GAC1C,MAAOA,GAAI+C,QAAQ,IAAK,KAAKA,QAAQ,IAAK,QFkKzCjN,IAAK,aACLhB,MAAO,SEhKCmF,EAAc5F,EAAKqJ,GAC5B,GAAMsC,KACN,IAAY,OAAR3L,EAAc,CAChB2L,EAAI5B,KAAK,kBAAoBxD,mBAAmBX,IAChD+F,EAAI5B,KAAK,aAAexD,mBAAmBvG,EAAImF,WAC3CkE,GACFsC,EAAI5B,KAAK,YAAcxD,mBAAmB8C,IAG5CsC,EAAI5B,KAAK,gBAAkBxD,mBAAmBvG,EAAIuF,cAClDoG,EAAI5B,KAAK,SAAWxD,mBAAmBvG,EAAIiG,QAEvCjG,EAAI6L,eAAe,UACrBF,EAAI5B,KAAK,SAAWxD,mBAAmBvG,EAAIsQ,QAGzCtQ,EAAI6L,eAAe,wBACrBF,EAAI5B,KAAK/J,EAAIuQ,oBAGf,IAAMC,GAAgBxQ,EAAIwQ,cAAgBxQ,EAAIwQ,cAAgB3O,aAAKmE,IACnE2F,GAAI5B,KAAK,qBAAuBxD,mBAAmBiK,IAGrD,MAAO7E,GAAI8E,KAAK,QFmKfhP,IAAK,eACLhB,MAAO,SEjKGiQ,GAQX,IAPA,GAAMC,GAAK,MACL1H,EAAS,oBACT2H,EAAS,SAACC,GACd,MAAOjB,oBAAmBiB,EAAEnC,QAAQiC,EAAI,OAEpC3Q,KACFqF,EAAQ4D,EAAOiH,KAAKQ,GACjBrL,GACLrF,EAAI4Q,EAAOvL,EAAM,KAAOuL,EAAOvL,EAAM,IACrCA,EAAQ4D,EAAOiH,KAAKQ,EAGtB,OAAO1Q,MFoKNyB,IAAK,gBACLhB,MAAO,SElKIqQ,GAEZ,IADA,GAAIC,GAAMD,EAAOE,SAAS,IACnBD,EAAI3P,OAAS,GAClB2P,EAAM,IAAMA,CAEd,OAAOA,MFqKNtP,IAAK,aACLhB,MAAO,SEnKCwQ,GACT,MAAO/R,MAAKyK,OAASuH,SAASD,EAAS,OFsKtCxP,IAAK,OACLhB,MAAO,WEnKR,MAAO0Q,MAAKC,OAAM,GAAIC,OAAOC,UAAY,QFuKxC7P,IAAK,gBACLhB,MAAO,SErKI8Q,GACZ,GAAwB,mBAAbA,GAAX,CAIArS,KAAK4G,KAAK,8BAAgCyL,EAC1C,IAAIC,GAAYnK,SAASoK,eAAeF,EAExC,KAAKC,EAAW,CACd,GAAInK,SAASqK,eAAiBrK,SAASC,kBAC5B/C,OAAOoN,OAASpN,OAAOqN,UAAUC,UAAUrJ,QAAQ,kBAAqB,CACjF,GAAMsJ,GAAMzK,SAASqK,cAAc,SACnCI,GAAIC,aAAa,KAAMR,GACvBO,EAAIE,MAAMC,WAAa,SACvBH,EAAIE,MAAME,SAAW,WACrBJ,EAAIE,MAAM7K,MAAQ2K,EAAIE,MAAMvK,OAASqK,EAAIK,YAAc,MAEvDX,EAAYnK,SAAS+K,qBAAqB,QAAQ,GAAGC,YAAYP,OACxDzK,UAASG,MAAQH,SAASG,KAAK8K,oBACxCjL,SAASG,KAAK8K,mBAAmB,YAAa,iBAAmBf,EAAW,SAAWA,EAAW,mCAEhGhN,QAAOgO,QAAUhO,OAAOgO,OAAOhB,KACjCC,EAAYjN,OAAOgO,OAAOhB,IAI9B,MAAOC,OFuKN/P,IAAK,YACLhB,MAAO,SErKAgB,EAAKzB,GACb,MAAId,MAAK6C,QAAU7C,KAAK6C,OAAOyQ,eAA+C,iBAA9BtT,KAAK6C,OAAOyQ,cACrDtT,KAAKuT,yBAKVC,aAAaC,QAAQlR,EAAKzB,IAEnB,IANLd,KAAK4G,KAAK,mCACH,GASN5G,KAAK0T,2BAKVC,eAAeF,QAAQlR,EAAKzB,IACrB,IALLd,KAAK4G,KAAK,qCACH,MF4KRrE,IAAK,WACLhB,MAAO,SEtKDgB,GACP,MAAIvC,MAAK6C,QAAU7C,KAAK6C,OAAOyQ,eAA+C,iBAA9BtT,KAAK6C,OAAOyQ,cACrDtT,KAAKuT,wBAKHC,aAAaI,QAAQrR,IAJ1BvC,KAAK4G,KAAK,kCACH,MAON5G,KAAK0T,0BAKHC,eAAeC,QAAQrR,IAJ5BvC,KAAK4G,KAAK,oCACH,SF4KRrE,IAAK,wBACLhB,MAAO,WEtKR,IACE,MAAO,gBAAkB8D,SAAUA,OAAOmO,aAC1C,MAAOzK,GACP,OAAO,MF2KRxG,IAAK,0BACLhB,MAAO,WEvKR,IACE,MAAO,kBAAoB8D,SAAUA,OAAOsO,eAC5C,MAAO5K,GACP,OAAO,MF4KRxG,IAAK,eACLhB,MAAO,SEzKGT,GACX,GAAY,OAARA,GAA+B,YAAf,mBAAOA,GAAP,YAAAU,EAAOV,IACzB,MAAOA,EAGT,IAAM+S,KACN,KAAK,GAAMC,KAAQhT,GACbA,EAAI6L,eAAemH,KACrBD,EAAKC,GAAQhT,EAAIgT,GAGrB,OAAOD,MF4KNtR,IAAK,kBACLhB,MAAO,WEvKR,MAAO,iCAAmCvB,KAAK+T,iBF6K9CxR,IAAK,MACLhB,MAAO,SE3KNyS,EAAO/K,EAAS6B,GAClB,GAAIkJ,GAASC,QAAQD,MAAO,CAC1B,GAAME,IAAY,GAAI/B,OAAOgC,cACzBC,EAAmB,EAGrBA,GADEpU,KAAK6C,OAAOyO,cACK4C,EAAY,IAAMlU,KAAK6C,OAAOyO,cAAgB,IAAMtR,KAAK+T,cAAgB,IAAM/T,KAAKkD,UAAU4B,iBAAiBkP,GAAS,IAAM/K,EAE9HiL,EAAY,IAAMlU,KAAK+T,cAAgB,IAAM/T,KAAKkD,UAAU4B,iBAAiBkP,GAAS,IAAM/K,EAG7G6B,IACFsJ,GAAoB,aAAetJ,EAAMuJ,OAG3CJ,QAAQK,IAAIF,OF+Kb7R,IAAK,QACLhB,MAAO,SE5KJ0H,EAAS6B,GACb9K,KAAKsU,IAAItU,KAAKkD,UAAUwB,cAAcT,MAAOgF,EAAS6B,MF+KrDvI,IAAK,OACLhB,MAAO,SE7KL0H,GACHjJ,KAAKsU,IAAItU,KAAKkD,UAAUwB,cAAcC,KAAMsE,EAAS,SFgLpD1G,IAAK,OACLhB,MAAO,SE9KL0H,GACHjJ,KAAKsU,IAAItU,KAAKkD,UAAUwB,cAAcE,KAAMqE,EAAS,SFiLpD1G,IAAK,UACLhB,MAAO,SE/KF0H,GACNjJ,KAAKsU,IAAItU,KAAKkD,UAAUwB,cAAcG,QAASoE,EAAS,SFkLvD1G,IAAK,WACLhB,MAAO,SEhLDgK,GACPlG,OAAOiB,SAASkJ,QAAQjE,MFmLvBhJ,IAAK,WACLhB,MAAO,WEhLR,MAAO8D,QAAOoJ,QAAUpJ,OAAOoJ,SAAWpJ,UFoLzC9C,IAAK,OACLhB,MAAO,SElLLgK,EAAKD,EAAMiJ,GACd,MAAOlP,QAAOwD,KAAK0C,EAAKD,EAAMiJ,MFqL7BhS,IAAK,cACLhB,MAAO,WElLR,MAAO,aFuLDqB,IAGTjD,cE90CoBiD,EAwpCrBhC,EAAOqT,SACLD,MAAO,EACPM,IAAK,SAACrL,QF2LsBzI,KAAKb,EAAU,WAAa,MAAOK,WAI3D,SAASJ,EAAQD,GGl3CvBC,EAAAD,QAAAM","file":"salte-auth.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"uuid\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"salte-auth\", [\"uuid\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"salte-auth\"] = factory(require(\"uuid\"));\n\telse\n\t\troot[\"salte-auth\"] = factory(root[\"uuid\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","/**\n * salte-auth JavaScript Library v1.0.7\n *\n * @license MIT (https://github.com/salte-io/salte-auth/blob/master/LICENSE)\n *\n * Made with â™¥ by Ceci <admin@cecilias.me>, Dave Woodward <dave@salte.io>\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"uuid\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"salte-auth\", [\"uuid\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"salte-auth\"] = factory(require(\"uuid\"));\n\telse\n\t\troot[\"salte-auth\"] = factory(root[\"uuid\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @public\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @class Config\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @property {clientId}        Identifier assigned to your app by Azure Active Directory\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @property {redirectUri}     Endpoint at which you expect to receive tokens\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @property {instance}        This is the URL path to the identity provider that authorize and logout will be called against.\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @property {endpoints}       Collection of {Endpoint-ResourceId} used for autmatically attaching tokens in webApi calls\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @property {scope}           This may be used to define the specific authorization(s) being requested from the resource owner.\n\t                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */\n\t\n\t/**\n\t * User information from idtoken.\n\t *  @class User\n\t *  @property {string} userName - username assigned from upn, email, or sub (i.e. subject).\n\t *  @property {object} profile - properties parsed from idtoken.\n\t */\n\t\n\t/**\n\t * Creates a new AuthenticationContext object.\n\t * @constructor\n\t * @param {object}  config               Configuration options for AuthenticationContext\n\t */\n\t\n\tvar _uuid = __webpack_require__(1);\n\t\n\tvar _uuid2 = _interopRequireDefault(_uuid);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar AuthenticationContext = function () {\n\t  function AuthenticationContext(config) {\n\t    _classCallCheck(this, AuthenticationContext);\n\t\n\t    /**\n\t    * Enum for request type\n\t    * @enum {string}\n\t    */\n\t    this.REQUEST_TYPE = {\n\t      LOGIN: 'LOGIN',\n\t      RENEW_TOKEN: 'RENEW_TOKEN',\n\t      UNKNOWN: 'UNKNOWN'\n\t    };\n\t\n\t    /**\n\t    * Enum for storage constants\n\t    * @enum {string}\n\t    */\n\t    this.CONSTANTS = {\n\t      ACCESS_TOKEN: 'access_token',\n\t      EXPIRES_IN: 'expires_in',\n\t      ID_TOKEN: 'id_token',\n\t      ERROR_DESCRIPTION: 'error_description',\n\t      SESSION_STATE: 'session_state',\n\t      STORAGE: {\n\t        TOKEN_KEYS: 'auth.token.keys',\n\t        ACCESS_TOKEN_KEY: 'auth.access.token.key',\n\t        EXPIRATION_KEY: 'auth.expiration.key',\n\t        STATE_LOGIN: 'auth.state.login',\n\t        STATE_RENEW: 'auth.state.renew',\n\t        NONCE_IDTOKEN: 'auth.nonce.idtoken',\n\t        SESSION_STATE: 'auth.session.state',\n\t        USERNAME: 'auth.username',\n\t        IDTOKEN: 'auth.idtoken',\n\t        ERROR: 'auth.error',\n\t        ERROR_DESCRIPTION: 'auth.error.description',\n\t        LOGIN_REQUEST: 'auth.login.request',\n\t        LOGIN_ERROR: 'auth.login.error',\n\t        RENEW_STATUS: 'auth.token.renew.status'\n\t      },\n\t      RESOURCE_DELIMETER: '|',\n\t      LOADFRAME_TIMEOUT: '6000',\n\t      TOKEN_RENEW_STATUS_CANCELED: 'Canceled',\n\t      TOKEN_RENEW_STATUS_COMPLETED: 'Completed',\n\t      TOKEN_RENEW_STATUS_IN_PROGRESS: 'In Progress',\n\t      LOGGING_LEVEL: {\n\t        ERROR: 0,\n\t        WARN: 1,\n\t        INFO: 2,\n\t        VERBOSE: 3\n\t      },\n\t      LEVEL_STRING_MAP: {\n\t        0: 'ERROR:',\n\t        1: 'WARNING:',\n\t        2: 'INFO:',\n\t        3: 'VERBOSE:'\n\t      },\n\t      POPUP_WIDTH: 483,\n\t      POPUP_HEIGHT: 600\n\t    };\n\t\n\t    if (window.AuthenticationContext) {\n\t      return window.AuthenticationContext;\n\t    }\n\t    window.AuthenticationContext = this;\n\t\n\t    // public\n\t    this.config = {};\n\t    this.callback = null;\n\t    this.popUp = false;\n\t    this.isAngular = false;\n\t\n\t    // private\n\t    this._user = null;\n\t    this._activeRenewals = {};\n\t    this._loginInProgress = false;\n\t    this._renewStates = [];\n\t\n\t    this.callBackMappedToRenewStates = {};\n\t    this.callBacksMappedToRenewStates = {};\n\t\n\t    // validate before constructor assignments\n\t    if (config.displayCall && typeof config.displayCall !== 'function') {\n\t      throw new Error('displayCall is not a function');\n\t    }\n\t\n\t    if (!config.clientId) {\n\t      throw new Error('clientId is required');\n\t    }\n\t\n\t    this.config = this._cloneConfig(config);\n\t\n\t    if (this.config.popUp) {\n\t      this.popUp = true;\n\t    }\n\t\n\t    if (this.config.callback && typeof this.config.callback === 'function') {\n\t      this.callback = this.config.callback;\n\t    }\n\t\n\t    if (!this.config.instance || !this.config.instance.match(/^https:\\/\\/.*\\/$/)) {\n\t      throw new Error('instance must be a valid https endpoint that ends in a forward slash.');\n\t    }\n\t\n\t    // App can request idtoken for itself using clientid as resource\n\t    if (!this.config.loginResource) {\n\t      this.config.loginResource = this.config.clientId;\n\t    }\n\t\n\t    if (!this.config.redirectUri) {\n\t      this.config.redirectUri = window.location.href;\n\t    }\n\t\n\t    if (!this.config.anonymousEndpoints) {\n\t      this.config.anonymousEndpoints = [];\n\t    }\n\t\n\t    if (this.config.isAngular) {\n\t      this.isAngular = this.config.isAngular;\n\t    }\n\t\n\t    this.setResponseType(this.config.responseType);\n\t  }\n\t\n\t  _createClass(AuthenticationContext, [{\n\t    key: 'setResponseType',\n\t    value: function setResponseType(responseType) {\n\t      this.config.responseType = responseType || this.CONSTANTS.ID_TOKEN;\n\t    }\n\t\n\t    /**\n\t     * Gets initial Idtoken for the app backend\n\t     * Saves the resulting Idtoken in localStorage.\n\t     * @param {string} startPage the start page\n\t     */\n\t\n\t  }, {\n\t    key: 'login',\n\t    value: function login(startPage) {\n\t      // Token is not present and user needs to login\n\t      if (this._loginInProgress) {\n\t        this.info('Login in progress');\n\t        return;\n\t      }\n\t      var expectedState = _uuid2.default.v4();\n\t      this.config.state = expectedState;\n\t      this._idTokenNonce = _uuid2.default.v4();\n\t      if (!startPage) {\n\t        startPage = window.location;\n\t      }\n\t      this.verbose('Expected state: ' + expectedState + ' startPage:' + startPage);\n\t      this._saveItem(this.CONSTANTS.STORAGE.LOGIN_REQUEST, startPage);\n\t      this._saveItem(this.CONSTANTS.STORAGE.LOGIN_ERROR, '');\n\t      this._saveItem(this.CONSTANTS.STORAGE.STATE_LOGIN, expectedState);\n\t      this._saveItem(this.CONSTANTS.STORAGE.NONCE_IDTOKEN, this._idTokenNonce);\n\t      this._saveItem(this.CONSTANTS.STORAGE.ERROR, '');\n\t      this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, '');\n\t      var urlNavigate = this._getNavigateUrl(this.config.responseType, null) + '&nonce=' + encodeURIComponent(this._idTokenNonce);\n\t      this._loginInProgress = true;\n\t      if (this.popUp) {\n\t        this._loginPopup(urlNavigate);\n\t        return;\n\t      }\n\t      if (this.config.displayCall) {\n\t        // User defined way of handling the navigation\n\t        this.config.displayCall(urlNavigate);\n\t      } else {\n\t        this.promptUser(urlNavigate);\n\t      }\n\t    }\n\t  }, {\n\t    key: '_openPopup',\n\t    value: function _openPopup(urlNavigate, title, popUpWidth, popUpHeight) {\n\t      try {\n\t        /**\n\t        * adding winLeft and winTop to account for dual monitor\n\t        * using screenLeft and screenTop for IE8 and earlier\n\t        */\n\t        var winLeft = window.screenLeft ? window.screenLeft : window.screenX;\n\t        var winTop = window.screenTop ? window.screenTop : window.screenY;\n\t        /**\n\t        * window.innerWidth displays browser window's height and width excluding toolbars\n\t        * using document.documentElement.clientWidth for IE8 and earlier\n\t        */\n\t        var width = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;\n\t        var height = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;\n\t        var left = width / 2 - popUpWidth / 2 + winLeft;\n\t        var top = height / 2 - popUpHeight / 2 + winTop;\n\t\n\t        var popupWindow = this.open(urlNavigate, title, 'width=' + popUpWidth + ', height=' + popUpHeight + ', top=' + top + ', left=' + left);\n\t        if (popupWindow.focus) {\n\t          popupWindow.focus();\n\t        }\n\t        return popupWindow;\n\t      } catch (e) {\n\t        this.warn('Error opening popup, ' + e.message);\n\t        this._loginInProgress = false;\n\t        return null;\n\t      }\n\t    }\n\t  }, {\n\t    key: '_loginPopup',\n\t    value: function _loginPopup(urlNavigate) {\n\t      var _this = this;\n\t\n\t      var popupWindow = this._openPopup(urlNavigate, 'login', this.CONSTANTS.POPUP_WIDTH, this.CONSTANTS.POPUP_HEIGHT);\n\t      if (popupWindow === null) {\n\t        this.warn('Popup Window is null. This can happen if you are using IE');\n\t        this._saveItem(this.CONSTANTS.STORAGE.ERROR, 'Error opening popup');\n\t        this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, 'Popup Window is null. This can happen if you are using IE');\n\t        this._saveItem(this.CONSTANTS.STORAGE.LOGIN_ERROR, 'Popup Window is null. This can happen if you are using IE');\n\t        if (this.callback) {\n\t          this.callback(this._getItem(this.CONSTANTS.STORAGE.LOGIN_ERROR), null);\n\t        }\n\t        return;\n\t      }\n\t      var registeredRedirectUri = void 0;\n\t      if (this.config.redirectUri.indexOf('#') === -1) {\n\t        registeredRedirectUri = this.config.redirectUri;\n\t      } else {\n\t        registeredRedirectUri = this.config.redirectUri.split('#')[0];\n\t      }\n\t      var pollTimer = window.setInterval(function () {\n\t        if (!popupWindow || popupWindow.closed || popupWindow.closed === undefined) {\n\t          _this._loginInProgress = false;\n\t          window.clearInterval(pollTimer);\n\t        }\n\t        try {\n\t          if (popupWindow.location.href.indexOf(registeredRedirectUri) !== -1) {\n\t            if (_this.isAngular) {\n\t              window.location.hash = popupWindow.location.hash;\n\t            } else {\n\t              _this.handleWindowCallback(popupWindow.location.hash, popupWindow.location.search);\n\t            }\n\t            window.clearInterval(pollTimer);\n\t            _this._loginInProgress = false;\n\t            _this.info('Closing popup window');\n\t            popupWindow.close();\n\t          }\n\t        } catch (e) {}\n\t      }, 20);\n\t    }\n\t  }, {\n\t    key: 'loginInProgress',\n\t    value: function loginInProgress() {\n\t      return this._loginInProgress;\n\t    }\n\t  }, {\n\t    key: '_hasResource',\n\t    value: function _hasResource(key) {\n\t      var keys = this._getItem(this.CONSTANTS.STORAGE.TOKEN_KEYS);\n\t      return keys && !this._isEmpty(keys) && keys.indexOf(key + this.CONSTANTS.RESOURCE_DELIMETER) > -1;\n\t    }\n\t\n\t    /**\n\t     * Gets token for the specified resource from local storage cache\n\t     * @param {string}   resource A URI that identifies the resource for which the token is valid.\n\t     * @return {string} token if exists and not expired or null\n\t     */\n\t\n\t  }, {\n\t    key: 'getCachedToken',\n\t    value: function getCachedToken(resource) {\n\t      if (!this._hasResource(resource)) {\n\t        return null;\n\t      }\n\t\n\t      var token = this._getItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY + resource);\n\t      var expired = this._getItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY + resource);\n\t\n\t      // If expiration is within offset, it will force renew\n\t      var offset = this.config.expireOffsetSeconds || 120;\n\t\n\t      if (expired && expired > this._now() + offset) {\n\t        return token;\n\t      }\n\t      this._saveItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY + resource, '');\n\t      this._saveItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY + resource, 0);\n\t      return null;\n\t    }\n\t\n\t    /**\n\t     * Retrieves and parse idToken from localstorage\n\t     * @return {User} user object\n\t     */\n\t\n\t  }, {\n\t    key: 'getCachedUser',\n\t    value: function getCachedUser() {\n\t      if (this._user) {\n\t        return this._user;\n\t      }\n\t\n\t      var idtoken = this._getItem(this.CONSTANTS.STORAGE.IDTOKEN);\n\t      this._user = this._createUser(idtoken);\n\t      return this._user;\n\t    }\n\t  }, {\n\t    key: 'registerCallback',\n\t    value: function registerCallback(expectedState, resource, callback) {\n\t      var _this2 = this;\n\t\n\t      this._activeRenewals[resource] = expectedState;\n\t      if (!this.callBacksMappedToRenewStates[expectedState]) {\n\t        this.callBacksMappedToRenewStates[expectedState] = [];\n\t      }\n\t      this.callBacksMappedToRenewStates[expectedState].push(callback);\n\t      if (!this.callBackMappedToRenewStates[expectedState]) {\n\t        this.callBackMappedToRenewStates[expectedState] = function (message, token) {\n\t          for (var i = 0; i < _this2.callBacksMappedToRenewStates[expectedState].length; ++i) {\n\t            try {\n\t              _this2.callBacksMappedToRenewStates[expectedState][i](message, token);\n\t            } catch (error) {\n\t              _this2.warn(error);\n\t            }\n\t          }\n\t          _this2._activeRenewals[resource] = null;\n\t          _this2.callBacksMappedToRenewStates[expectedState] = null;\n\t          _this2.callBackMappedToRenewStates[expectedState] = null;\n\t        };\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Acquires access token with hidden iframe\n\t     * @param {string} resource  ResourceUri identifying the target resource\n\t     * @param {string} callback  ResourceUri identifying the target resource\n\t     */\n\t\n\t  }, {\n\t    key: '_renewToken',\n\t    value: function _renewToken(resource, callback) {\n\t      // use iframe to try refresh token\n\t      // use given resource to create new authz url\n\t      this.info('renewToken is called for resource:' + resource);\n\t      var frameHandle = this._addAuthFrame('authRenewFrame' + resource);\n\t      var expectedState = _uuid2.default.v4() + '|' + resource;\n\t      this.config.state = expectedState;\n\t      // renew happens in iframe, so it keeps javascript context\n\t      this._renewStates.push(expectedState);\n\t\n\t      this.verbose('Renew token Expected state: ' + expectedState);\n\t      var urlNavigate = this._getNavigateUrl('token', resource) + '&prompt=none';\n\t      urlNavigate = this._addHintParameters(urlNavigate);\n\t\n\t      this.registerCallback(expectedState, resource, callback);\n\t      this.verbose('Navigate to:' + urlNavigate);\n\t      this._saveItem(this.CONSTANTS.STORAGE.LOGIN_REQUEST, '');\n\t      frameHandle.src = 'about:blank';\n\t      this._loadFrameTimeout(urlNavigate, 'authRenewFrame' + resource, resource);\n\t    }\n\t  }, {\n\t    key: '_renewIdToken',\n\t    value: function _renewIdToken(callback) {\n\t      // use iframe to try refresh token\n\t      this.info('renewIdToken is called');\n\t      var frameHandle = this._addAuthFrame('authIdTokenFrame');\n\t      var expectedState = _uuid2.default.v4() + '|' + this.config.clientId;\n\t      this._idTokenNonce = _uuid2.default.v4();\n\t      this._saveItem(this.CONSTANTS.STORAGE.NONCE_IDTOKEN, this._idTokenNonce);\n\t      this.config.state = expectedState;\n\t      // renew happens in iframe, so it keeps javascript context\n\t      this._renewStates.push(expectedState);\n\t\n\t      this.verbose('Renew Idtoken Expected state: ' + expectedState);\n\t      var urlNavigate = this._getNavigateUrl(this.config.responseType, null) + '&prompt=none';\n\t      urlNavigate = this._addHintParameters(urlNavigate);\n\t\n\t      urlNavigate += '&nonce=' + encodeURIComponent(this._idTokenNonce);\n\t      this.registerCallback(expectedState, this.config.clientId, callback);\n\t      this.idTokenNonce = null;\n\t      this.verbose('Navigate to:' + urlNavigate);\n\t      this._saveItem(this.CONSTANTS.STORAGE.LOGIN_REQUEST, '');\n\t      frameHandle.src = 'about:blank';\n\t      this._loadFrameTimeout(urlNavigate, 'authIdTokenFrame', this.config.clientId);\n\t    }\n\t  }, {\n\t    key: '_urlContainsQueryStringParameter',\n\t    value: function _urlContainsQueryStringParameter(name, url) {\n\t      // regex to detect pattern of a ? or & followed by the name parameter and an equals character\n\t      var regex = new RegExp('[\\\\?&]' + name + '=');\n\t      return regex.test(url);\n\t    }\n\t\n\t    // Calling _loadFrame but with a timeout to signal failure in loadframeStatus. Callbacks are left\n\t    // registered when network errors occur and subsequent token requests for same resource are registered to the pending request\n\t\n\t  }, {\n\t    key: '_loadFrameTimeout',\n\t    value: function _loadFrameTimeout(urlNavigation, frameName, resource) {\n\t      var _this3 = this;\n\t\n\t      // set iframe session to pending\n\t      this.verbose('Set loading state to pending for: ' + resource);\n\t      this._saveItem(this.CONSTANTS.STORAGE.RENEW_STATUS + resource, this.CONSTANTS.TOKEN_RENEW_STATUS_IN_PROGRESS);\n\t      this._loadFrame(urlNavigation, frameName);\n\t      setTimeout(function () {\n\t        if (_this3._getItem(_this3.CONSTANTS.STORAGE.RENEW_STATUS + resource) === _this3.CONSTANTS.TOKEN_RENEW_STATUS_IN_PROGRESS) {\n\t          // fail the iframe session if it's in pending state\n\t          _this3.verbose('Loading frame has timed out after: ' + _this3.CONSTANTS.LOADFRAME_TIMEOUT / 1000 + ' seconds for resource ' + resource);\n\t          var expectedState = _this3._activeRenewals[resource];\n\t\n\t          _this3._saveItem(_this3.CONSTANTS.STORAGE.RENEW_STATUS + resource, _this3.CONSTANTS.TOKEN_RENEW_STATUS_CANCELED);\n\t\n\t          if (expectedState && _this3.callBackMappedToRenewStates[expectedState]) {\n\t            _this3.callBackMappedToRenewStates[expectedState]('Token renewal operation failed due to timeout', null);\n\t          }\n\t        }\n\t      }, this.CONSTANTS.LOADFRAME_TIMEOUT);\n\t    }\n\t  }, {\n\t    key: '_loadFrame',\n\t    value: function _loadFrame(urlNavigate, frameName) {\n\t      var _this4 = this;\n\t\n\t      // This trick overcomes iframe navigation in IE\n\t      // IE does not load the page consistently in iframe\n\t      this.info('LoadFrame: ' + frameName);\n\t      var frameCheck = frameName;\n\t      setTimeout(function () {\n\t        var frameHandle = _this4._addAuthFrame(frameCheck);\n\t        if (frameHandle.src === '' || frameHandle.src === 'about:blank') {\n\t          frameHandle.src = urlNavigate;\n\t          _this4._loadFrame(urlNavigate, frameCheck);\n\t        }\n\t      }, 500);\n\t    }\n\t\n\t    /**\n\t     * Acquire token from cache if not expired and available. Acquires token from iframe if expired.\n\t     * @param {string} resource  ResourceUri identifying the target resource\n\t     * @param {function} callback The callback function\n\t     */\n\t\n\t  }, {\n\t    key: 'acquireToken',\n\t    value: function acquireToken(resource, callback) {\n\t      if (this._isEmpty(resource)) {\n\t        this.warn('resource is required');\n\t        callback('resource is required', null);\n\t        return;\n\t      }\n\t\n\t      var token = this.getCachedToken(resource);\n\t      if (token) {\n\t        this.info('Token is already in cache for resource:' + resource);\n\t        callback(null, token);\n\t        return;\n\t      }\n\t\n\t      if (!this._user) {\n\t        this.warn('User login is required');\n\t        callback('User login is required', null);\n\t        return;\n\t      }\n\t\n\t      // refresh attept with iframe\n\t      // Already renewing for this resource, callback when we get the token.\n\t      if (this._activeRenewals[resource]) {\n\t        // Active renewals contains the state for each renewal.\n\t        this.registerCallback(this._activeRenewals[resource], resource, callback);\n\t      } else if (resource === this.config.clientId) {\n\t        // App uses idtoken to send to api endpoints\n\t        // Default resource is tracked as clientid to store this token\n\t        this.verbose('renewing idtoken');\n\t        this._renewIdToken(callback);\n\t      } else {\n\t        this._renewToken(resource, callback);\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Redirect the Browser to Azure AD Authorization endpoint\n\t     * @param {string} urlNavigate The authorization request url\n\t     */\n\t\n\t  }, {\n\t    key: 'promptUser',\n\t    value: function promptUser(urlNavigate) {\n\t      if (urlNavigate) {\n\t        this.info('Navigate to:' + urlNavigate);\n\t        this.navigate(urlNavigate);\n\t      } else {\n\t        this.info('Navigate url is empty');\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Clear cache items.\n\t     */\n\t\n\t  }, {\n\t    key: 'clearCache',\n\t    value: function clearCache() {\n\t      this._saveItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY, '');\n\t      this._saveItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY, 0);\n\t      this._saveItem(this.CONSTANTS.STORAGE.SESSION_STATE, '');\n\t      this._saveItem(this.CONSTANTS.STORAGE.STATE_LOGIN, '');\n\t      this._renewStates = [];\n\t      this._saveItem(this.CONSTANTS.STORAGE.USERNAME, '');\n\t      this._saveItem(this.CONSTANTS.STORAGE.IDTOKEN, '');\n\t      this._saveItem(this.CONSTANTS.STORAGE.ERROR, '');\n\t      this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, '');\n\t      var keys = this._getItem(this.CONSTANTS.STORAGE.TOKEN_KEYS);\n\t\n\t      if (!this._isEmpty(keys)) {\n\t        keys = keys.split(this.CONSTANTS.RESOURCE_DELIMETER);\n\t        for (var i = 0; i < keys.length; i++) {\n\t          this._saveItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY + keys[i], '');\n\t          this._saveItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY + keys[i], 0);\n\t        }\n\t      }\n\t      this._saveItem(this.CONSTANTS.STORAGE.TOKEN_KEYS, '');\n\t    }\n\t\n\t    /**\n\t     * Clear cache items for a resource.\n\t     * @param {string} resource The resource\n\t     */\n\t\n\t  }, {\n\t    key: 'clearCacheForResource',\n\t    value: function clearCacheForResource(resource) {\n\t      this._saveItem(this.CONSTANTS.STORAGE.STATE_RENEW, '');\n\t      this._saveItem(this.CONSTANTS.STORAGE.ERROR, '');\n\t      this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, '');\n\t      if (this._hasResource(resource)) {\n\t        this._saveItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY + resource, '');\n\t        this._saveItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY + resource, 0);\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Logout user will redirect page to logout endpoint.\n\t     * After logout, it will redirect to post_logout page if provided.\n\t     */\n\t\n\t  }, {\n\t    key: 'logOut',\n\t    value: function logOut() {\n\t      this.clearCache();\n\t      var logout = '';\n\t      this._user = null;\n\t\n\t      if (this.config.postLogoutRedirectUri) {\n\t        logout = 'post_logout_redirect_uri=' + encodeURIComponent(this.config.postLogoutRedirectUri);\n\t      }\n\t\n\t      var urlNavigate = this.config.instance + 'logout?' + logout;\n\t      this.info('Logout navigate to: ' + urlNavigate);\n\t      this.promptUser(urlNavigate);\n\t    }\n\t  }, {\n\t    key: '_isEmpty',\n\t    value: function _isEmpty(str) {\n\t      return typeof str === 'undefined' || !str || str.length === 0;\n\t    }\n\t\n\t    /**\n\t     * Gets a user profile\n\t     * @param {requestCallback} callback The callback that handles the response.\n\t     */\n\t\n\t  }, {\n\t    key: 'getUser',\n\t    value: function getUser(callback) {\n\t      // IDToken is first call\n\t      if (typeof callback !== 'function') {\n\t        throw new Error('callback is not a function');\n\t      }\n\t\n\t      // user in memory\n\t      if (this._user) {\n\t        callback(null, this._user);\n\t        return;\n\t      }\n\t\n\t      // frame is used to get idtoken\n\t      var idtoken = this._getItem(this.CONSTANTS.STORAGE.IDTOKEN);\n\t      if (this._isEmpty(idtoken)) {\n\t        this.warn('User information is not available');\n\t        callback('User information is not available');\n\t      } else {\n\t        this.info('User exists in cache: ');\n\t        this._user = this._createUser(idtoken);\n\t        callback(null, this._user);\n\t      }\n\t    }\n\t  }, {\n\t    key: '_addHintParameters',\n\t    value: function _addHintParameters(urlNavigate) {\n\t      // include hint params only if upn is present\n\t      if (this._user && this._user.profile && this._user.profile.hasOwnProperty('upn')) {\n\t        // add login_hint\n\t        urlNavigate += '&login_hint=' + encodeURIComponent(this._user.profile.upn);\n\t\n\t        // don't add domain_hint twice if user provided it in the extraQueryParameter value\n\t        if (!this._urlContainsQueryStringParameter('domain_hint', urlNavigate) && this._user.profile.upn.indexOf('@') > -1) {\n\t          var parts = this._user.profile.upn.split('@');\n\t          // local part can include @ in quotes. Sending last part handles that.\n\t          urlNavigate += '&domain_hint=' + encodeURIComponent(parts[parts.length - 1]);\n\t        }\n\t      }\n\t\n\t      return urlNavigate;\n\t    }\n\t  }, {\n\t    key: '_createUser',\n\t    value: function _createUser(idToken) {\n\t      var user = null;\n\t      var parsedJson = this._extractIdToken(idToken);\n\t      if (parsedJson && parsedJson.hasOwnProperty('aud')) {\n\t        var audienceMatch = false;\n\t\n\t        if (Array.isArray(parsedJson.aud)) {\n\t          // If the ID Token contains multiple audiences then an azp claim must be present and equal to the client id.\n\t          if (parsedJson.hasOwnProperty('azp') && parsedJson.azp.toLowerCase() === this.config.clientId.toLowerCase()) {\n\t            for (var i = 0; i < parsedJson.aud.length; i++) {\n\t              if (parsedJson.aud[i].toLowerCase() === this.config.clientId.toLowerCase()) {\n\t                audienceMatch = true;\n\t                break;\n\t              }\n\t            }\n\t          }\n\t        } else {\n\t          audienceMatch = parsedJson.aud.toLowerCase() === this.config.clientId.toLowerCase();\n\t        }\n\t\n\t        if (audienceMatch) {\n\t          user = {\n\t            userName: '',\n\t            profile: parsedJson\n\t          };\n\t\n\t          if (parsedJson.hasOwnProperty('upn')) {\n\t            user.userName = parsedJson.upn;\n\t          } else if (parsedJson.hasOwnProperty('email')) {\n\t            user.userName = parsedJson.email;\n\t          } else if (parsedJson.hasOwnProperty('sub')) {\n\t            user.userName = parsedJson.sub;\n\t          }\n\t        } else {\n\t          this.warn('IdToken has invalid aud/azp field');\n\t        }\n\t      }\n\t\n\t      return user;\n\t    }\n\t  }, {\n\t    key: '_getHash',\n\t    value: function _getHash(hash) {\n\t      if (hash.indexOf('#/') > -1) {\n\t        hash = hash.substring(hash.indexOf('#/') + 2);\n\t      } else if (hash.indexOf('#') > -1) {\n\t        hash = hash.substring(1);\n\t      }\n\t\n\t      return hash;\n\t    }\n\t  }, {\n\t    key: '_getSearch',\n\t    value: function _getSearch(search) {\n\t      if (search.indexOf('?') > -1) {\n\t        search = search.substring(1);\n\t      }\n\t\n\t      return search;\n\t    }\n\t  }, {\n\t    key: '_getParameters',\n\t    value: function _getParameters(hash, search) {\n\t      var parameters = {};\n\t\n\t      if (hash) {\n\t        hash = this._getHash(hash);\n\t        parameters = this._deserialize(hash);\n\t      }\n\t\n\t      if (search) {\n\t        search = this._getSearch(search);\n\t        var searchParameters = this._deserialize(search);\n\t        parameters = this._extend(parameters, searchParameters);\n\t      }\n\t\n\t      return parameters;\n\t    }\n\t  }, {\n\t    key: '_extend',\n\t    value: function _extend(obj, src) {\n\t      for (var key in src) {\n\t        if (src.hasOwnProperty(key)) {\n\t          obj[key] = src[key];\n\t        }\n\t      }\n\t      return obj;\n\t    }\n\t\n\t    /**\n\t     * Checks if hash contains access token or id token or error_description\n\t     * @param {string} hash  -  Hash passed from redirect page\n\t     * @param {string} search  -  Search passed from redirect page\n\t     * @return {boolean} exists if all the parameters exist\n\t     */\n\t\n\t  }, {\n\t    key: 'isCallback',\n\t    value: function isCallback(hash, search) {\n\t      var parameters = this._getParameters(hash, search);\n\t\n\t      return parameters.hasOwnProperty(this.CONSTANTS.ERROR_DESCRIPTION) || parameters.hasOwnProperty(this.CONSTANTS.ACCESS_TOKEN) || parameters.hasOwnProperty(this.CONSTANTS.ID_TOKEN);\n\t    }\n\t\n\t    /**\n\t     * Gets login error\n\t     * @return {string} error message related to login\n\t     */\n\t\n\t  }, {\n\t    key: 'getLoginError',\n\t    value: function getLoginError() {\n\t      return this._getItem(this.CONSTANTS.STORAGE.LOGIN_ERROR);\n\t    }\n\t\n\t    /**\n\t     * Gets requestInfo from given hash.\n\t     * @param {string} hash  -  Hash passed from redirect page\n\t     * @param {string} search  -  Search passed from redirect page\n\t     * @return {string} error message related to login\n\t     */\n\t\n\t  }, {\n\t    key: 'getRequestInfo',\n\t    value: function getRequestInfo(hash, search) {\n\t      var parameters = this._getParameters(hash, search);\n\t      var requestInfo = {\n\t        valid: false,\n\t        parameters: {},\n\t        stateMatch: false,\n\t        stateResponse: '',\n\t        requestType: this.REQUEST_TYPE.UNKNOWN\n\t      };\n\t\n\t      if (parameters) {\n\t        requestInfo.parameters = parameters;\n\t        if (parameters.hasOwnProperty(this.CONSTANTS.ERROR_DESCRIPTION) || parameters.hasOwnProperty(this.CONSTANTS.ACCESS_TOKEN) || parameters.hasOwnProperty(this.CONSTANTS.ID_TOKEN)) {\n\t          requestInfo.valid = true;\n\t\n\t          // which call\n\t          var stateResponse = '';\n\t          if (parameters.hasOwnProperty('state')) {\n\t            this.verbose('State: ' + parameters.state);\n\t            stateResponse = parameters.state;\n\t          } else {\n\t            this.warn('No state returned');\n\t            return requestInfo;\n\t          }\n\t\n\t          requestInfo.stateResponse = stateResponse;\n\t\n\t          // async calls can fire iframe and login request at the same time if developer does not use the API as expected\n\t          // incoming callback needs to be looked up to find the request type\n\t          if (stateResponse === this._getItem(this.CONSTANTS.STORAGE.STATE_LOGIN)) {\n\t            requestInfo.requestType = this.REQUEST_TYPE.LOGIN;\n\t            requestInfo.stateMatch = true;\n\t            return requestInfo;\n\t          }\n\t\n\t          // external api requests may have many renewtoken requests for different resource\n\t          if (!requestInfo.stateMatch && window.parent && window.parent.AuthenticationContext) {\n\t            var statesInParentContext = window.parent.AuthenticationContext._renewStates;\n\t            for (var i = 0; i < statesInParentContext.length; i++) {\n\t              if (statesInParentContext[i] === requestInfo.stateResponse) {\n\t                requestInfo.requestType = this.REQUEST_TYPE.RENEW_TOKEN;\n\t                requestInfo.stateMatch = true;\n\t                break;\n\t              }\n\t            }\n\t          }\n\t        }\n\t      }\n\t\n\t      return requestInfo;\n\t    }\n\t  }, {\n\t    key: '_getResourceFromState',\n\t    value: function _getResourceFromState(state) {\n\t      if (state) {\n\t        var splitIndex = state.indexOf('|');\n\t        if (splitIndex > -1 && splitIndex + 1 < state.length) {\n\t          return state.substring(splitIndex + 1);\n\t        }\n\t      }\n\t\n\t      return '';\n\t    }\n\t\n\t    /**\n\t     * Saves token from hash that is received from redirect.\n\t     * @param {string} requestInfo Hash passed from redirect page\n\t     */\n\t\n\t  }, {\n\t    key: 'saveTokenFromHash',\n\t    value: function saveTokenFromHash(requestInfo) {\n\t      this.info('State status:' + requestInfo.stateMatch + '; Request type:' + requestInfo.requestType);\n\t      this._saveItem(this.CONSTANTS.STORAGE.ERROR, '');\n\t      this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, '');\n\t\n\t      var resource = this._getResourceFromState(requestInfo.stateResponse);\n\t\n\t      // Record error\n\t      if (requestInfo.parameters.hasOwnProperty(this.CONSTANTS.ERROR_DESCRIPTION)) {\n\t        this.info('Error :' + requestInfo.parameters.error + '; Error description:' + requestInfo.parameters[this.CONSTANTS.ERROR_DESCRIPTION]);\n\t        this._saveItem(this.CONSTANTS.STORAGE.ERROR, requestInfo.parameters.error);\n\t        this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, requestInfo.parameters[this.CONSTANTS.ERROR_DESCRIPTION]);\n\t\n\t        if (requestInfo.requestType === this.REQUEST_TYPE.LOGIN) {\n\t          this._loginInProgress = false;\n\t          this._saveItem(this.CONSTANTS.STORAGE.LOGIN_ERROR, requestInfo.parameters.error_description);\n\t        }\n\t      } else if (requestInfo.stateMatch) {\n\t        // record tokens to storage if exists\n\t        this.info('State is right');\n\t        if (requestInfo.parameters.hasOwnProperty(this.CONSTANTS.SESSION_STATE)) {\n\t          this._saveItem(this.CONSTANTS.STORAGE.SESSION_STATE, requestInfo.parameters[this.CONSTANTS.SESSION_STATE]);\n\t        }\n\t\n\t        var keys = void 0;\n\t\n\t        if (requestInfo.parameters.hasOwnProperty(this.CONSTANTS.ACCESS_TOKEN)) {\n\t          this.info('Fragment has access token');\n\t\n\t          if (!this._hasResource(resource)) {\n\t            keys = this._getItem(this.CONSTANTS.STORAGE.TOKEN_KEYS) || '';\n\t            this._saveItem(this.CONSTANTS.STORAGE.TOKEN_KEYS, keys + resource + this.CONSTANTS.RESOURCE_DELIMETER);\n\t          }\n\t          // save token with related resource\n\t          this._saveItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY + resource, requestInfo.parameters[this.CONSTANTS.ACCESS_TOKEN]);\n\t          this._saveItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY + resource, this._expiresIn(requestInfo.parameters[this.CONSTANTS.EXPIRES_IN]));\n\t        }\n\t\n\t        if (requestInfo.parameters.hasOwnProperty(this.CONSTANTS.ID_TOKEN)) {\n\t          this.info('Fragment has id token');\n\t          this._loginInProgress = false;\n\t\n\t          this._user = this._createUser(requestInfo.parameters[this.CONSTANTS.ID_TOKEN]);\n\t\n\t          if (this._user && this._user.profile) {\n\t            if (this._user.profile.nonce === this._getItem(this.CONSTANTS.STORAGE.NONCE_IDTOKEN)) {\n\t              this._saveItem(this.CONSTANTS.STORAGE.IDTOKEN, requestInfo.parameters[this.CONSTANTS.ID_TOKEN]);\n\t\n\t              // Save idtoken as access token for app itself\n\t              resource = this.config.loginResource ? this.config.loginResource : this.config.clientId;\n\t\n\t              if (!this._hasResource(resource)) {\n\t                keys = this._getItem(this.CONSTANTS.STORAGE.TOKEN_KEYS) || '';\n\t                this._saveItem(this.CONSTANTS.STORAGE.TOKEN_KEYS, keys + resource + this.CONSTANTS.RESOURCE_DELIMETER);\n\t              }\n\t              this._saveItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY + resource, requestInfo.parameters[this.CONSTANTS.ID_TOKEN]);\n\t              this._saveItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY + resource, this._user.profile.exp);\n\t            } else {\n\t              this._user = null;\n\t              this._saveItem(this.CONSTANTS.STORAGE.LOGIN_ERROR, 'Nonce is not same as ' + this._idTokenNonce);\n\t            }\n\t          } else {\n\t            this._saveItem(this.CONSTANTS.STORAGE.ERROR, 'invalid id_token');\n\t            this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, 'Invalid id_token. id_token: ' + requestInfo.parameters[this.CONSTANTS.ID_TOKEN]);\n\t          }\n\t        }\n\t      } else {\n\t        this._saveItem(this.CONSTANTS.STORAGE.ERROR, 'Invalid_state');\n\t        this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, 'Invalid_state. state: ' + requestInfo.stateResponse);\n\t      }\n\t      this._saveItem(this.CONSTANTS.STORAGE.RENEW_STATUS + resource, this.CONSTANTS.TOKEN_RENEW_STATUS_COMPLETED);\n\t    }\n\t\n\t    /**\n\t     * Gets resource for given endpoint if mapping is provided with config.\n\t     * @param {string} endpoint API endpoint\n\t     * @return {string} resource for this API endpoint\n\t     */\n\t\n\t  }, {\n\t    key: 'getResourceForEndpoint',\n\t    value: function getResourceForEndpoint(endpoint) {\n\t      if (this.config && this.config.endpoints) {\n\t        for (var configEndpoint in this.config.endpoints) {\n\t          // configEndpoint is like /api/Todo requested endpoint can be /api/Todo/1\n\t          if (endpoint.indexOf(configEndpoint) > -1) {\n\t            return this.config.endpoints[configEndpoint];\n\t          }\n\t        }\n\t      }\n\t\n\t      // default resource will be clientid if nothing specified\n\t      // App will use idtoken for calls to itself\n\t      // check if it's staring from http or https, needs to match with app host\n\t      if (endpoint.indexOf('http://') > -1 || endpoint.indexOf('https://') > -1) {\n\t        if (this._getHostFromUri(endpoint) === this._getHostFromUri(this.config.redirectUri)) {\n\t          return this.config.loginResource;\n\t        }\n\t      } else {\n\t        // in angular level, the url for $http interceptor call could be relative url,\n\t        // if it's relative call, we'll treat it as app backend call.\n\t        // if user specified list of anonymous endpoints, no need to send token to these endpoints, return null.\n\t        if (this.config && this.config.anonymousEndpoints) {\n\t          for (var i = 0; i < this.config.anonymousEndpoints.length; i++) {\n\t            if (endpoint.indexOf(this.config.anonymousEndpoints[i]) > -1) {\n\t              return null;\n\t            }\n\t          }\n\t        }\n\t        // all other app's backend calls are secured.\n\t        return this.config.loginResource;\n\t      }\n\t\n\t      // if not the app's own backend or not a domain listed in the endpoints structure\n\t      return null;\n\t    }\n\t  }, {\n\t    key: '_getHostFromUri',\n\t    value: function _getHostFromUri(uri) {\n\t      // remove http:// or https:// from uri\n\t      var extractedUri = String(uri).replace(/^(https?:)\\/\\//, '');\n\t\n\t      extractedUri = extractedUri.split('/')[0];\n\t      return extractedUri;\n\t    }\n\t\n\t    /* exported  oauth2Callback */\n\t\n\t  }, {\n\t    key: 'handleWindowCallback',\n\t    value: function handleWindowCallback(hash, search) {\n\t      // This is for regular javascript usage for redirect handling\n\t      // need to make sure this is for callback\n\t      if (!hash) {\n\t        hash = window.location.hash;\n\t      }\n\t\n\t      if (!search) {\n\t        search = window.location.search;\n\t      }\n\t\n\t      if (this.isCallback(hash, search)) {\n\t        var requestInfo = this.getRequestInfo(hash, search);\n\t        this.info('Returned from redirect url');\n\t        this.saveTokenFromHash(requestInfo);\n\t        var callback = null;\n\t        if (requestInfo.requestType === this.REQUEST_TYPE.RENEW_TOKEN && this.isIframe()) {\n\t          // iframe call but same single page\n\t          this.verbose('Window is in iframe');\n\t          callback = window.parent.AuthenticationContext.callBackMappedToRenewStates[requestInfo.stateResponse];\n\t          if (callback) {\n\t            callback(this._getItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION), requestInfo.parameters[this.CONSTANTS.ACCESS_TOKEN] || requestInfo.parameters[this.CONSTANTS.ID_TOKEN]);\n\t          }\n\t          return;\n\t        } else if (requestInfo.requestType === this.REQUEST_TYPE.LOGIN) {\n\t          callback = this.callback;\n\t          if (callback) {\n\t            callback(this._getItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION), requestInfo.parameters[this.CONSTANTS.ID_TOKEN]);\n\t          }\n\t        }\n\t        // No need to redirect user in case of popup\n\t        if (!this.popUp) {\n\t          this.navigate(this._getItem(this.CONSTANTS.STORAGE.LOGIN_REQUEST));\n\t        }\n\t      }\n\t    }\n\t  }, {\n\t    key: '_getNavigateUrl',\n\t    value: function _getNavigateUrl(responseType, resource) {\n\t      var urlNavigate = this.config.instance + 'authorize' + this._serialize(responseType, this.config, resource) + this._addLibMetadata();\n\t      if (this.config.scope) {\n\t        urlNavigate += '&scope=' + encodeURIComponent(this.config.scope);\n\t      }\n\t      this.info('Navigate url:' + urlNavigate);\n\t      return urlNavigate;\n\t    }\n\t  }, {\n\t    key: '_extractIdToken',\n\t    value: function _extractIdToken(encodedIdToken) {\n\t      // id token will be decoded to get the username\n\t      var decodedToken = this._decodeJwt(encodedIdToken);\n\t      if (!decodedToken) {\n\t        return null;\n\t      }\n\t\n\t      try {\n\t        var base64IdToken = decodedToken.JWSPayload;\n\t        var base64Decoded = this._base64DecodeStringUrlSafe(base64IdToken);\n\t        if (!base64Decoded) {\n\t          this.info('The returned id_token could not be base64 url safe decoded.');\n\t          return null;\n\t        }\n\t\n\t        return JSON.parse(base64Decoded);\n\t      } catch (err) {\n\t        this.error('The returned id_token could not be decoded', err);\n\t      }\n\t\n\t      return null;\n\t    }\n\t  }, {\n\t    key: '_base64DecodeStringUrlSafe',\n\t    value: function _base64DecodeStringUrlSafe(base64IdToken) {\n\t      base64IdToken = base64IdToken.replace(/-/g, '+').replace(/_/g, '/');\n\t      return decodeURIComponent(escape(window.atob(base64IdToken)));\n\t    }\n\t\n\t    // Auth.node js crack function\n\t\n\t  }, {\n\t    key: '_decodeJwt',\n\t    value: function _decodeJwt(jwtToken) {\n\t      if (this._isEmpty(jwtToken)) {\n\t        return null;\n\t      }\n\t\n\t      var idTokenPartsRegex = /^([^\\.\\s]*)\\.([^\\.\\s]+)\\.([^\\.\\s]*)$/;\n\t\n\t      var matches = idTokenPartsRegex.exec(jwtToken);\n\t      if (!matches || matches.length < 4) {\n\t        this.warn('The returned id_token is not parseable.');\n\t        return null;\n\t      }\n\t\n\t      var crackedToken = {\n\t        header: matches[1],\n\t        JWSPayload: matches[2],\n\t        JWSSig: matches[3]\n\t      };\n\t\n\t      return crackedToken;\n\t    }\n\t  }, {\n\t    key: '_convertUrlSafeToRegularBase64EncodedString',\n\t    value: function _convertUrlSafeToRegularBase64EncodedString(str) {\n\t      return str.replace('-', '+').replace('_', '/');\n\t    }\n\t  }, {\n\t    key: '_serialize',\n\t    value: function _serialize(responseType, obj, resource) {\n\t      var str = [];\n\t      if (obj !== null) {\n\t        str.push('?response_type=' + encodeURIComponent(responseType));\n\t        str.push('client_id=' + encodeURIComponent(obj.clientId));\n\t        if (resource) {\n\t          str.push('resource=' + encodeURIComponent(resource));\n\t        }\n\t\n\t        str.push('redirect_uri=' + encodeURIComponent(obj.redirectUri));\n\t        str.push('state=' + encodeURIComponent(obj.state));\n\t\n\t        if (obj.hasOwnProperty('slice')) {\n\t          str.push('slice=' + encodeURIComponent(obj.slice));\n\t        }\n\t\n\t        if (obj.hasOwnProperty('extraQueryParameter')) {\n\t          str.push(obj.extraQueryParameter);\n\t        }\n\t\n\t        var correlationId = obj.correlationId ? obj.correlationId : _uuid2.default.v4();\n\t        str.push('client-request-id=' + encodeURIComponent(correlationId));\n\t      }\n\t\n\t      return str.join('&');\n\t    }\n\t  }, {\n\t    key: '_deserialize',\n\t    value: function _deserialize(query) {\n\t      var pl = /\\+/g; // Regex for replacing addition symbol with a space\n\t      var search = /([^&=]+)=([^&]*)/g;\n\t      var decode = function decode(s) {\n\t        return decodeURIComponent(s.replace(pl, ' '));\n\t      };\n\t      var obj = {};\n\t      var match = search.exec(query);\n\t      while (match) {\n\t        obj[decode(match[1])] = decode(match[2]);\n\t        match = search.exec(query);\n\t      }\n\t\n\t      return obj;\n\t    }\n\t  }, {\n\t    key: '_decimalToHex',\n\t    value: function _decimalToHex(number) {\n\t      var hex = number.toString(16);\n\t      while (hex.length < 2) {\n\t        hex = '0' + hex;\n\t      }\n\t      return hex;\n\t    }\n\t  }, {\n\t    key: '_expiresIn',\n\t    value: function _expiresIn(expires) {\n\t      return this._now() + parseInt(expires, 10);\n\t    }\n\t  }, {\n\t    key: '_now',\n\t    value: function _now() {\n\t      return Math.round(new Date().getTime() / 1000.0);\n\t    }\n\t  }, {\n\t    key: '_addAuthFrame',\n\t    value: function _addAuthFrame(iframeId) {\n\t      if (typeof iframeId === 'undefined') {\n\t        return;\n\t      }\n\t\n\t      this.info('Add auth frame to document:' + iframeId);\n\t      var authFrame = document.getElementById(iframeId);\n\t\n\t      if (!authFrame) {\n\t        if (document.createElement && document.documentElement && (window.opera || window.navigator.userAgent.indexOf('MSIE 5.0') === -1)) {\n\t          var ifr = document.createElement('iframe');\n\t          ifr.setAttribute('id', iframeId);\n\t          ifr.style.visibility = 'hidden';\n\t          ifr.style.position = 'absolute';\n\t          ifr.style.width = ifr.style.height = ifr.borderWidth = '0px';\n\t\n\t          authFrame = document.getElementsByTagName('body')[0].appendChild(ifr);\n\t        } else if (document.body && document.body.insertAdjacentHTML) {\n\t          document.body.insertAdjacentHTML('beforeEnd', '<iframe name=\"' + iframeId + '\" id=\"' + iframeId + '\" style=\"display:none\"></iframe>');\n\t        }\n\t        if (window.frames && window.frames[iframeId]) {\n\t          authFrame = window.frames[iframeId];\n\t        }\n\t      }\n\t\n\t      return authFrame;\n\t    }\n\t  }, {\n\t    key: '_saveItem',\n\t    value: function _saveItem(key, obj) {\n\t      if (this.config && this.config.cacheLocation && this.config.cacheLocation === 'localStorage') {\n\t        if (!this._supportsLocalStorage()) {\n\t          this.info('Local storage is not supported');\n\t          return false;\n\t        }\n\t\n\t        localStorage.setItem(key, obj);\n\t\n\t        return true;\n\t      }\n\t\n\t      // Default as session storage\n\t      if (!this._supportsSessionStorage()) {\n\t        this.info('Session storage is not supported');\n\t        return false;\n\t      }\n\t\n\t      sessionStorage.setItem(key, obj);\n\t      return true;\n\t    }\n\t  }, {\n\t    key: '_getItem',\n\t    value: function _getItem(key) {\n\t      if (this.config && this.config.cacheLocation && this.config.cacheLocation === 'localStorage') {\n\t        if (!this._supportsLocalStorage()) {\n\t          this.info('Local storage is not supported');\n\t          return null;\n\t        }\n\t\n\t        return localStorage.getItem(key);\n\t      }\n\t\n\t      // Default as session storage\n\t      if (!this._supportsSessionStorage()) {\n\t        this.info('Session storage is not supported');\n\t        return null;\n\t      }\n\t\n\t      return sessionStorage.getItem(key);\n\t    }\n\t  }, {\n\t    key: '_supportsLocalStorage',\n\t    value: function _supportsLocalStorage() {\n\t      try {\n\t        return 'localStorage' in window && window.localStorage;\n\t      } catch (e) {\n\t        return false;\n\t      }\n\t    }\n\t  }, {\n\t    key: '_supportsSessionStorage',\n\t    value: function _supportsSessionStorage() {\n\t      try {\n\t        return 'sessionStorage' in window && window.sessionStorage;\n\t      } catch (e) {\n\t        return false;\n\t      }\n\t    }\n\t  }, {\n\t    key: '_cloneConfig',\n\t    value: function _cloneConfig(obj) {\n\t      if (obj === null || (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object') {\n\t        return obj;\n\t      }\n\t\n\t      var copy = {};\n\t      for (var attr in obj) {\n\t        if (obj.hasOwnProperty(attr)) {\n\t          copy[attr] = obj[attr];\n\t        }\n\t      }\n\t      return copy;\n\t    }\n\t  }, {\n\t    key: '_addLibMetadata',\n\t    value: function _addLibMetadata() {\n\t      // x-client-SKU\n\t      // x-client-Ver\n\t      return '&x-client-SKU=Js&x-client-Ver=' + this._libVersion();\n\t    }\n\t  }, {\n\t    key: 'log',\n\t    value: function log(level, message, error) {\n\t      if (level <= Logging.level) {\n\t        var timestamp = new Date().toUTCString();\n\t        var formattedMessage = '';\n\t\n\t        if (this.config.correlationId) {\n\t          formattedMessage = timestamp + ':' + this.config.correlationId + '-' + this._libVersion() + '-' + this.CONSTANTS.LEVEL_STRING_MAP[level] + ' ' + message;\n\t        } else {\n\t          formattedMessage = timestamp + ':' + this._libVersion() + '-' + this.CONSTANTS.LEVEL_STRING_MAP[level] + ' ' + message;\n\t        }\n\t\n\t        if (error) {\n\t          formattedMessage += '\\nstack:\\n' + error.stack;\n\t        }\n\t\n\t        Logging.log(formattedMessage);\n\t      }\n\t    }\n\t  }, {\n\t    key: 'error',\n\t    value: function error(message, _error) {\n\t      this.log(this.CONSTANTS.LOGGING_LEVEL.ERROR, message, _error);\n\t    }\n\t  }, {\n\t    key: 'warn',\n\t    value: function warn(message) {\n\t      this.log(this.CONSTANTS.LOGGING_LEVEL.WARN, message, null);\n\t    }\n\t  }, {\n\t    key: 'info',\n\t    value: function info(message) {\n\t      this.log(this.CONSTANTS.LOGGING_LEVEL.INFO, message, null);\n\t    }\n\t  }, {\n\t    key: 'verbose',\n\t    value: function verbose(message) {\n\t      this.log(this.CONSTANTS.LOGGING_LEVEL.VERBOSE, message, null);\n\t    }\n\t  }, {\n\t    key: 'navigate',\n\t    value: function navigate(url) {\n\t      window.location.replace(url);\n\t    }\n\t  }, {\n\t    key: 'isIframe',\n\t    value: function isIframe() {\n\t      return window.parent && window.parent !== window;\n\t    }\n\t  }, {\n\t    key: 'open',\n\t    value: function open(url, name, features) {\n\t      return window.open(url, name, features);\n\t    }\n\t  }, {\n\t    key: '_libVersion',\n\t    value: function _libVersion() {\n\t      return '1.0.12';\n\t    }\n\t  }]);\n\t\n\t  return AuthenticationContext;\n\t}();\n\t\n\texports.default = AuthenticationContext;\n\t\n\t\n\tglobal.Logging = {\n\t  level: 0,\n\t  log: function log(message) {}\n\t};\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** salte-auth.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 969d1e2a37cdd5b5302a\n **/","/**\n * @public\n * @class Config\n * @property {clientId}        Identifier assigned to your app by Azure Active Directory\n * @property {redirectUri}     Endpoint at which you expect to receive tokens\n * @property {instance}        This is the URL path to the identity provider that authorize and logout will be called against.\n * @property {endpoints}       Collection of {Endpoint-ResourceId} used for autmatically attaching tokens in webApi calls\n * @property {scope}           This may be used to define the specific authorization(s) being requested from the resource owner.\n */\n\n/**\n * User information from idtoken.\n *  @class User\n *  @property {string} userName - username assigned from upn, email, or sub (i.e. subject).\n *  @property {object} profile - properties parsed from idtoken.\n */\n\n/**\n * Creates a new AuthenticationContext object.\n * @constructor\n * @param {object}  config               Configuration options for AuthenticationContext\n */\n\nimport uuid from 'uuid';\n\nexport default class AuthenticationContext {\n  constructor(config) {\n    /**\n    * Enum for request type\n    * @enum {string}\n    */\n    this.REQUEST_TYPE = {\n      LOGIN: 'LOGIN',\n      RENEW_TOKEN: 'RENEW_TOKEN',\n      UNKNOWN: 'UNKNOWN'\n    };\n\n    /**\n    * Enum for storage constants\n    * @enum {string}\n    */\n    this.CONSTANTS = {\n      ACCESS_TOKEN: 'access_token',\n      EXPIRES_IN: 'expires_in',\n      ID_TOKEN: 'id_token',\n      ERROR_DESCRIPTION: 'error_description',\n      SESSION_STATE: 'session_state',\n      STORAGE: {\n        TOKEN_KEYS: 'auth.token.keys',\n        ACCESS_TOKEN_KEY: 'auth.access.token.key',\n        EXPIRATION_KEY: 'auth.expiration.key',\n        STATE_LOGIN: 'auth.state.login',\n        STATE_RENEW: 'auth.state.renew',\n        NONCE_IDTOKEN: 'auth.nonce.idtoken',\n        SESSION_STATE: 'auth.session.state',\n        USERNAME: 'auth.username',\n        IDTOKEN: 'auth.idtoken',\n        ERROR: 'auth.error',\n        ERROR_DESCRIPTION: 'auth.error.description',\n        LOGIN_REQUEST: 'auth.login.request',\n        LOGIN_ERROR: 'auth.login.error',\n        RENEW_STATUS: 'auth.token.renew.status'\n      },\n      RESOURCE_DELIMETER: '|',\n      LOADFRAME_TIMEOUT: '6000',\n      TOKEN_RENEW_STATUS_CANCELED: 'Canceled',\n      TOKEN_RENEW_STATUS_COMPLETED: 'Completed',\n      TOKEN_RENEW_STATUS_IN_PROGRESS: 'In Progress',\n      LOGGING_LEVEL: {\n        ERROR: 0,\n        WARN: 1,\n        INFO: 2,\n        VERBOSE: 3\n      },\n      LEVEL_STRING_MAP: {\n        0: 'ERROR:',\n        1: 'WARNING:',\n        2: 'INFO:',\n        3: 'VERBOSE:'\n      },\n      POPUP_WIDTH: 483,\n      POPUP_HEIGHT: 600\n    };\n\n    if (window.AuthenticationContext) {\n      return window.AuthenticationContext;\n    }\n    window.AuthenticationContext = this;\n\n    // public\n    this.config = {};\n    this.callback = null;\n    this.popUp = false;\n    this.isAngular = false;\n\n    // private\n    this._user = null;\n    this._activeRenewals = {};\n    this._loginInProgress = false;\n    this._renewStates = [];\n\n    this.callBackMappedToRenewStates = {};\n    this.callBacksMappedToRenewStates = {};\n\n    // validate before constructor assignments\n    if (config.displayCall && typeof config.displayCall !== 'function') {\n      throw new Error('displayCall is not a function');\n    }\n\n    if (!config.clientId) {\n      throw new Error('clientId is required');\n    }\n\n    this.config = this._cloneConfig(config);\n\n    if (this.config.popUp) {\n      this.popUp = true;\n    }\n\n    if (this.config.callback && typeof this.config.callback === 'function') {\n      this.callback = this.config.callback;\n    }\n\n    if (!this.config.instance || !this.config.instance.match(/^https:\\/\\/.*\\/$/)) {\n      throw new Error('instance must be a valid https endpoint that ends in a forward slash.');\n    }\n\n    // App can request idtoken for itself using clientid as resource\n    if (!this.config.loginResource) {\n      this.config.loginResource = this.config.clientId;\n    }\n\n    if (!this.config.redirectUri) {\n      this.config.redirectUri = window.location.href;\n    }\n\n    if (!this.config.anonymousEndpoints) {\n      this.config.anonymousEndpoints = [];\n    }\n\n    if (this.config.isAngular) {\n      this.isAngular = this.config.isAngular;\n    }\n\n    this.setResponseType(this.config.responseType);\n  }\n\n  setResponseType(responseType) {\n    this.config.responseType = responseType || this.CONSTANTS.ID_TOKEN;\n  }\n\n  /**\n   * Gets initial Idtoken for the app backend\n   * Saves the resulting Idtoken in localStorage.\n   * @param {string} startPage the start page\n   */\n  login(startPage) {\n    // Token is not present and user needs to login\n    if (this._loginInProgress) {\n      this.info('Login in progress');\n      return;\n    }\n    const expectedState = uuid.v4();\n    this.config.state = expectedState;\n    this._idTokenNonce = uuid.v4();\n    if (!startPage) {\n      startPage = window.location;\n    }\n    this.verbose('Expected state: ' + expectedState + ' startPage:' + startPage);\n    this._saveItem(this.CONSTANTS.STORAGE.LOGIN_REQUEST, startPage);\n    this._saveItem(this.CONSTANTS.STORAGE.LOGIN_ERROR, '');\n    this._saveItem(this.CONSTANTS.STORAGE.STATE_LOGIN, expectedState);\n    this._saveItem(this.CONSTANTS.STORAGE.NONCE_IDTOKEN, this._idTokenNonce);\n    this._saveItem(this.CONSTANTS.STORAGE.ERROR, '');\n    this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, '');\n    const urlNavigate = this._getNavigateUrl(this.config.responseType, null) + '&nonce=' + encodeURIComponent(this._idTokenNonce);\n    this._loginInProgress = true;\n    if (this.popUp) {\n      this._loginPopup(urlNavigate);\n      return;\n    }\n    if (this.config.displayCall) {\n      // User defined way of handling the navigation\n      this.config.displayCall(urlNavigate);\n    } else {\n      this.promptUser(urlNavigate);\n    }\n  }\n\n  _openPopup(urlNavigate, title, popUpWidth, popUpHeight) {\n    try {\n      /**\n      * adding winLeft and winTop to account for dual monitor\n      * using screenLeft and screenTop for IE8 and earlier\n      */\n      const winLeft = window.screenLeft ? window.screenLeft : window.screenX;\n      const winTop = window.screenTop ? window.screenTop : window.screenY;\n      /**\n      * window.innerWidth displays browser window's height and width excluding toolbars\n      * using document.documentElement.clientWidth for IE8 and earlier\n      */\n      const width = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;\n      const height = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;\n      const left = ((width / 2) - (popUpWidth / 2)) + winLeft;\n      const top = ((height / 2) - (popUpHeight / 2)) + winTop;\n\n      const popupWindow = this.open(urlNavigate, title, 'width=' + popUpWidth + ', height=' + popUpHeight + ', top=' + top + ', left=' + left);\n      if (popupWindow.focus) {\n        popupWindow.focus();\n      }\n      return popupWindow;\n    } catch (e) {\n      this.warn('Error opening popup, ' + e.message);\n      this._loginInProgress = false;\n      return null;\n    }\n  }\n\n  _loginPopup(urlNavigate) {\n    const popupWindow = this._openPopup(urlNavigate, 'login', this.CONSTANTS.POPUP_WIDTH, this.CONSTANTS.POPUP_HEIGHT);\n    if (popupWindow === null) {\n      this.warn('Popup Window is null. This can happen if you are using IE');\n      this._saveItem(this.CONSTANTS.STORAGE.ERROR, 'Error opening popup');\n      this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, 'Popup Window is null. This can happen if you are using IE');\n      this._saveItem(this.CONSTANTS.STORAGE.LOGIN_ERROR, 'Popup Window is null. This can happen if you are using IE');\n      if (this.callback) {\n        this.callback(this._getItem(this.CONSTANTS.STORAGE.LOGIN_ERROR), null);\n      }\n      return;\n    }\n    let registeredRedirectUri;\n    if (this.config.redirectUri.indexOf('#') === -1) {\n      registeredRedirectUri = this.config.redirectUri;\n    } else {\n      registeredRedirectUri = this.config.redirectUri.split('#')[0];\n    }\n    const pollTimer = window.setInterval(() => {\n      if (!popupWindow || popupWindow.closed || popupWindow.closed === undefined) {\n        this._loginInProgress = false;\n        window.clearInterval(pollTimer);\n      }\n      try {\n        if (popupWindow.location.href.indexOf(registeredRedirectUri) !== -1) {\n          if (this.isAngular) {\n            window.location.hash = popupWindow.location.hash;\n          } else {\n            this.handleWindowCallback(popupWindow.location.hash, popupWindow.location.search);\n          }\n          window.clearInterval(pollTimer);\n          this._loginInProgress = false;\n          this.info('Closing popup window');\n          popupWindow.close();\n        }\n      } catch (e) {\n      }\n    }, 20);\n  }\n\n  loginInProgress() {\n    return this._loginInProgress;\n  }\n\n  _hasResource(key) {\n    const keys = this._getItem(this.CONSTANTS.STORAGE.TOKEN_KEYS);\n    return keys && !this._isEmpty(keys) && (keys.indexOf(key + this.CONSTANTS.RESOURCE_DELIMETER) > -1);\n  }\n\n  /**\n   * Gets token for the specified resource from local storage cache\n   * @param {string}   resource A URI that identifies the resource for which the token is valid.\n   * @return {string} token if exists and not expired or null\n   */\n  getCachedToken(resource) {\n    if (!this._hasResource(resource)) {\n      return null;\n    }\n\n    const token = this._getItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY + resource);\n    const expired = this._getItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY + resource);\n\n    // If expiration is within offset, it will force renew\n    const offset = this.config.expireOffsetSeconds || 120;\n\n    if (expired && (expired > this._now() + offset)) {\n      return token;\n    }\n    this._saveItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY + resource, '');\n    this._saveItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY + resource, 0);\n    return null;\n  }\n\n  /**\n   * Retrieves and parse idToken from localstorage\n   * @return {User} user object\n   */\n  getCachedUser() {\n    if (this._user) {\n      return this._user;\n    }\n\n    const idtoken = this._getItem(this.CONSTANTS.STORAGE.IDTOKEN);\n    this._user = this._createUser(idtoken);\n    return this._user;\n  }\n\n  registerCallback(expectedState, resource, callback) {\n    this._activeRenewals[resource] = expectedState;\n    if (!this.callBacksMappedToRenewStates[expectedState]) {\n      this.callBacksMappedToRenewStates[expectedState] = [];\n    }\n    this.callBacksMappedToRenewStates[expectedState].push(callback);\n    if (!this.callBackMappedToRenewStates[expectedState]) {\n      this.callBackMappedToRenewStates[expectedState] = (message, token) => {\n        for (let i = 0; i < this.callBacksMappedToRenewStates[expectedState].length; ++i) {\n          try {\n            this.callBacksMappedToRenewStates[expectedState][i](message, token);\n          } catch (error) {\n            this.warn(error);\n          }\n        }\n        this._activeRenewals[resource] = null;\n        this.callBacksMappedToRenewStates[expectedState] = null;\n        this.callBackMappedToRenewStates[expectedState] = null;\n      };\n    }\n  }\n\n  /**\n   * Acquires access token with hidden iframe\n   * @param {string} resource  ResourceUri identifying the target resource\n   * @param {string} callback  ResourceUri identifying the target resource\n   */\n  _renewToken(resource, callback) {\n    // use iframe to try refresh token\n    // use given resource to create new authz url\n    this.info('renewToken is called for resource:' + resource);\n    const frameHandle = this._addAuthFrame('authRenewFrame' + resource);\n    const expectedState = uuid.v4() + '|' + resource;\n    this.config.state = expectedState;\n    // renew happens in iframe, so it keeps javascript context\n    this._renewStates.push(expectedState);\n\n    this.verbose('Renew token Expected state: ' + expectedState);\n    let urlNavigate = this._getNavigateUrl('token', resource) + '&prompt=none';\n    urlNavigate = this._addHintParameters(urlNavigate);\n\n    this.registerCallback(expectedState, resource, callback);\n    this.verbose('Navigate to:' + urlNavigate);\n    this._saveItem(this.CONSTANTS.STORAGE.LOGIN_REQUEST, '');\n    frameHandle.src = 'about:blank';\n    this._loadFrameTimeout(urlNavigate, 'authRenewFrame' + resource, resource);\n  }\n\n  _renewIdToken(callback) {\n    // use iframe to try refresh token\n    this.info('renewIdToken is called');\n    const frameHandle = this._addAuthFrame('authIdTokenFrame');\n    const expectedState = uuid.v4() + '|' + this.config.clientId;\n    this._idTokenNonce = uuid.v4();\n    this._saveItem(this.CONSTANTS.STORAGE.NONCE_IDTOKEN, this._idTokenNonce);\n    this.config.state = expectedState;\n    // renew happens in iframe, so it keeps javascript context\n    this._renewStates.push(expectedState);\n\n    this.verbose('Renew Idtoken Expected state: ' + expectedState);\n    let urlNavigate = this._getNavigateUrl(this.config.responseType, null) + '&prompt=none';\n    urlNavigate = this._addHintParameters(urlNavigate);\n\n    urlNavigate += '&nonce=' + encodeURIComponent(this._idTokenNonce);\n    this.registerCallback(expectedState, this.config.clientId, callback);\n    this.idTokenNonce = null;\n    this.verbose('Navigate to:' + urlNavigate);\n    this._saveItem(this.CONSTANTS.STORAGE.LOGIN_REQUEST, '');\n    frameHandle.src = 'about:blank';\n    this._loadFrameTimeout(urlNavigate, 'authIdTokenFrame', this.config.clientId);\n  }\n\n  _urlContainsQueryStringParameter(name, url) {\n    // regex to detect pattern of a ? or & followed by the name parameter and an equals character\n    const regex = new RegExp('[\\\\?&]' + name + '=');\n    return regex.test(url);\n  }\n\n  // Calling _loadFrame but with a timeout to signal failure in loadframeStatus. Callbacks are left\n  // registered when network errors occur and subsequent token requests for same resource are registered to the pending request\n  _loadFrameTimeout(urlNavigation, frameName, resource) {\n    // set iframe session to pending\n    this.verbose('Set loading state to pending for: ' + resource);\n    this._saveItem(this.CONSTANTS.STORAGE.RENEW_STATUS + resource, this.CONSTANTS.TOKEN_RENEW_STATUS_IN_PROGRESS);\n    this._loadFrame(urlNavigation, frameName);\n    setTimeout(() => {\n      if (this._getItem(this.CONSTANTS.STORAGE.RENEW_STATUS + resource) === this.CONSTANTS.TOKEN_RENEW_STATUS_IN_PROGRESS) {\n        // fail the iframe session if it's in pending state\n        this.verbose('Loading frame has timed out after: ' + (this.CONSTANTS.LOADFRAME_TIMEOUT / 1000) + ' seconds for resource ' + resource);\n        const expectedState = this._activeRenewals[resource];\n\n        this._saveItem(this.CONSTANTS.STORAGE.RENEW_STATUS + resource, this.CONSTANTS.TOKEN_RENEW_STATUS_CANCELED);\n\n        if (expectedState && this.callBackMappedToRenewStates[expectedState]) {\n          this.callBackMappedToRenewStates[expectedState]('Token renewal operation failed due to timeout', null);\n        }\n      }\n    }, this.CONSTANTS.LOADFRAME_TIMEOUT);\n  }\n\n  _loadFrame(urlNavigate, frameName) {\n    // This trick overcomes iframe navigation in IE\n    // IE does not load the page consistently in iframe\n    this.info('LoadFrame: ' + frameName);\n    const frameCheck = frameName;\n    setTimeout(() => {\n      const frameHandle = this._addAuthFrame(frameCheck);\n      if (frameHandle.src === '' || frameHandle.src === 'about:blank') {\n        frameHandle.src = urlNavigate;\n        this._loadFrame(urlNavigate, frameCheck);\n      }\n    }, 500);\n  }\n\n  /**\n   * Acquire token from cache if not expired and available. Acquires token from iframe if expired.\n   * @param {string} resource  ResourceUri identifying the target resource\n   * @param {function} callback The callback function\n   */\n  acquireToken(resource, callback) {\n    if (this._isEmpty(resource)) {\n      this.warn('resource is required');\n      callback('resource is required', null);\n      return;\n    }\n\n    const token = this.getCachedToken(resource);\n    if (token) {\n      this.info('Token is already in cache for resource:' + resource);\n      callback(null, token);\n      return;\n    }\n\n    if (!this._user) {\n      this.warn('User login is required');\n      callback('User login is required', null);\n      return;\n    }\n\n    // refresh attept with iframe\n    // Already renewing for this resource, callback when we get the token.\n    if (this._activeRenewals[resource]) {\n      // Active renewals contains the state for each renewal.\n      this.registerCallback(this._activeRenewals[resource], resource, callback);\n    } else if (resource === this.config.clientId) {\n      // App uses idtoken to send to api endpoints\n      // Default resource is tracked as clientid to store this token\n      this.verbose('renewing idtoken');\n      this._renewIdToken(callback);\n    } else {\n      this._renewToken(resource, callback);\n    }\n  }\n\n  /**\n   * Redirect the Browser to Azure AD Authorization endpoint\n   * @param {string} urlNavigate The authorization request url\n   */\n  promptUser(urlNavigate) {\n    if (urlNavigate) {\n      this.info('Navigate to:' + urlNavigate);\n      this.navigate(urlNavigate);\n    } else {\n      this.info('Navigate url is empty');\n    }\n  }\n\n  /**\n   * Clear cache items.\n   */\n  clearCache() {\n    this._saveItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY, '');\n    this._saveItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY, 0);\n    this._saveItem(this.CONSTANTS.STORAGE.SESSION_STATE, '');\n    this._saveItem(this.CONSTANTS.STORAGE.STATE_LOGIN, '');\n    this._renewStates = [];\n    this._saveItem(this.CONSTANTS.STORAGE.USERNAME, '');\n    this._saveItem(this.CONSTANTS.STORAGE.IDTOKEN, '');\n    this._saveItem(this.CONSTANTS.STORAGE.ERROR, '');\n    this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, '');\n    let keys = this._getItem(this.CONSTANTS.STORAGE.TOKEN_KEYS);\n\n    if (!this._isEmpty(keys)) {\n      keys = keys.split(this.CONSTANTS.RESOURCE_DELIMETER);\n      for (let i = 0; i < keys.length; i++) {\n        this._saveItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY + keys[i], '');\n        this._saveItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY + keys[i], 0);\n      }\n    }\n    this._saveItem(this.CONSTANTS.STORAGE.TOKEN_KEYS, '');\n  }\n\n  /**\n   * Clear cache items for a resource.\n   * @param {string} resource The resource\n   */\n  clearCacheForResource(resource) {\n    this._saveItem(this.CONSTANTS.STORAGE.STATE_RENEW, '');\n    this._saveItem(this.CONSTANTS.STORAGE.ERROR, '');\n    this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, '');\n    if (this._hasResource(resource)) {\n      this._saveItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY + resource, '');\n      this._saveItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY + resource, 0);\n    }\n  }\n\n  /**\n   * Logout user will redirect page to logout endpoint.\n   * After logout, it will redirect to post_logout page if provided.\n   */\n  logOut() {\n    this.clearCache();\n    let logout = '';\n    this._user = null;\n\n    if (this.config.postLogoutRedirectUri) {\n      logout = 'post_logout_redirect_uri=' + encodeURIComponent(this.config.postLogoutRedirectUri);\n    }\n\n    const urlNavigate = this.config.instance + 'logout?' + logout;\n    this.info('Logout navigate to: ' + urlNavigate);\n    this.promptUser(urlNavigate);\n  }\n\n  _isEmpty(str) {\n    return (typeof str === 'undefined' || !str || str.length === 0);\n  }\n\n  /**\n   * Gets a user profile\n   * @param {requestCallback} callback The callback that handles the response.\n   */\n  getUser(callback) {\n    // IDToken is first call\n    if (typeof callback !== 'function') {\n      throw new Error('callback is not a function');\n    }\n\n    // user in memory\n    if (this._user) {\n      callback(null, this._user);\n      return;\n    }\n\n    // frame is used to get idtoken\n    const idtoken = this._getItem(this.CONSTANTS.STORAGE.IDTOKEN);\n    if (this._isEmpty(idtoken)) {\n      this.warn('User information is not available');\n      callback('User information is not available');\n    } else {\n      this.info('User exists in cache: ');\n      this._user = this._createUser(idtoken);\n      callback(null, this._user);\n    }\n  }\n\n  _addHintParameters(urlNavigate) {\n    // include hint params only if upn is present\n    if (this._user && this._user.profile && this._user.profile.hasOwnProperty('upn')) {\n      // add login_hint\n      urlNavigate += '&login_hint=' + encodeURIComponent(this._user.profile.upn);\n\n      // don't add domain_hint twice if user provided it in the extraQueryParameter value\n      if (!this._urlContainsQueryStringParameter('domain_hint', urlNavigate) && this._user.profile.upn.indexOf('@') > -1) {\n        const parts = this._user.profile.upn.split('@');\n        // local part can include @ in quotes. Sending last part handles that.\n        urlNavigate += '&domain_hint=' + encodeURIComponent(parts[parts.length - 1]);\n      }\n    }\n\n    return urlNavigate;\n  }\n\n  _createUser(idToken) {\n    let user = null;\n    const parsedJson = this._extractIdToken(idToken);\n    if (parsedJson && parsedJson.hasOwnProperty('aud')) {\n      let audienceMatch = false;\n\n      if (Array.isArray(parsedJson.aud)) {\n        // If the ID Token contains multiple audiences then an azp claim must be present and equal to the client id.\n        if (parsedJson.hasOwnProperty('azp') && parsedJson.azp.toLowerCase() === this.config.clientId.toLowerCase()) {\n          for (let i = 0; i < parsedJson.aud.length; i++) {\n            if (parsedJson.aud[i].toLowerCase() === this.config.clientId.toLowerCase()) {\n              audienceMatch = true;\n              break;\n            }\n          }\n        }\n      } else {\n        audienceMatch = (parsedJson.aud.toLowerCase() === this.config.clientId.toLowerCase());\n      }\n\n      if (audienceMatch) {\n        user = {\n          userName: '',\n          profile: parsedJson\n        };\n\n        if (parsedJson.hasOwnProperty('upn')) {\n          user.userName = parsedJson.upn;\n        } else if (parsedJson.hasOwnProperty('email')) {\n          user.userName = parsedJson.email;\n        } else if (parsedJson.hasOwnProperty('sub')) {\n          user.userName = parsedJson.sub;\n        }\n      } else {\n        this.warn('IdToken has invalid aud/azp field');\n      }\n    }\n\n    return user;\n  }\n\n  _getHash(hash) {\n    if (hash.indexOf('#/') > -1) {\n      hash = hash.substring(hash.indexOf('#/') + 2);\n    } else if (hash.indexOf('#') > -1) {\n      hash = hash.substring(1);\n    }\n\n    return hash;\n  }\n\n  _getSearch(search) {\n    if (search.indexOf('?') > -1) {\n      search = search.substring(1);\n    }\n\n    return search;\n  }\n\n  _getParameters(hash, search) {\n    let parameters = {};\n\n    if (hash) {\n      hash = this._getHash(hash);\n      parameters = this._deserialize(hash);\n    }\n\n    if (search) {\n      search = this._getSearch(search);\n      const searchParameters = this._deserialize(search);\n      parameters = this._extend(parameters, searchParameters);\n    }\n\n    return parameters;\n  }\n\n  _extend(obj, src) {\n    for (const key in src) {\n      if (src.hasOwnProperty(key)) {\n        obj[key] = src[key];\n      }\n    }\n    return obj;\n  }\n\n  /**\n   * Checks if hash contains access token or id token or error_description\n   * @param {string} hash  -  Hash passed from redirect page\n   * @param {string} search  -  Search passed from redirect page\n   * @return {boolean} exists if all the parameters exist\n   */\n  isCallback(hash, search) {\n    const parameters = this._getParameters(hash, search);\n\n    return parameters.hasOwnProperty(this.CONSTANTS.ERROR_DESCRIPTION) ||\n      parameters.hasOwnProperty(this.CONSTANTS.ACCESS_TOKEN) ||\n      parameters.hasOwnProperty(this.CONSTANTS.ID_TOKEN);\n  }\n\n  /**\n   * Gets login error\n   * @return {string} error message related to login\n   */\n  getLoginError() {\n    return this._getItem(this.CONSTANTS.STORAGE.LOGIN_ERROR);\n  }\n\n  /**\n   * Gets requestInfo from given hash.\n   * @param {string} hash  -  Hash passed from redirect page\n   * @param {string} search  -  Search passed from redirect page\n   * @return {string} error message related to login\n   */\n  getRequestInfo(hash, search) {\n    const parameters = this._getParameters(hash, search);\n    const requestInfo = {\n      valid: false,\n      parameters: {},\n      stateMatch: false,\n      stateResponse: '',\n      requestType: this.REQUEST_TYPE.UNKNOWN\n    };\n\n    if (parameters) {\n      requestInfo.parameters = parameters;\n      if (parameters.hasOwnProperty(this.CONSTANTS.ERROR_DESCRIPTION) ||\n        parameters.hasOwnProperty(this.CONSTANTS.ACCESS_TOKEN) ||\n        parameters.hasOwnProperty(this.CONSTANTS.ID_TOKEN)) {\n        requestInfo.valid = true;\n\n        // which call\n        let stateResponse = '';\n        if (parameters.hasOwnProperty('state')) {\n          this.verbose('State: ' + parameters.state);\n          stateResponse = parameters.state;\n        } else {\n          this.warn('No state returned');\n          return requestInfo;\n        }\n\n        requestInfo.stateResponse = stateResponse;\n\n        // async calls can fire iframe and login request at the same time if developer does not use the API as expected\n        // incoming callback needs to be looked up to find the request type\n        if (stateResponse === this._getItem(this.CONSTANTS.STORAGE.STATE_LOGIN)) {\n          requestInfo.requestType = this.REQUEST_TYPE.LOGIN;\n          requestInfo.stateMatch = true;\n          return requestInfo;\n        }\n\n        // external api requests may have many renewtoken requests for different resource\n        if (!requestInfo.stateMatch && window.parent && window.parent.AuthenticationContext) {\n          const statesInParentContext = window.parent.AuthenticationContext._renewStates;\n          for (let i = 0; i < statesInParentContext.length; i++) {\n            if (statesInParentContext[i] === requestInfo.stateResponse) {\n              requestInfo.requestType = this.REQUEST_TYPE.RENEW_TOKEN;\n              requestInfo.stateMatch = true;\n              break;\n            }\n          }\n        }\n      }\n    }\n\n    return requestInfo;\n  }\n\n  _getResourceFromState(state) {\n    if (state) {\n      const splitIndex = state.indexOf('|');\n      if (splitIndex > -1 && splitIndex + 1 < state.length) {\n        return state.substring(splitIndex + 1);\n      }\n    }\n\n    return '';\n  }\n\n  /**\n   * Saves token from hash that is received from redirect.\n   * @param {string} requestInfo Hash passed from redirect page\n   */\n  saveTokenFromHash(requestInfo) {\n    this.info('State status:' + requestInfo.stateMatch + '; Request type:' + requestInfo.requestType);\n    this._saveItem(this.CONSTANTS.STORAGE.ERROR, '');\n    this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, '');\n\n    let resource = this._getResourceFromState(requestInfo.stateResponse);\n\n    // Record error\n    if (requestInfo.parameters.hasOwnProperty(this.CONSTANTS.ERROR_DESCRIPTION)) {\n      this.info('Error :' + requestInfo.parameters.error + '; Error description:' + requestInfo.parameters[this.CONSTANTS.ERROR_DESCRIPTION]);\n      this._saveItem(this.CONSTANTS.STORAGE.ERROR, requestInfo.parameters.error);\n      this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, requestInfo.parameters[this.CONSTANTS.ERROR_DESCRIPTION]);\n\n      if (requestInfo.requestType === this.REQUEST_TYPE.LOGIN) {\n        this._loginInProgress = false;\n        this._saveItem(this.CONSTANTS.STORAGE.LOGIN_ERROR, requestInfo.parameters.error_description);\n      }\n    } else if (requestInfo.stateMatch) {\n      // record tokens to storage if exists\n      this.info('State is right');\n      if (requestInfo.parameters.hasOwnProperty(this.CONSTANTS.SESSION_STATE)) {\n        this._saveItem(this.CONSTANTS.STORAGE.SESSION_STATE, requestInfo.parameters[this.CONSTANTS.SESSION_STATE]);\n      }\n\n      let keys;\n\n      if (requestInfo.parameters.hasOwnProperty(this.CONSTANTS.ACCESS_TOKEN)) {\n        this.info('Fragment has access token');\n\n        if (!this._hasResource(resource)) {\n          keys = this._getItem(this.CONSTANTS.STORAGE.TOKEN_KEYS) || '';\n          this._saveItem(this.CONSTANTS.STORAGE.TOKEN_KEYS, keys + resource + this.CONSTANTS.RESOURCE_DELIMETER);\n        }\n        // save token with related resource\n        this._saveItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY + resource, requestInfo.parameters[this.CONSTANTS.ACCESS_TOKEN]);\n        this._saveItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY + resource, this._expiresIn(requestInfo.parameters[this.CONSTANTS.EXPIRES_IN]));\n      }\n\n      if (requestInfo.parameters.hasOwnProperty(this.CONSTANTS.ID_TOKEN)) {\n        this.info('Fragment has id token');\n        this._loginInProgress = false;\n\n        this._user = this._createUser(requestInfo.parameters[this.CONSTANTS.ID_TOKEN]);\n\n        if (this._user && this._user.profile) {\n          if (this._user.profile.nonce === this._getItem(this.CONSTANTS.STORAGE.NONCE_IDTOKEN)) {\n            this._saveItem(this.CONSTANTS.STORAGE.IDTOKEN, requestInfo.parameters[this.CONSTANTS.ID_TOKEN]);\n\n            // Save idtoken as access token for app itself\n            resource = this.config.loginResource ? this.config.loginResource : this.config.clientId;\n\n            if (!this._hasResource(resource)) {\n              keys = this._getItem(this.CONSTANTS.STORAGE.TOKEN_KEYS) || '';\n              this._saveItem(this.CONSTANTS.STORAGE.TOKEN_KEYS, keys + resource + this.CONSTANTS.RESOURCE_DELIMETER);\n            }\n            this._saveItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY + resource, requestInfo.parameters[this.CONSTANTS.ID_TOKEN]);\n            this._saveItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY + resource, this._user.profile.exp);\n          } else {\n            this._user = null;\n            this._saveItem(this.CONSTANTS.STORAGE.LOGIN_ERROR, 'Nonce is not same as ' + this._idTokenNonce);\n          }\n        } else {\n          this._saveItem(this.CONSTANTS.STORAGE.ERROR, 'invalid id_token');\n          this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, 'Invalid id_token. id_token: ' + requestInfo.parameters[this.CONSTANTS.ID_TOKEN]);\n        }\n      }\n    } else {\n      this._saveItem(this.CONSTANTS.STORAGE.ERROR, 'Invalid_state');\n      this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, 'Invalid_state. state: ' + requestInfo.stateResponse);\n    }\n    this._saveItem(this.CONSTANTS.STORAGE.RENEW_STATUS + resource, this.CONSTANTS.TOKEN_RENEW_STATUS_COMPLETED);\n  }\n\n  /**\n   * Gets resource for given endpoint if mapping is provided with config.\n   * @param {string} endpoint API endpoint\n   * @return {string} resource for this API endpoint\n   */\n  getResourceForEndpoint(endpoint) {\n    if (this.config && this.config.endpoints) {\n      for (const configEndpoint in this.config.endpoints) {\n        // configEndpoint is like /api/Todo requested endpoint can be /api/Todo/1\n        if (endpoint.indexOf(configEndpoint) > -1) {\n          return this.config.endpoints[configEndpoint];\n        }\n      }\n    }\n\n    // default resource will be clientid if nothing specified\n    // App will use idtoken for calls to itself\n    // check if it's staring from http or https, needs to match with app host\n    if (endpoint.indexOf('http://') > -1 || endpoint.indexOf('https://') > -1) {\n      if (this._getHostFromUri(endpoint) === this._getHostFromUri(this.config.redirectUri)) {\n        return this.config.loginResource;\n      }\n    } else {\n      // in angular level, the url for $http interceptor call could be relative url,\n      // if it's relative call, we'll treat it as app backend call.\n      // if user specified list of anonymous endpoints, no need to send token to these endpoints, return null.\n      if (this.config && this.config.anonymousEndpoints) {\n        for (let i = 0; i < this.config.anonymousEndpoints.length; i++) {\n          if (endpoint.indexOf(this.config.anonymousEndpoints[i]) > -1) {\n            return null;\n          }\n        }\n      }\n      // all other app's backend calls are secured.\n      return this.config.loginResource;\n    }\n\n    // if not the app's own backend or not a domain listed in the endpoints structure\n    return null;\n  }\n\n  _getHostFromUri(uri) {\n    // remove http:// or https:// from uri\n    let extractedUri = String(uri).replace(/^(https?:)\\/\\//, '');\n\n    extractedUri = extractedUri.split('/')[0];\n    return extractedUri;\n  }\n\n  /* exported  oauth2Callback */\n  handleWindowCallback(hash, search) {\n    // This is for regular javascript usage for redirect handling\n    // need to make sure this is for callback\n    if (!hash) {\n      hash = window.location.hash;\n    }\n\n    if (!search) {\n      search = window.location.search;\n    }\n\n    if (this.isCallback(hash, search)) {\n      const requestInfo = this.getRequestInfo(hash, search);\n      this.info('Returned from redirect url');\n      this.saveTokenFromHash(requestInfo);\n      let callback = null;\n      if ((requestInfo.requestType === this.REQUEST_TYPE.RENEW_TOKEN) && this.isIframe()) {\n        // iframe call but same single page\n        this.verbose('Window is in iframe');\n        callback = window.parent.AuthenticationContext.callBackMappedToRenewStates[requestInfo.stateResponse];\n        if (callback) {\n          callback(this._getItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION), requestInfo.parameters[this.CONSTANTS.ACCESS_TOKEN] || requestInfo.parameters[this.CONSTANTS.ID_TOKEN]);\n        }\n        return;\n      } else if (requestInfo.requestType === this.REQUEST_TYPE.LOGIN) {\n        callback = this.callback;\n        if (callback) {\n          callback(this._getItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION), requestInfo.parameters[this.CONSTANTS.ID_TOKEN]);\n        }\n      }\n      // No need to redirect user in case of popup\n      if (!this.popUp) {\n        this.navigate(this._getItem(this.CONSTANTS.STORAGE.LOGIN_REQUEST));\n      }\n    }\n  }\n\n  _getNavigateUrl(responseType, resource) {\n    let urlNavigate = this.config.instance + 'authorize' + this._serialize(responseType, this.config, resource) + this._addLibMetadata();\n    if (this.config.scope) {\n      urlNavigate += '&scope=' + encodeURIComponent(this.config.scope);\n    }\n    this.info('Navigate url:' + urlNavigate);\n    return urlNavigate;\n  }\n\n  _extractIdToken(encodedIdToken) {\n    // id token will be decoded to get the username\n    const decodedToken = this._decodeJwt(encodedIdToken);\n    if (!decodedToken) {\n      return null;\n    }\n\n    try {\n      const base64IdToken = decodedToken.JWSPayload;\n      const base64Decoded = this._base64DecodeStringUrlSafe(base64IdToken);\n      if (!base64Decoded) {\n        this.info('The returned id_token could not be base64 url safe decoded.');\n        return null;\n      }\n\n      return JSON.parse(base64Decoded);\n    } catch (err) {\n      this.error('The returned id_token could not be decoded', err);\n    }\n\n    return null;\n  }\n\n  _base64DecodeStringUrlSafe(base64IdToken) {\n    base64IdToken = base64IdToken.replace(/-/g, '+').replace(/_/g, '/');\n    return decodeURIComponent(escape(window.atob(base64IdToken)));\n  }\n\n    // Auth.node js crack function\n  _decodeJwt(jwtToken) {\n    if (this._isEmpty(jwtToken)) {\n      return null;\n    }\n\n    const idTokenPartsRegex = /^([^\\.\\s]*)\\.([^\\.\\s]+)\\.([^\\.\\s]*)$/;\n\n    const matches = idTokenPartsRegex.exec(jwtToken);\n    if (!matches || matches.length < 4) {\n      this.warn('The returned id_token is not parseable.');\n      return null;\n    }\n\n    const crackedToken = {\n      header: matches[1],\n      JWSPayload: matches[2],\n      JWSSig: matches[3]\n    };\n\n    return crackedToken;\n  }\n\n  _convertUrlSafeToRegularBase64EncodedString(str) {\n    return str.replace('-', '+').replace('_', '/');\n  }\n\n  _serialize(responseType, obj, resource) {\n    const str = [];\n    if (obj !== null) {\n      str.push('?response_type=' + encodeURIComponent(responseType));\n      str.push('client_id=' + encodeURIComponent(obj.clientId));\n      if (resource) {\n        str.push('resource=' + encodeURIComponent(resource));\n      }\n\n      str.push('redirect_uri=' + encodeURIComponent(obj.redirectUri));\n      str.push('state=' + encodeURIComponent(obj.state));\n\n      if (obj.hasOwnProperty('slice')) {\n        str.push('slice=' + encodeURIComponent(obj.slice));\n      }\n\n      if (obj.hasOwnProperty('extraQueryParameter')) {\n        str.push(obj.extraQueryParameter);\n      }\n\n      const correlationId = obj.correlationId ? obj.correlationId : uuid.v4();\n      str.push('client-request-id=' + encodeURIComponent(correlationId));\n    }\n\n    return str.join('&');\n  }\n\n  _deserialize(query) {\n    const pl = /\\+/g; // Regex for replacing addition symbol with a space\n    const search = /([^&=]+)=([^&]*)/g;\n    const decode = (s) => {\n      return decodeURIComponent(s.replace(pl, ' '));\n    };\n    const obj = {};\n    let match = search.exec(query);\n    while (match) {\n      obj[decode(match[1])] = decode(match[2]);\n      match = search.exec(query);\n    }\n\n    return obj;\n  }\n\n  _decimalToHex(number) {\n    let hex = number.toString(16);\n    while (hex.length < 2) {\n      hex = '0' + hex;\n    }\n    return hex;\n  }\n\n  _expiresIn(expires) {\n    return this._now() + parseInt(expires, 10);\n  }\n\n  _now() {\n    return Math.round(new Date().getTime() / 1000.0);\n  }\n\n  _addAuthFrame(iframeId) {\n    if (typeof iframeId === 'undefined') {\n      return;\n    }\n\n    this.info('Add auth frame to document:' + iframeId);\n    let authFrame = document.getElementById(iframeId);\n\n    if (!authFrame) {\n      if (document.createElement && document.documentElement &&\n                (window.opera || window.navigator.userAgent.indexOf('MSIE 5.0') === -1)) {\n        const ifr = document.createElement('iframe');\n        ifr.setAttribute('id', iframeId);\n        ifr.style.visibility = 'hidden';\n        ifr.style.position = 'absolute';\n        ifr.style.width = ifr.style.height = ifr.borderWidth = '0px';\n\n        authFrame = document.getElementsByTagName('body')[0].appendChild(ifr);\n      } else if (document.body && document.body.insertAdjacentHTML) {\n        document.body.insertAdjacentHTML('beforeEnd', '<iframe name=\"' + iframeId + '\" id=\"' + iframeId + '\" style=\"display:none\"></iframe>');\n      }\n      if (window.frames && window.frames[iframeId]) {\n        authFrame = window.frames[iframeId];\n      }\n    }\n\n    return authFrame;\n  }\n\n  _saveItem(key, obj) {\n    if (this.config && this.config.cacheLocation && this.config.cacheLocation === 'localStorage') {\n      if (!this._supportsLocalStorage()) {\n        this.info('Local storage is not supported');\n        return false;\n      }\n\n      localStorage.setItem(key, obj);\n\n      return true;\n    }\n\n    // Default as session storage\n    if (!this._supportsSessionStorage()) {\n      this.info('Session storage is not supported');\n      return false;\n    }\n\n    sessionStorage.setItem(key, obj);\n    return true;\n  }\n\n  _getItem(key) {\n    if (this.config && this.config.cacheLocation && this.config.cacheLocation === 'localStorage') {\n      if (!this._supportsLocalStorage()) {\n        this.info('Local storage is not supported');\n        return null;\n      }\n\n      return localStorage.getItem(key);\n    }\n\n    // Default as session storage\n    if (!this._supportsSessionStorage()) {\n      this.info('Session storage is not supported');\n      return null;\n    }\n\n    return sessionStorage.getItem(key);\n  }\n\n  _supportsLocalStorage() {\n    try {\n      return 'localStorage' in window && window.localStorage;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  _supportsSessionStorage() {\n    try {\n      return 'sessionStorage' in window && window.sessionStorage;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  _cloneConfig(obj) {\n    if (obj === null || typeof obj !== 'object') {\n      return obj;\n    }\n\n    const copy = {};\n    for (const attr in obj) {\n      if (obj.hasOwnProperty(attr)) {\n        copy[attr] = obj[attr];\n      }\n    }\n    return copy;\n  }\n\n  _addLibMetadata() {\n    // x-client-SKU\n    // x-client-Ver\n    return '&x-client-SKU=Js&x-client-Ver=' + this._libVersion();\n  }\n\n  log(level, message, error) {\n    if (level <= Logging.level) {\n      const timestamp = new Date().toUTCString();\n      let formattedMessage = '';\n\n      if (this.config.correlationId) {\n        formattedMessage = timestamp + ':' + this.config.correlationId + '-' + this._libVersion() + '-' + this.CONSTANTS.LEVEL_STRING_MAP[level] + ' ' + message;\n      } else {\n        formattedMessage = timestamp + ':' + this._libVersion() + '-' + this.CONSTANTS.LEVEL_STRING_MAP[level] + ' ' + message;\n      }\n\n      if (error) {\n        formattedMessage += '\\nstack:\\n' + error.stack;\n      }\n\n      Logging.log(formattedMessage);\n    }\n  }\n\n  error(message, error) {\n    this.log(this.CONSTANTS.LOGGING_LEVEL.ERROR, message, error);\n  }\n\n  warn(message) {\n    this.log(this.CONSTANTS.LOGGING_LEVEL.WARN, message, null);\n  }\n\n  info(message) {\n    this.log(this.CONSTANTS.LOGGING_LEVEL.INFO, message, null);\n  }\n\n  verbose(message) {\n    this.log(this.CONSTANTS.LOGGING_LEVEL.VERBOSE, message, null);\n  }\n\n  navigate(url) {\n    window.location.replace(url);\n  }\n\n  isIframe() {\n    return window.parent && window.parent !== window;\n  }\n\n  open(url, name, features) {\n    return window.open(url, name, features);\n  }\n\n  _libVersion() {\n    return '1.0.12';\n  }\n}\n\nglobal.Logging = {\n  level: 0,\n  log: (message) => {}\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./salte-auth.js\n **/","module.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external {\"root\":\"uuid\",\"commonjs2\":\"uuid\",\"commonjs\":\"uuid\",\"amd\":\"uuid\"}\n ** module id = 1\n ** module chunks = 0\n **/"],"sourceRoot":""}