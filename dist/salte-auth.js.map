{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///salte-auth.js","webpack:///webpack/bootstrap 820508c0cd44ee1eba48","webpack:///./salte-auth.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_typeof","Symbol","iterator","obj","constructor","prototype","AuthenticationContext","config","REQUEST_TYPE","LOGIN","RENEW_TOKEN","UNKNOWN","CONSTANTS","ACCESS_TOKEN","EXPIRES_IN","ID_TOKEN","ERROR_DESCRIPTION","SESSION_STATE","STORAGE","TOKEN_KEYS","ACCESS_TOKEN_KEY","EXPIRATION_KEY","STATE_LOGIN","STATE_RENEW","NONCE_IDTOKEN","USERNAME","IDTOKEN","ERROR","LOGIN_REQUEST","LOGIN_ERROR","RENEW_STATUS","RESOURCE_DELIMETER","LOADFRAME_TIMEOUT","TOKEN_RENEW_STATUS_CANCELED","TOKEN_RENEW_STATUS_COMPLETED","TOKEN_RENEW_STATUS_IN_PROGRESS","LOGGING_LEVEL","WARN","INFO","VERBOSE","LEVEL_STRING_MAP","0","1","2","3","POPUP_WIDTH","POPUP_HEIGHT","window","callback","popUp","isAngular","_user","_activeRenewals","_loginInProgress","_renewStates","callBackMappedToRenewStates","callBacksMappedToRenewStates","displayCall","Error","clientId","_cloneConfig","instance","match","loginResource","redirectUri","location","href","anonymousEndpoints","setResponseType","responseType","Logging","level","log","message","login","startPage","info","expectedState","_guid","state","_idTokenNonce","verbose","_saveItem","urlNavigate","_getNavigateUrl","encodeURIComponent","_loginPopup","promptUser","_openPopup","title","popUpWidth","popUpHeight","winLeft","screenLeft","screenX","winTop","screenTop","screenY","width","innerWidth","document","documentElement","clientWidth","body","height","innerHeight","clientHeight","left","top","popupWindow","open","focus","e","warn","_getItem","registeredRedirectUri","indexOf","split","that","pollTimer","setInterval","closed","undefined","clearInterval","hash","handleWindowCallback","search","close","loginInProgress","_hasResource","key","keys","_isEmpty","getCachedToken","resource","token","expired","offset","expireOffsetSeconds","_now","getCachedUser","idtoken","_createUser","registerCallback","self","push","i","length","error","_renewToken","frameHandle","_addAuthFrame","_addHintParameters","src","_loadFrameTimeout","_renewIdToken","idTokenNonce","_urlContainsQueryStringParameter","name","url","regex","RegExp","test","urlNavigation","frameName","_loadFrame","setTimeout","frameCheck","acquireToken","replace","clearCache","clearCacheForResource","logOut","logout","postLogoutRedirectUri","str","getUser","profile","hasOwnProperty","upn","parts","idToken","user","parsedJson","_extractIdToken","audienceMatch","Array","isArray","aud","azp","toLowerCase","userName","email","sub","_getHash","substring","_getSearch","_getParameters","parameters","_deserialize","searchParameters","_extend","isCallback","getLoginError","getRequestInfo","requestInfo","valid","stateMatch","stateResponse","requestType","parent","statesInParentContext","_getResourceFromState","splitIndex","saveTokenFromHash","error_description","_expiresIn","nonce","exp","getResourceForEndpoint","endpoint","endpoints","configEndpoint","_getHostFromUri","uri","extractedUri","String","_serialize","_addLibMetadata","scope","encodedIdToken","decodedToken","_decodeJwt","base64IdToken","JWSPayload","base64Decoded","_base64DecodeStringUrlSafe","JSON","parse","err","atob","decodeURIComponent","escape","_decode","codes","h1","h2","h3","h4","bits","c1","c2","c3","decoded","charAt","fromCharCode","jwtToken","idTokenPartsRegex","matches","exec","crackedToken","header","JWSSig","_convertUrlSafeToRegularBase64EncodedString","slice","extraQueryParameter","correlationId","join","query","pl","decode","s","_decimalToHex","number","hex","toString","cryptoObj","crypto","msCrypto","getRandomValues","buffer","Uint8Array","guidHolder","r","guidResponse","Math","random","expires","parseInt","round","Date","getTime","iframeId","authFrame","getElementById","createElement","opera","navigator","userAgent","ifr","setAttribute","style","visibility","position","borderWidth","getElementsByTagName","appendChild","insertAdjacentHTML","frames","cacheLocation","_supportsLocalStorage","localStorage","setItem","_supportsSessionStorage","sessionStorage","getItem","copy","attr","_libVersion","timestamp","toUTCString","formattedMessage","stack","inject","conf"],"mappings":"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","file":"salte-auth.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"salte-auth\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"salte-auth\"] = factory();\n\telse\n\t\troot[\"salte-auth\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"salte-auth\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"salte-auth\"] = factory();\n\telse\n\t\troot[\"salte-auth\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\t/* global Logging: false */\n\t\n\tvar AuthenticationContext = function () {\n\t  'use strict';\n\t\n\t  /**\n\t   * @public\n\t   * @class Config\n\t   * @property {clientId}        Identifier assigned to your app by Azure Active Directory\n\t   * @property {redirectUri}     Endpoint at which you expect to receive tokens\n\t   * @property {instance}        This is the URL path to the identity provider that authorize and logout will be called against.\n\t   * @property {endpoints}       Collection of {Endpoint-ResourceId} used for autmatically attaching tokens in webApi calls\n\t   * @property {scope}           This may be used to define the specific authorization(s) being requested from the resource owner.\n\t   */\n\t\n\t  /**\n\t   * User information from idtoken.\n\t   *  @class User\n\t   *  @property {string} userName - username assigned from upn, email, or sub (i.e. subject).\n\t   *  @property {object} profile - properties parsed from idtoken.\n\t   */\n\t\n\t  /**\n\t   * Creates a new AuthenticationContext object.\n\t   * @constructor\n\t   * @param {object}  config               Configuration options for AuthenticationContext\n\t   *\n\t   **/\n\t\n\t  AuthenticationContext = function AuthenticationContext(config) {\n\t    /**\n\t     * Enum for request type\n\t     * @enum {string}\n\t     */\n\t    this.REQUEST_TYPE = {\n\t      LOGIN: 'LOGIN',\n\t      RENEW_TOKEN: 'RENEW_TOKEN',\n\t      UNKNOWN: 'UNKNOWN'\n\t    };\n\t\n\t    /**\n\t     * Enum for storage constants\n\t     * @enum {string}\n\t     */\n\t    this.CONSTANTS = {\n\t      ACCESS_TOKEN: 'access_token',\n\t      EXPIRES_IN: 'expires_in',\n\t      ID_TOKEN: 'id_token',\n\t      ERROR_DESCRIPTION: 'error_description',\n\t      SESSION_STATE: 'session_state',\n\t      STORAGE: {\n\t        TOKEN_KEYS: 'auth.token.keys',\n\t        ACCESS_TOKEN_KEY: 'auth.access.token.key',\n\t        EXPIRATION_KEY: 'auth.expiration.key',\n\t        STATE_LOGIN: 'auth.state.login',\n\t        STATE_RENEW: 'auth.state.renew',\n\t        NONCE_IDTOKEN: 'auth.nonce.idtoken',\n\t        SESSION_STATE: 'auth.session.state',\n\t        USERNAME: 'auth.username',\n\t        IDTOKEN: 'auth.idtoken',\n\t        ERROR: 'auth.error',\n\t        ERROR_DESCRIPTION: 'auth.error.description',\n\t        LOGIN_REQUEST: 'auth.login.request',\n\t        LOGIN_ERROR: 'auth.login.error',\n\t        RENEW_STATUS: 'auth.token.renew.status'\n\t      },\n\t      RESOURCE_DELIMETER: '|',\n\t      LOADFRAME_TIMEOUT: '6000',\n\t      TOKEN_RENEW_STATUS_CANCELED: 'Canceled',\n\t      TOKEN_RENEW_STATUS_COMPLETED: 'Completed',\n\t      TOKEN_RENEW_STATUS_IN_PROGRESS: 'In Progress',\n\t      LOGGING_LEVEL: {\n\t        ERROR: 0,\n\t        WARN: 1,\n\t        INFO: 2,\n\t        VERBOSE: 3\n\t      },\n\t      LEVEL_STRING_MAP: {\n\t        0: 'ERROR:',\n\t        1: 'WARNING:',\n\t        2: 'INFO:',\n\t        3: 'VERBOSE:'\n\t      },\n\t      POPUP_WIDTH: 483,\n\t      POPUP_HEIGHT: 600\n\t    };\n\t\n\t    if (window.AuthenticationContext) {\n\t      return window.AuthenticationContext;\n\t    }\n\t    window.AuthenticationContext = this;\n\t\n\t    // public\n\t    this.config = {};\n\t    this.callback = null;\n\t    this.popUp = false;\n\t    this.isAngular = false;\n\t\n\t    // private\n\t    this._user = null;\n\t    this._activeRenewals = {};\n\t    this._loginInProgress = false;\n\t    this._renewStates = [];\n\t\n\t    window.callBackMappedToRenewStates = {};\n\t    window.callBacksMappedToRenewStates = {};\n\t\n\t    // validate before constructor assignments\n\t    if (config.displayCall && typeof config.displayCall !== 'function') {\n\t      throw new Error('displayCall is not a function');\n\t    }\n\t\n\t    if (!config.clientId) {\n\t      throw new Error('clientId is required');\n\t    }\n\t\n\t    this.config = this._cloneConfig(config);\n\t\n\t    if (this.config.popUp) {\n\t      this.popUp = true;\n\t    }\n\t\n\t    if (this.config.callback && typeof this.config.callback === 'function') {\n\t      this.callback = this.config.callback;\n\t    }\n\t\n\t    if (!this.config.instance || !this.config.instance.match(/^https:\\/\\/.*\\/$/)) {\n\t      throw new Error('instance must be a valid https endpoint that ends in a forward slash.');\n\t    }\n\t\n\t    // App can request idtoken for itself using clientid as resource\n\t    if (!this.config.loginResource) {\n\t      this.config.loginResource = this.config.clientId;\n\t    }\n\t\n\t    if (!this.config.redirectUri) {\n\t      this.config.redirectUri = window.location.href;\n\t    }\n\t\n\t    if (!this.config.anonymousEndpoints) {\n\t      this.config.anonymousEndpoints = [];\n\t    }\n\t\n\t    if (this.config.isAngular) {\n\t      this.isAngular = this.config.isAngular;\n\t    }\n\t\n\t    this.setResponseType(this.config.responseType);\n\t  };\n\t\n\t  AuthenticationContext.prototype.setResponseType = function (responseType) {\n\t    if (responseType) {\n\t      this.config.responseType = responseType;\n\t    } else {\n\t      this.config.responseType = this.CONSTANTS.ID_TOKEN;\n\t    }\n\t  };\n\t\n\t  window.Logging = {\n\t    level: 0,\n\t    log: function log(message) {} // jshint ignore:line\n\t  };\n\t\n\t  /**\n\t   * Gets initial Idtoken for the app backend\n\t   * Saves the resulting Idtoken in localStorage.\n\t   * @param {string} startPage the start page\n\t   */\n\t  AuthenticationContext.prototype.login = function (startPage) {\n\t    // Token is not present and user needs to login\n\t    if (this._loginInProgress) {\n\t      this.info('Login in progress');\n\t      return;\n\t    }\n\t    var expectedState = this._guid();\n\t    this.config.state = expectedState;\n\t    this._idTokenNonce = this._guid();\n\t    if (!startPage) {\n\t      startPage = window.location;\n\t    }\n\t    this.verbose('Expected state: ' + expectedState + ' startPage:' + startPage);\n\t    this._saveItem(this.CONSTANTS.STORAGE.LOGIN_REQUEST, startPage);\n\t    this._saveItem(this.CONSTANTS.STORAGE.LOGIN_ERROR, '');\n\t    this._saveItem(this.CONSTANTS.STORAGE.STATE_LOGIN, expectedState);\n\t    this._saveItem(this.CONSTANTS.STORAGE.NONCE_IDTOKEN, this._idTokenNonce);\n\t    this._saveItem(this.CONSTANTS.STORAGE.ERROR, '');\n\t    this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, '');\n\t    var urlNavigate = this._getNavigateUrl(this.config.responseType, null) + '&nonce=' + encodeURIComponent(this._idTokenNonce);\n\t    this._loginInProgress = true;\n\t    if (this.popUp) {\n\t      this._loginPopup(urlNavigate);\n\t      return;\n\t    }\n\t    if (this.config.displayCall) {\n\t      // User defined way of handling the navigation\n\t      this.config.displayCall(urlNavigate);\n\t    } else {\n\t      this.promptUser(urlNavigate);\n\t    }\n\t  };\n\t\n\t  AuthenticationContext.prototype._openPopup = function (urlNavigate, title, popUpWidth, popUpHeight) {\n\t    try {\n\t      /**\n\t      * adding winLeft and winTop to account for dual monitor\n\t      * using screenLeft and screenTop for IE8 and earlier\n\t      */\n\t      var winLeft = window.screenLeft ? window.screenLeft : window.screenX;\n\t      var winTop = window.screenTop ? window.screenTop : window.screenY;\n\t      /**\n\t      * window.innerWidth displays browser window's height and width excluding toolbars\n\t      * using document.documentElement.clientWidth for IE8 and earlier\n\t      */\n\t      var width = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;\n\t      var height = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;\n\t      var left = width / 2 - popUpWidth / 2 + winLeft;\n\t      var top = height / 2 - popUpHeight / 2 + winTop;\n\t\n\t      var popupWindow = window.open(urlNavigate, title, 'width=' + popUpWidth + ', height=' + popUpHeight + ', top=' + top + ', left=' + left);\n\t      if (popupWindow.focus) {\n\t        popupWindow.focus();\n\t      }\n\t      return popupWindow;\n\t    } catch (e) {\n\t      this.warn('Error opening popup, ' + e.message);\n\t      this._loginInProgress = false;\n\t      return null;\n\t    }\n\t  };\n\t\n\t  AuthenticationContext.prototype._loginPopup = function (urlNavigate) {\n\t    var popupWindow = this._openPopup(urlNavigate, 'login', this.CONSTANTS.POPUP_WIDTH, this.CONSTANTS.POPUP_HEIGHT);\n\t    if (popupWindow === null) {\n\t      this.warn('Popup Window is null. This can happen if you are using IE');\n\t      this._saveItem(this.CONSTANTS.STORAGE.ERROR, 'Error opening popup');\n\t      this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, 'Popup Window is null. This can happen if you are using IE');\n\t      this._saveItem(this.CONSTANTS.STORAGE.LOGIN_ERROR, 'Popup Window is null. This can happen if you are using IE');\n\t      if (this.callback) {\n\t        this.callback(this._getItem(this.CONSTANTS.STORAGE.LOGIN_ERROR), null);\n\t      }\n\t      return;\n\t    }\n\t    var registeredRedirectUri;\n\t    if (this.config.redirectUri.indexOf('#') === -1) {\n\t      registeredRedirectUri = this.config.redirectUri;\n\t    } else {\n\t      registeredRedirectUri = this.config.redirectUri.split('#')[0];\n\t    }\n\t    var that = this;\n\t    var pollTimer = window.setInterval(function () {\n\t      if (!popupWindow || popupWindow.closed || popupWindow.closed === undefined) {\n\t        that._loginInProgress = false;\n\t        window.clearInterval(pollTimer);\n\t      }\n\t      try {\n\t        if (popupWindow.location.href.indexOf(registeredRedirectUri) !== -1) {\n\t          if (that.isAngular) {\n\t            window.location.hash = popupWindow.location.hash;\n\t          } else {\n\t            that.handleWindowCallback(popupWindow.location.hash, popupWindow.location.search);\n\t          }\n\t          window.clearInterval(pollTimer);\n\t          that._loginInProgress = false;\n\t          that.info('Closing popup window');\n\t          popupWindow.close();\n\t        }\n\t      } catch (e) {}\n\t    }, 20);\n\t  };\n\t\n\t  AuthenticationContext.prototype.loginInProgress = function () {\n\t    return this._loginInProgress;\n\t  };\n\t\n\t  AuthenticationContext.prototype._hasResource = function (key) {\n\t    var keys = this._getItem(this.CONSTANTS.STORAGE.TOKEN_KEYS);\n\t    return keys && !this._isEmpty(keys) && keys.indexOf(key + this.CONSTANTS.RESOURCE_DELIMETER) > -1;\n\t  };\n\t\n\t  /**\n\t   * Gets token for the specified resource from local storage cache\n\t   * @param {string}   resource A URI that identifies the resource for which the token is valid.\n\t   * @return {string} token if exists and not expired or null\n\t   */\n\t  AuthenticationContext.prototype.getCachedToken = function (resource) {\n\t    if (!this._hasResource(resource)) {\n\t      return null;\n\t    }\n\t\n\t    var token = this._getItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY + resource);\n\t    var expired = this._getItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY + resource);\n\t\n\t    // If expiration is within offset, it will force renew\n\t    var offset = this.config.expireOffsetSeconds || 120;\n\t\n\t    if (expired && expired > this._now() + offset) {\n\t      return token;\n\t    }\n\t    this._saveItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY + resource, '');\n\t    this._saveItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY + resource, 0);\n\t    return null;\n\t  };\n\t\n\t  /**\n\t   * Retrieves and parse idToken from localstorage\n\t   * @return {User} user object\n\t   */\n\t  AuthenticationContext.prototype.getCachedUser = function () {\n\t    if (this._user) {\n\t      return this._user;\n\t    }\n\t\n\t    var idtoken = this._getItem(this.CONSTANTS.STORAGE.IDTOKEN);\n\t    this._user = this._createUser(idtoken);\n\t    return this._user;\n\t  };\n\t\n\t  AuthenticationContext.prototype.registerCallback = function (expectedState, resource, callback) {\n\t    this._activeRenewals[resource] = expectedState;\n\t    if (!window.callBacksMappedToRenewStates[expectedState]) {\n\t      window.callBacksMappedToRenewStates[expectedState] = [];\n\t    }\n\t    var self = this;\n\t    window.callBacksMappedToRenewStates[expectedState].push(callback);\n\t    if (!window.callBackMappedToRenewStates[expectedState]) {\n\t      window.callBackMappedToRenewStates[expectedState] = function (message, token) {\n\t        for (var i = 0; i < window.callBacksMappedToRenewStates[expectedState].length; ++i) {\n\t          try {\n\t            window.callBacksMappedToRenewStates[expectedState][i](message, token);\n\t          } catch (error) {\n\t            self.warn(error);\n\t          }\n\t        }\n\t        self._activeRenewals[resource] = null;\n\t        window.callBacksMappedToRenewStates[expectedState] = null;\n\t        window.callBackMappedToRenewStates[expectedState] = null;\n\t      };\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Acquires access token with hidden iframe\n\t   * @param {string} resource  ResourceUri identifying the target resource\n\t   * @param {string} callback  ResourceUri identifying the target resource\n\t   */\n\t  AuthenticationContext.prototype._renewToken = function (resource, callback) {\n\t    // use iframe to try refresh token\n\t    // use given resource to create new authz url\n\t    this.info('renewToken is called for resource:' + resource);\n\t    var frameHandle = this._addAuthFrame('authRenewFrame' + resource);\n\t    var expectedState = this._guid() + '|' + resource;\n\t    this.config.state = expectedState;\n\t    // renew happens in iframe, so it keeps javascript context\n\t    this._renewStates.push(expectedState);\n\t\n\t    this.verbose('Renew token Expected state: ' + expectedState);\n\t    var urlNavigate = this._getNavigateUrl('token', resource) + '&prompt=none';\n\t    urlNavigate = this._addHintParameters(urlNavigate);\n\t\n\t    this.registerCallback(expectedState, resource, callback);\n\t    this.verbose('Navigate to:' + urlNavigate);\n\t    this._saveItem(this.CONSTANTS.STORAGE.LOGIN_REQUEST, '');\n\t    frameHandle.src = 'about:blank';\n\t    this._loadFrameTimeout(urlNavigate, 'authRenewFrame' + resource, resource);\n\t  };\n\t\n\t  AuthenticationContext.prototype._renewIdToken = function (callback) {\n\t    // use iframe to try refresh token\n\t    this.info('renewIdToken is called');\n\t    var frameHandle = this._addAuthFrame('authIdTokenFrame');\n\t    var expectedState = this._guid() + '|' + this.config.clientId;\n\t    this._idTokenNonce = this._guid();\n\t    this._saveItem(this.CONSTANTS.STORAGE.NONCE_IDTOKEN, this._idTokenNonce);\n\t    this.config.state = expectedState;\n\t    // renew happens in iframe, so it keeps javascript context\n\t    this._renewStates.push(expectedState);\n\t\n\t    this.verbose('Renew Idtoken Expected state: ' + expectedState);\n\t    var urlNavigate = this._getNavigateUrl(this.config.responseType, null) + '&prompt=none';\n\t    urlNavigate = this._addHintParameters(urlNavigate);\n\t\n\t    urlNavigate += '&nonce=' + encodeURIComponent(this._idTokenNonce);\n\t    this.registerCallback(expectedState, this.config.clientId, callback);\n\t    this.idTokenNonce = null;\n\t    this.verbose('Navigate to:' + urlNavigate);\n\t    this._saveItem(this.CONSTANTS.STORAGE.LOGIN_REQUEST, '');\n\t    frameHandle.src = 'about:blank';\n\t    this._loadFrameTimeout(urlNavigate, 'authIdTokenFrame', this.config.clientId);\n\t  };\n\t\n\t  AuthenticationContext.prototype._urlContainsQueryStringParameter = function (name, url) {\n\t    // regex to detect pattern of a ? or & followed by the name parameter and an equals character\n\t    var regex = new RegExp('[\\\\?&]' + name + '=');\n\t    return regex.test(url);\n\t  };\n\t\n\t  // Calling _loadFrame but with a timeout to signal failure in loadframeStatus. Callbacks are left\n\t  // registered when network errors occur and subsequent token requests for same resource are registered to the pending request\n\t  AuthenticationContext.prototype._loadFrameTimeout = function (urlNavigation, frameName, resource) {\n\t    // set iframe session to pending\n\t    this.verbose('Set loading state to pending for: ' + resource);\n\t    this._saveItem(this.CONSTANTS.STORAGE.RENEW_STATUS + resource, this.CONSTANTS.TOKEN_RENEW_STATUS_IN_PROGRESS);\n\t    this._loadFrame(urlNavigation, frameName);\n\t    var self = this;\n\t    setTimeout(function () {\n\t      if (self._getItem(self.CONSTANTS.STORAGE.RENEW_STATUS + resource) === self.CONSTANTS.TOKEN_RENEW_STATUS_IN_PROGRESS) {\n\t        // fail the iframe session if it's in pending state\n\t        self.verbose('Loading frame has timed out after: ' + self.CONSTANTS.LOADFRAME_TIMEOUT / 1000 + ' seconds for resource ' + resource);\n\t        var expectedState = self._activeRenewals[resource];\n\t        if (expectedState && window.callBackMappedToRenewStates[expectedState]) {\n\t          window.callBackMappedToRenewStates[expectedState]('Token renewal operation failed due to timeout', null);\n\t        }\n\t\n\t        self._saveItem(self.CONSTANTS.STORAGE.RENEW_STATUS + resource, self.CONSTANTS.TOKEN_RENEW_STATUS_CANCELED);\n\t      }\n\t    }, self.CONSTANTS.LOADFRAME_TIMEOUT);\n\t  };\n\t\n\t  AuthenticationContext.prototype._loadFrame = function (urlNavigate, frameName) {\n\t    // This trick overcomes iframe navigation in IE\n\t    // IE does not load the page consistently in iframe\n\t    var self = this;\n\t    self.info('LoadFrame: ' + frameName);\n\t    var frameCheck = frameName;\n\t    setTimeout(function () {\n\t      var frameHandle = self._addAuthFrame(frameCheck);\n\t      if (frameHandle.src === '' || frameHandle.src === 'about:blank') {\n\t        frameHandle.src = urlNavigate;\n\t        self._loadFrame(urlNavigate, frameCheck);\n\t      }\n\t    }, 500);\n\t  };\n\t\n\t  /**\n\t   * Acquire token from cache if not expired and available. Acquires token from iframe if expired.\n\t   * @param {string} resource  ResourceUri identifying the target resource\n\t   * @param {function} callback The callback function\n\t   */\n\t  AuthenticationContext.prototype.acquireToken = function (resource, callback) {\n\t    if (this._isEmpty(resource)) {\n\t      this.warn('resource is required');\n\t      callback('resource is required', null);\n\t      return;\n\t    }\n\t\n\t    var token = this.getCachedToken(resource);\n\t    if (token) {\n\t      this.info('Token is already in cache for resource:' + resource);\n\t      callback(null, token);\n\t      return;\n\t    }\n\t\n\t    if (!this._user) {\n\t      this.warn('User login is required');\n\t      callback('User login is required', null);\n\t      return;\n\t    }\n\t\n\t    // refresh attept with iframe\n\t    // Already renewing for this resource, callback when we get the token.\n\t    if (this._activeRenewals[resource]) {\n\t      // Active renewals contains the state for each renewal.\n\t      this.registerCallback(this._activeRenewals[resource], resource, callback);\n\t    } else if (resource === this.config.clientId) {\n\t      // App uses idtoken to send to api endpoints\n\t      // Default resource is tracked as clientid to store this token\n\t      this.verbose('renewing idtoken');\n\t      this._renewIdToken(callback);\n\t    } else {\n\t      this._renewToken(resource, callback);\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Redirect the Browser to Azure AD Authorization endpoint\n\t   * @param {string} urlNavigate The authorization request url\n\t   */\n\t  AuthenticationContext.prototype.promptUser = function (urlNavigate) {\n\t    if (urlNavigate) {\n\t      this.info('Navigate to:' + urlNavigate);\n\t      window.location.replace(urlNavigate);\n\t    } else {\n\t      this.info('Navigate url is empty');\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Clear cache items.\n\t   */\n\t  AuthenticationContext.prototype.clearCache = function () {\n\t    this._saveItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY, '');\n\t    this._saveItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY, 0);\n\t    this._saveItem(this.CONSTANTS.STORAGE.SESSION_STATE, '');\n\t    this._saveItem(this.CONSTANTS.STORAGE.STATE_LOGIN, '');\n\t    this._renewStates = [];\n\t    this._saveItem(this.CONSTANTS.STORAGE.USERNAME, '');\n\t    this._saveItem(this.CONSTANTS.STORAGE.IDTOKEN, '');\n\t    this._saveItem(this.CONSTANTS.STORAGE.ERROR, '');\n\t    this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, '');\n\t    var keys = this._getItem(this.CONSTANTS.STORAGE.TOKEN_KEYS);\n\t\n\t    if (!this._isEmpty(keys)) {\n\t      keys = keys.split(this.CONSTANTS.RESOURCE_DELIMETER);\n\t      for (var i = 0; i < keys.length; i++) {\n\t        this._saveItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY + keys[i], '');\n\t        this._saveItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY + keys[i], 0);\n\t      }\n\t    }\n\t    this._saveItem(this.CONSTANTS.STORAGE.TOKEN_KEYS, '');\n\t  };\n\t\n\t  /**\n\t   * Clear cache items for a resource.\n\t   * @param {string} resource The resource\n\t   */\n\t  AuthenticationContext.prototype.clearCacheForResource = function (resource) {\n\t    this._saveItem(this.CONSTANTS.STORAGE.STATE_RENEW, '');\n\t    this._saveItem(this.CONSTANTS.STORAGE.ERROR, '');\n\t    this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, '');\n\t    if (this._hasResource(resource)) {\n\t      this._saveItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY + resource, '');\n\t      this._saveItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY + resource, 0);\n\t    }\n\t  };\n\t\n\t  /**\n\t   * Logout user will redirect page to logout endpoint.\n\t   * After logout, it will redirect to post_logout page if provided.\n\t   */\n\t  AuthenticationContext.prototype.logOut = function () {\n\t    this.clearCache();\n\t    var logout = '';\n\t    this._user = null;\n\t\n\t    if (this.config.postLogoutRedirectUri) {\n\t      logout = 'post_logout_redirect_uri=' + encodeURIComponent(this.config.postLogoutRedirectUri);\n\t    }\n\t\n\t    var urlNavigate = this.config.instance + 'logout?' + logout;\n\t    this.info('Logout navigate to: ' + urlNavigate);\n\t    this.promptUser(urlNavigate);\n\t  };\n\t\n\t  AuthenticationContext.prototype._isEmpty = function (str) {\n\t    return typeof str === 'undefined' || !str || str.length === 0;\n\t  };\n\t\n\t  /**\n\t   * Gets a user profile\n\t   * @param {requestCallback} callback The callback that handles the response.\n\t   */\n\t  AuthenticationContext.prototype.getUser = function (callback) {\n\t    // IDToken is first call\n\t    if (typeof callback !== 'function') {\n\t      throw new Error('callback is not a function');\n\t    }\n\t\n\t    // user in memory\n\t    if (this._user) {\n\t      callback(null, this._user);\n\t      return;\n\t    }\n\t\n\t    // frame is used to get idtoken\n\t    var idtoken = this._getItem(this.CONSTANTS.STORAGE.IDTOKEN);\n\t    if (this._isEmpty(idtoken)) {\n\t      this.warn('User information is not available');\n\t      callback('User information is not available');\n\t    } else {\n\t      this.info('User exists in cache: ');\n\t      this._user = this._createUser(idtoken);\n\t      callback(null, this._user);\n\t    }\n\t  };\n\t\n\t  AuthenticationContext.prototype._addHintParameters = function (urlNavigate) {\n\t    // include hint params only if upn is present\n\t    if (this._user && this._user.profile && this._user.profile.hasOwnProperty('upn')) {\n\t      // add login_hint\n\t      urlNavigate += '&login_hint=' + encodeURIComponent(this._user.profile.upn);\n\t\n\t      // don't add domain_hint twice if user provided it in the extraQueryParameter value\n\t      if (!this._urlContainsQueryStringParameter('domain_hint', urlNavigate) && this._user.profile.upn.indexOf('@') > -1) {\n\t        var parts = this._user.profile.upn.split('@');\n\t        // local part can include @ in quotes. Sending last part handles that.\n\t        urlNavigate += '&domain_hint=' + encodeURIComponent(parts[parts.length - 1]);\n\t      }\n\t    }\n\t\n\t    return urlNavigate;\n\t  };\n\t\n\t  AuthenticationContext.prototype._createUser = function (idToken) {\n\t    var user = null;\n\t    var parsedJson = this._extractIdToken(idToken);\n\t    if (parsedJson && parsedJson.hasOwnProperty('aud')) {\n\t      var audienceMatch = false;\n\t\n\t      if (Array.isArray(parsedJson.aud)) {\n\t        // If the ID Token contains multiple audiences then an azp claim must be present and equal to the client id.\n\t        if (parsedJson.hasOwnProperty('azp') && parsedJson.azp.toLowerCase() === this.config.clientId.toLowerCase()) {\n\t          for (var i = 0; i < parsedJson.aud.length; i++) {\n\t            if (parsedJson.aud[i].toLowerCase() === this.config.clientId.toLowerCase()) {\n\t              audienceMatch = true;\n\t              break;\n\t            }\n\t          }\n\t        }\n\t      } else {\n\t        audienceMatch = parsedJson.aud.toLowerCase() === this.config.clientId.toLowerCase();\n\t      }\n\t\n\t      if (audienceMatch) {\n\t        user = {\n\t          userName: '',\n\t          profile: parsedJson\n\t        };\n\t\n\t        if (parsedJson.hasOwnProperty('upn')) {\n\t          user.userName = parsedJson.upn;\n\t        } else if (parsedJson.hasOwnProperty('email')) {\n\t          user.userName = parsedJson.email;\n\t        } else if (parsedJson.hasOwnProperty('sub')) {\n\t          user.userName = parsedJson.sub;\n\t        }\n\t      } else {\n\t        this.warn('IdToken has invalid aud/azp field');\n\t      }\n\t    }\n\t\n\t    return user;\n\t  };\n\t\n\t  AuthenticationContext.prototype._getHash = function (hash) {\n\t    if (hash.indexOf('#/') > -1) {\n\t      hash = hash.substring(hash.indexOf('#/') + 2);\n\t    } else if (hash.indexOf('#') > -1) {\n\t      hash = hash.substring(1);\n\t    }\n\t\n\t    return hash;\n\t  };\n\t\n\t  AuthenticationContext.prototype._getSearch = function (search) {\n\t    if (search.indexOf('?') > -1) {\n\t      search = search.substring(1);\n\t    }\n\t\n\t    return search;\n\t  };\n\t\n\t  AuthenticationContext.prototype._getParameters = function (hash, search) {\n\t    var parameters = {};\n\t\n\t    if (hash) {\n\t      hash = this._getHash(hash);\n\t      parameters = this._deserialize(hash);\n\t    }\n\t\n\t    if (search) {\n\t      search = this._getSearch(search);\n\t      var searchParameters = this._deserialize(search);\n\t      parameters = this._extend(parameters, searchParameters);\n\t    }\n\t\n\t    return parameters;\n\t  };\n\t\n\t  AuthenticationContext.prototype._extend = function (obj, src) {\n\t    for (var key in src) {\n\t      if (src.hasOwnProperty(key)) {\n\t        obj[key] = src[key];\n\t      }\n\t    }\n\t    return obj;\n\t  };\n\t\n\t  /**\n\t   * Checks if hash contains access token or id token or error_description\n\t   * @param {string} hash  -  Hash passed from redirect page\n\t   * @param {string} search  -  Search passed from redirect page\n\t   * @return {boolean} exists if all the parameters exist\n\t   */\n\t  AuthenticationContext.prototype.isCallback = function (hash, search) {\n\t    var parameters = this._getParameters(hash, search);\n\t\n\t    return parameters.hasOwnProperty(this.CONSTANTS.ERROR_DESCRIPTION) || parameters.hasOwnProperty(this.CONSTANTS.ACCESS_TOKEN) || parameters.hasOwnProperty(this.CONSTANTS.ID_TOKEN);\n\t  };\n\t\n\t  /**\n\t   * Gets login error\n\t   * @return {string} error message related to login\n\t   */\n\t  AuthenticationContext.prototype.getLoginError = function () {\n\t    return this._getItem(this.CONSTANTS.STORAGE.LOGIN_ERROR);\n\t  };\n\t\n\t  /**\n\t   * Gets requestInfo from given hash.\n\t   * @param {string} hash  -  Hash passed from redirect page\n\t   * @param {string} search  -  Search passed from redirect page\n\t   * @return {string} error message related to login\n\t   */\n\t  AuthenticationContext.prototype.getRequestInfo = function (hash, search) {\n\t    var parameters = this._getParameters(hash, search);\n\t    var requestInfo = {\n\t      valid: false,\n\t      parameters: {},\n\t      stateMatch: false,\n\t      stateResponse: '',\n\t      requestType: this.REQUEST_TYPE.UNKNOWN\n\t    };\n\t\n\t    if (parameters) {\n\t      requestInfo.parameters = parameters;\n\t      if (parameters.hasOwnProperty(this.CONSTANTS.ERROR_DESCRIPTION) || parameters.hasOwnProperty(this.CONSTANTS.ACCESS_TOKEN) || parameters.hasOwnProperty(this.CONSTANTS.ID_TOKEN)) {\n\t        requestInfo.valid = true;\n\t\n\t        // which call\n\t        var stateResponse = '';\n\t        if (parameters.hasOwnProperty('state')) {\n\t          this.verbose('State: ' + parameters.state);\n\t          stateResponse = parameters.state;\n\t        } else {\n\t          this.warn('No state returned');\n\t          return requestInfo;\n\t        }\n\t\n\t        requestInfo.stateResponse = stateResponse;\n\t\n\t        // async calls can fire iframe and login request at the same time if developer does not use the API as expected\n\t        // incoming callback needs to be looked up to find the request type\n\t        if (stateResponse === this._getItem(this.CONSTANTS.STORAGE.STATE_LOGIN)) {\n\t          requestInfo.requestType = this.REQUEST_TYPE.LOGIN;\n\t          requestInfo.stateMatch = true;\n\t          return requestInfo;\n\t        }\n\t\n\t        // external api requests may have many renewtoken requests for different resource\n\t        if (!requestInfo.stateMatch && window.parent && window.parent.AuthenticationContext) {\n\t          var statesInParentContext = window.parent.AuthenticationContext._renewStates;\n\t          for (var i = 0; i < statesInParentContext.length; i++) {\n\t            if (statesInParentContext[i] === requestInfo.stateResponse) {\n\t              requestInfo.requestType = this.REQUEST_TYPE.RENEW_TOKEN;\n\t              requestInfo.stateMatch = true;\n\t              break;\n\t            }\n\t          }\n\t        }\n\t      }\n\t    }\n\t\n\t    return requestInfo;\n\t  };\n\t\n\t  AuthenticationContext.prototype._getResourceFromState = function (state) {\n\t    if (state) {\n\t      var splitIndex = state.indexOf('|');\n\t      if (splitIndex > -1 && splitIndex + 1 < state.length) {\n\t        return state.substring(splitIndex + 1);\n\t      }\n\t    }\n\t\n\t    return '';\n\t  };\n\t\n\t  /**\n\t   * Saves token from hash that is received from redirect.\n\t   * @param {string} requestInfo Hash passed from redirect page\n\t   */\n\t  AuthenticationContext.prototype.saveTokenFromHash = function (requestInfo) {\n\t    this.info('State status:' + requestInfo.stateMatch + '; Request type:' + requestInfo.requestType);\n\t    this._saveItem(this.CONSTANTS.STORAGE.ERROR, '');\n\t    this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, '');\n\t\n\t    var resource = this._getResourceFromState(requestInfo.stateResponse);\n\t\n\t    // Record error\n\t    if (requestInfo.parameters.hasOwnProperty(this.CONSTANTS.ERROR_DESCRIPTION)) {\n\t      this.info('Error :' + requestInfo.parameters.error + '; Error description:' + requestInfo.parameters[this.CONSTANTS.ERROR_DESCRIPTION]);\n\t      this._saveItem(this.CONSTANTS.STORAGE.ERROR, requestInfo.parameters.error);\n\t      this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, requestInfo.parameters[this.CONSTANTS.ERROR_DESCRIPTION]);\n\t\n\t      if (requestInfo.requestType === this.REQUEST_TYPE.LOGIN) {\n\t        this._loginInProgress = false;\n\t        this._saveItem(this.CONSTANTS.STORAGE.LOGIN_ERROR, requestInfo.parameters.error_description); // jshint ignore:line\n\t      }\n\t    } else if (requestInfo.stateMatch) {\n\t      // record tokens to storage if exists\n\t      this.info('State is right');\n\t      if (requestInfo.parameters.hasOwnProperty(this.CONSTANTS.SESSION_STATE)) {\n\t        this._saveItem(this.CONSTANTS.STORAGE.SESSION_STATE, requestInfo.parameters[this.CONSTANTS.SESSION_STATE]);\n\t      }\n\t\n\t      var keys;\n\t\n\t      if (requestInfo.parameters.hasOwnProperty(this.CONSTANTS.ACCESS_TOKEN)) {\n\t        this.info('Fragment has access token');\n\t\n\t        if (!this._hasResource(resource)) {\n\t          keys = this._getItem(this.CONSTANTS.STORAGE.TOKEN_KEYS) || '';\n\t          this._saveItem(this.CONSTANTS.STORAGE.TOKEN_KEYS, keys + resource + this.CONSTANTS.RESOURCE_DELIMETER);\n\t        }\n\t        // save token with related resource\n\t        this._saveItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY + resource, requestInfo.parameters[this.CONSTANTS.ACCESS_TOKEN]);\n\t        this._saveItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY + resource, this._expiresIn(requestInfo.parameters[this.CONSTANTS.EXPIRES_IN]));\n\t      }\n\t\n\t      if (requestInfo.parameters.hasOwnProperty(this.CONSTANTS.ID_TOKEN)) {\n\t        this.info('Fragment has id token');\n\t        this._loginInProgress = false;\n\t\n\t        this._user = this._createUser(requestInfo.parameters[this.CONSTANTS.ID_TOKEN]);\n\t\n\t        if (this._user && this._user.profile) {\n\t          if (this._user.profile.nonce === this._getItem(this.CONSTANTS.STORAGE.NONCE_IDTOKEN)) {\n\t            this._saveItem(this.CONSTANTS.STORAGE.IDTOKEN, requestInfo.parameters[this.CONSTANTS.ID_TOKEN]);\n\t\n\t            // Save idtoken as access token for app itself\n\t            resource = this.config.loginResource ? this.config.loginResource : this.config.clientId;\n\t\n\t            if (!this._hasResource(resource)) {\n\t              keys = this._getItem(this.CONSTANTS.STORAGE.TOKEN_KEYS) || '';\n\t              this._saveItem(this.CONSTANTS.STORAGE.TOKEN_KEYS, keys + resource + this.CONSTANTS.RESOURCE_DELIMETER);\n\t            }\n\t            this._saveItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY + resource, requestInfo.parameters[this.CONSTANTS.ID_TOKEN]);\n\t            this._saveItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY + resource, this._user.profile.exp);\n\t          } else {\n\t            this._user = null;\n\t            this._saveItem(this.CONSTANTS.STORAGE.LOGIN_ERROR, 'Nonce is not same as ' + this._idTokenNonce);\n\t          }\n\t        } else {\n\t          this._saveItem(this.CONSTANTS.STORAGE.ERROR, 'invalid id_token');\n\t          this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, 'Invalid id_token. id_token: ' + requestInfo.parameters[this.CONSTANTS.ID_TOKEN]);\n\t        }\n\t      }\n\t    } else {\n\t      this._saveItem(this.CONSTANTS.STORAGE.ERROR, 'Invalid_state');\n\t      this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, 'Invalid_state. state: ' + requestInfo.stateResponse);\n\t    }\n\t    this._saveItem(this.CONSTANTS.STORAGE.RENEW_STATUS + resource, this.CONSTANTS.TOKEN_RENEW_STATUS_COMPLETED);\n\t  };\n\t\n\t  /**\n\t   * Gets resource for given endpoint if mapping is provided with config.\n\t   * @param {string} endpoint API endpoint\n\t   * @return {string} resource for this API endpoint\n\t   */\n\t  AuthenticationContext.prototype.getResourceForEndpoint = function (endpoint) {\n\t    if (this.config && this.config.endpoints) {\n\t      for (var configEndpoint in this.config.endpoints) {\n\t        // configEndpoint is like /api/Todo requested endpoint can be /api/Todo/1\n\t        if (endpoint.indexOf(configEndpoint) > -1) {\n\t          return this.config.endpoints[configEndpoint];\n\t        }\n\t      }\n\t    }\n\t\n\t    // default resource will be clientid if nothing specified\n\t    // App will use idtoken for calls to itself\n\t    // check if it's staring from http or https, needs to match with app host\n\t    if (endpoint.indexOf('http://') > -1 || endpoint.indexOf('https://') > -1) {\n\t      if (this._getHostFromUri(endpoint) === this._getHostFromUri(this.config.redirectUri)) {\n\t        return this.config.loginResource;\n\t      }\n\t    } else {\n\t      // in angular level, the url for $http interceptor call could be relative url,\n\t      // if it's relative call, we'll treat it as app backend call.\n\t      // if user specified list of anonymous endpoints, no need to send token to these endpoints, return null.\n\t      if (this.config && this.config.anonymousEndpoints) {\n\t        for (var i = 0; i < this.config.anonymousEndpoints.length; i++) {\n\t          if (endpoint.indexOf(this.config.anonymousEndpoints[i]) > -1) {\n\t            return null;\n\t          }\n\t        }\n\t      }\n\t      // all other app's backend calls are secured.\n\t      return this.config.loginResource;\n\t    }\n\t\n\t    // if not the app's own backend or not a domain listed in the endpoints structure\n\t    return null;\n\t  };\n\t\n\t  AuthenticationContext.prototype._getHostFromUri = function (uri) {\n\t    // remove http:// or https:// from uri\n\t    var extractedUri = String(uri).replace(/^(https?:)\\/\\//, '');\n\t\n\t    extractedUri = extractedUri.split('/')[0];\n\t    return extractedUri;\n\t  };\n\t\n\t  /* exported  oauth2Callback */\n\t  AuthenticationContext.prototype.handleWindowCallback = function (hash, search) {\n\t    // This is for regular javascript usage for redirect handling\n\t    // need to make sure this is for callback\n\t    if (!hash) {\n\t      hash = window.location.hash;\n\t    }\n\t\n\t    if (!search) {\n\t      search = window.location.search;\n\t    }\n\t\n\t    if (this.isCallback(hash, search)) {\n\t      var requestInfo = this.getRequestInfo(hash, search);\n\t      this.info('Returned from redirect url');\n\t      this.saveTokenFromHash(requestInfo);\n\t      var callback = null;\n\t      if (requestInfo.requestType === this.REQUEST_TYPE.RENEW_TOKEN && window.parent && window.parent !== window) {\n\t        // iframe call but same single page\n\t        this.verbose('Window is in iframe');\n\t        callback = window.parent.callBackMappedToRenewStates[requestInfo.stateResponse];\n\t        if (callback) {\n\t          callback(this._getItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION), requestInfo.parameters[this.CONSTANTS.ACCESS_TOKEN] || requestInfo.parameters[this.CONSTANTS.ID_TOKEN]);\n\t        }\n\t        return;\n\t      } else if (requestInfo.requestType === this.REQUEST_TYPE.LOGIN) {\n\t        callback = this.callback;\n\t        if (callback) {\n\t          callback(this._getItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION), requestInfo.parameters[this.CONSTANTS.ID_TOKEN]);\n\t        }\n\t      }\n\t      // No need to redirect user in case of popup\n\t      if (!this.popUp) {\n\t        window.location = this._getItem(this.CONSTANTS.STORAGE.LOGIN_REQUEST);\n\t      }\n\t    }\n\t  };\n\t\n\t  AuthenticationContext.prototype._getNavigateUrl = function (responseType, resource) {\n\t    var urlNavigate = this.config.instance + 'authorize' + this._serialize(responseType, this.config, resource) + this._addLibMetadata();\n\t    if (this.config.scope) {\n\t      urlNavigate += '&scope=' + encodeURIComponent(this.config.scope);\n\t    }\n\t    this.info('Navigate url:' + urlNavigate);\n\t    return urlNavigate;\n\t  };\n\t\n\t  AuthenticationContext.prototype._extractIdToken = function (encodedIdToken) {\n\t    // id token will be decoded to get the username\n\t    var decodedToken = this._decodeJwt(encodedIdToken);\n\t    if (!decodedToken) {\n\t      return null;\n\t    }\n\t\n\t    try {\n\t      var base64IdToken = decodedToken.JWSPayload;\n\t      var base64Decoded = this._base64DecodeStringUrlSafe(base64IdToken);\n\t      if (!base64Decoded) {\n\t        this.info('The returned id_token could not be base64 url safe decoded.');\n\t        return null;\n\t      }\n\t\n\t      // ECMA script has JSON built-in support\n\t      return JSON.parse(base64Decoded);\n\t    } catch (err) {\n\t      this.error('The returned id_token could not be decoded', err);\n\t    }\n\t\n\t    return null;\n\t  };\n\t\n\t  AuthenticationContext.prototype._base64DecodeStringUrlSafe = function (base64IdToken) {\n\t    // html5 should support atob function for decoding\n\t    base64IdToken = base64IdToken.replace(/-/g, '+').replace(/_/g, '/');\n\t    if (window.atob) {\n\t      return decodeURIComponent(escape(window.atob(base64IdToken)));\n\t    }\n\t    return decodeURIComponent(escape(this._decode(base64IdToken)));\n\t  };\n\t\n\t  // Take https://cdnjs.cloudflare.com/ajax/libs/Base64/0.3.0/base64.js and https://en.wikipedia.org/wiki/Base64 as reference.\n\t  AuthenticationContext.prototype._decode = function (base64IdToken) {\n\t    var codes = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\t    base64IdToken = String(base64IdToken).replace(/[=]+$/, '');\n\t\n\t    var length = base64IdToken.length;\n\t    if (length % 4 === 1) {\n\t      throw new Error('The token to be decoded is not correctly encoded.');\n\t    }\n\t\n\t    var h1, h2, h3, h4, bits, c1, c2, c3;\n\t    var decoded = '';\n\t    for (var i = 0; i < length; i += 4) {\n\t      // Every 4 base64 encoded character will be converted to 3 byte string, which is 24 bits\n\t      // then 6 bits per base64 encoded character\n\t      h1 = codes.indexOf(base64IdToken.charAt(i));\n\t      h2 = codes.indexOf(base64IdToken.charAt(i + 1));\n\t      h3 = codes.indexOf(base64IdToken.charAt(i + 2));\n\t      h4 = codes.indexOf(base64IdToken.charAt(i + 3));\n\t\n\t      // For padding, if last two are '='\n\t      if (i + 2 === length - 1) {\n\t        bits = h1 << 18 | h2 << 12 | h3 << 6;\n\t        c1 = bits >> 16 & 255;\n\t        c2 = bits >> 8 & 255;\n\t        decoded += String.fromCharCode(c1, c2);\n\t        break;\n\t      } else if (i + 1 === length - 1) {\n\t        // if last one is '='\n\t        bits = h1 << 18 | h2 << 12;\n\t        c1 = bits >> 16 & 255;\n\t        decoded += String.fromCharCode(c1);\n\t        break;\n\t      }\n\t\n\t      bits = h1 << 18 | h2 << 12 | h3 << 6 | h4;\n\t\n\t      // then convert to 3 byte chars\n\t      c1 = bits >> 16 & 255;\n\t      c2 = bits >> 8 & 255;\n\t      c3 = bits & 255;\n\t\n\t      decoded += String.fromCharCode(c1, c2, c3);\n\t    }\n\t\n\t    return decoded;\n\t  };\n\t\n\t  // Auth.node js crack function\n\t  AuthenticationContext.prototype._decodeJwt = function (jwtToken) {\n\t    if (this._isEmpty(jwtToken)) {\n\t      return null;\n\t    }\n\t\n\t    var idTokenPartsRegex = /^([^\\.\\s]*)\\.([^\\.\\s]+)\\.([^\\.\\s]*)$/;\n\t\n\t    var matches = idTokenPartsRegex.exec(jwtToken);\n\t    if (!matches || matches.length < 4) {\n\t      this.warn('The returned id_token is not parseable.');\n\t      return null;\n\t    }\n\t\n\t    var crackedToken = {\n\t      header: matches[1],\n\t      JWSPayload: matches[2],\n\t      JWSSig: matches[3]\n\t    };\n\t\n\t    return crackedToken;\n\t  };\n\t\n\t  AuthenticationContext.prototype._convertUrlSafeToRegularBase64EncodedString = function (str) {\n\t    return str.replace('-', '+').replace('_', '/');\n\t  };\n\t\n\t  AuthenticationContext.prototype._serialize = function (responseType, obj, resource) {\n\t    var str = [];\n\t    if (obj !== null) {\n\t      str.push('?response_type=' + encodeURIComponent(responseType));\n\t      str.push('client_id=' + encodeURIComponent(obj.clientId));\n\t      if (resource) {\n\t        str.push('resource=' + encodeURIComponent(resource));\n\t      }\n\t\n\t      str.push('redirect_uri=' + encodeURIComponent(obj.redirectUri));\n\t      str.push('state=' + encodeURIComponent(obj.state));\n\t\n\t      if (obj.hasOwnProperty('slice')) {\n\t        str.push('slice=' + encodeURIComponent(obj.slice));\n\t      }\n\t\n\t      if (obj.hasOwnProperty('extraQueryParameter')) {\n\t        str.push(obj.extraQueryParameter);\n\t      }\n\t\n\t      var correlationId = obj.correlationId ? obj.correlationId : this._guid();\n\t      str.push('client-request-id=' + encodeURIComponent(correlationId));\n\t    }\n\t\n\t    return str.join('&');\n\t  };\n\t\n\t  AuthenticationContext.prototype._deserialize = function (query) {\n\t    var match,\n\t        pl = /\\+/g,\n\t        // Regex for replacing addition symbol with a space\n\t    search = /([^&=]+)=([^&]*)/g,\n\t        decode = function decode(s) {\n\t      return decodeURIComponent(s.replace(pl, ' '));\n\t    },\n\t        obj = {};\n\t    match = search.exec(query);\n\t    while (match) {\n\t      obj[decode(match[1])] = decode(match[2]);\n\t      match = search.exec(query);\n\t    }\n\t\n\t    return obj;\n\t  };\n\t\n\t  AuthenticationContext.prototype._decimalToHex = function (number) {\n\t    var hex = number.toString(16);\n\t    while (hex.length < 2) {\n\t      hex = '0' + hex;\n\t    }\n\t    return hex;\n\t  };\n\t\n\t  /* jshint ignore:start */\n\t  AuthenticationContext.prototype._guid = function () {\n\t    // RFC4122: The version 4 UUID is meant for generating UUIDs from truly-random or\n\t    // pseudo-random numbers.\n\t    // The algorithm is as follows:\n\t    //     Set the two most significant bits (bits 6 and 7) of the\n\t    //        clock_seq_hi_and_reserved to zero and one, respectively.\n\t    //     Set the four most significant bits (bits 12 through 15) of the\n\t    //        time_hi_and_version field to the 4-bit version number from\n\t    //        Section 4.1.3. Version4\n\t    //     Set all the other bits to randomly (or pseudo-randomly) chosen\n\t    //     values.\n\t    // UUID                   = time-low \"-\" time-mid \"-\"time-high-and-version \"-\"clock-seq-reserved and low(2hexOctet)\"-\" node\n\t    // time-low               = 4hexOctet\n\t    // time-mid               = 2hexOctet\n\t    // time-high-and-version  = 2hexOctet\n\t    // clock-seq-and-reserved = hexOctet:\n\t    // clock-seq-low          = hexOctet\n\t    // node                   = 6hexOctet\n\t    // Format: xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\n\t    // y could be 1000, 1001, 1010, 1011 since most significant two bits needs to be 10\n\t    // y values are 8, 9, A, B\n\t    var cryptoObj = window.crypto || window.msCrypto; // for IE 11\n\t    if (cryptoObj && cryptoObj.getRandomValues) {\n\t      var buffer = new Uint8Array(16);\n\t      cryptoObj.getRandomValues(buffer);\n\t      // buffer[6] and buffer[7] represents the time_hi_and_version field. We will set the four most significant bits (4 through 7) of buffer[6] to represent decimal number 4 (UUID version number).\n\t      buffer[6] |= 0x40; // buffer[6] | 01000000 will set the 6 bit to 1.\n\t      buffer[6] &= 0x4f; // buffer[6] & 01001111 will set the 4, 5, and 7 bit to 0 such that bits 4-7 == 0100 = \"4\".\n\t      // buffer[8] represents the clock_seq_hi_and_reserved field. We will set the two most significant bits (6 and 7) of the clock_seq_hi_and_reserved to zero and one, respectively.\n\t      buffer[8] |= 0x80; // buffer[8] | 10000000 will set the 7 bit to 1.\n\t      buffer[8] &= 0xbf; // buffer[8] & 10111111 will set the 6 bit to 0.\n\t      return this._decimalToHex(buffer[0]) + this._decimalToHex(buffer[1]) + this._decimalToHex(buffer[2]) + this._decimalToHex(buffer[3]) + '-' + this._decimalToHex(buffer[4]) + this._decimalToHex(buffer[5]) + '-' + this._decimalToHex(buffer[6]) + this._decimalToHex(buffer[7]) + '-' + this._decimalToHex(buffer[8]) + this._decimalToHex(buffer[9]) + '-' + this._decimalToHex(buffer[10]) + this._decimalToHex(buffer[11]) + this._decimalToHex(buffer[12]) + this._decimalToHex(buffer[13]) + this._decimalToHex(buffer[14]) + this._decimalToHex(buffer[15]);\n\t    }\n\t    var guidHolder = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx';\n\t    var hex = '0123456789abcdef';\n\t    var r = 0;\n\t    var guidResponse = \"\";\n\t    for (var i = 0; i < 36; i++) {\n\t      if (guidHolder[i] !== '-' && guidHolder[i] !== '4') {\n\t        // each x and y needs to be random\n\t        r = Math.random() * 16 | 0;\n\t      }\n\t      if (guidHolder[i] === 'x') {\n\t        guidResponse += hex[r];\n\t      } else if (guidHolder[i] === 'y') {\n\t        // clock-seq-and-reserved first hex is filtered and remaining hex values are random\n\t        r &= 0x3; // bit and with 0011 to set pos 2 to zero ?0??\n\t        r |= 0x8; // set pos 3 to 1 as 1???\n\t        guidResponse += hex[r];\n\t      } else {\n\t        guidResponse += guidHolder[i];\n\t      }\n\t    }\n\t    return guidResponse;\n\t  };\n\t\n\t  AuthenticationContext.prototype._expiresIn = function (expires) {\n\t    return this._now() + parseInt(expires, 10);\n\t  };\n\t\n\t  AuthenticationContext.prototype._now = function () {\n\t    return Math.round(new Date().getTime() / 1000.0);\n\t  };\n\t\n\t  AuthenticationContext.prototype._addAuthFrame = function (iframeId) {\n\t    if (typeof iframeId === 'undefined') {\n\t      return;\n\t    }\n\t\n\t    this.info('Add auth frame to document:' + iframeId);\n\t    var authFrame = document.getElementById(iframeId);\n\t\n\t    if (!authFrame) {\n\t      if (document.createElement && document.documentElement && (window.opera || window.navigator.userAgent.indexOf('MSIE 5.0') === -1)) {\n\t        var ifr = document.createElement('iframe');\n\t        ifr.setAttribute('id', iframeId);\n\t        ifr.style.visibility = 'hidden';\n\t        ifr.style.position = 'absolute';\n\t        ifr.style.width = ifr.style.height = ifr.borderWidth = '0px';\n\t\n\t        authFrame = document.getElementsByTagName('body')[0].appendChild(ifr);\n\t      } else if (document.body && document.body.insertAdjacentHTML) {\n\t        document.body.insertAdjacentHTML('beforeEnd', '<iframe name=\"' + iframeId + '\" id=\"' + iframeId + '\" style=\"display:none\"></iframe>');\n\t      }\n\t      if (window.frames && window.frames[iframeId]) {\n\t        authFrame = window.frames[iframeId];\n\t      }\n\t    }\n\t\n\t    return authFrame;\n\t  };\n\t\n\t  AuthenticationContext.prototype._saveItem = function (key, obj) {\n\t    if (this.config && this.config.cacheLocation && this.config.cacheLocation === 'localStorage') {\n\t      if (!this._supportsLocalStorage()) {\n\t        this.info('Local storage is not supported');\n\t        return false;\n\t      }\n\t\n\t      localStorage.setItem(key, obj);\n\t\n\t      return true;\n\t    }\n\t\n\t    // Default as session storage\n\t    if (!this._supportsSessionStorage()) {\n\t      this.info('Session storage is not supported');\n\t      return false;\n\t    }\n\t\n\t    sessionStorage.setItem(key, obj);\n\t    return true;\n\t  };\n\t\n\t  AuthenticationContext.prototype._getItem = function (key) {\n\t    if (this.config && this.config.cacheLocation && this.config.cacheLocation === 'localStorage') {\n\t      if (!this._supportsLocalStorage()) {\n\t        this.info('Local storage is not supported');\n\t        return null;\n\t      }\n\t\n\t      return localStorage.getItem(key);\n\t    }\n\t\n\t    // Default as session storage\n\t    if (!this._supportsSessionStorage()) {\n\t      this.info('Session storage is not supported');\n\t      return null;\n\t    }\n\t\n\t    return sessionStorage.getItem(key);\n\t  };\n\t\n\t  AuthenticationContext.prototype._supportsLocalStorage = function () {\n\t    try {\n\t      return 'localStorage' in window && window.localStorage;\n\t    } catch (e) {\n\t      return false;\n\t    }\n\t  };\n\t\n\t  AuthenticationContext.prototype._supportsSessionStorage = function () {\n\t    try {\n\t      return 'sessionStorage' in window && window.sessionStorage;\n\t    } catch (e) {\n\t      return false;\n\t    }\n\t  };\n\t\n\t  AuthenticationContext.prototype._cloneConfig = function (obj) {\n\t    if (obj === null || (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object') {\n\t      return obj;\n\t    }\n\t\n\t    var copy = {};\n\t    for (var attr in obj) {\n\t      if (obj.hasOwnProperty(attr)) {\n\t        copy[attr] = obj[attr];\n\t      }\n\t    }\n\t    return copy;\n\t  };\n\t\n\t  AuthenticationContext.prototype._addLibMetadata = function () {\n\t    // x-client-SKU\n\t    // x-client-Ver\n\t    return '&x-client-SKU=Js&x-client-Ver=' + this._libVersion();\n\t  };\n\t\n\t  AuthenticationContext.prototype.log = function (level, message, error) {\n\t    if (level <= Logging.level) {\n\t      var timestamp = new Date().toUTCString();\n\t      var formattedMessage = '';\n\t\n\t      if (this.config.correlationId) {\n\t        formattedMessage = timestamp + ':' + this.config.correlationId + '-' + this._libVersion() + '-' + this.CONSTANTS.LEVEL_STRING_MAP[level] + ' ' + message;\n\t      } else {\n\t        formattedMessage = timestamp + ':' + this._libVersion() + '-' + this.CONSTANTS.LEVEL_STRING_MAP[level] + ' ' + message;\n\t      }\n\t\n\t      if (error) {\n\t        formattedMessage += '\\nstack:\\n' + error.stack;\n\t      }\n\t\n\t      Logging.log(formattedMessage);\n\t    }\n\t  };\n\t\n\t  AuthenticationContext.prototype.error = function (message, error) {\n\t    this.log(this.CONSTANTS.LOGGING_LEVEL.ERROR, message, error);\n\t  };\n\t\n\t  AuthenticationContext.prototype.warn = function (message) {\n\t    this.log(this.CONSTANTS.LOGGING_LEVEL.WARN, message, null);\n\t  };\n\t\n\t  AuthenticationContext.prototype.info = function (message) {\n\t    this.log(this.CONSTANTS.LOGGING_LEVEL.INFO, message, null);\n\t  };\n\t\n\t  AuthenticationContext.prototype.verbose = function (message) {\n\t    this.log(this.CONSTANTS.LOGGING_LEVEL.VERBOSE, message, null);\n\t  };\n\t\n\t  AuthenticationContext.prototype._libVersion = function () {\n\t    return '1.0.12';\n\t  };\n\t\n\t  if (typeof module !== 'undefined' && module.exports) {\n\t    module.exports = AuthenticationContext;\n\t    module.exports.inject = function (conf) {\n\t      return new AuthenticationContext(conf);\n\t    };\n\t  }\n\t\n\t  return AuthenticationContext;\n\t}();\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** salte-auth.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 820508c0cd44ee1eba48\n **/","/* global Logging: false */\n\nvar AuthenticationContext = (function() {\n  'use strict';\n\n    /**\n     * @public\n     * @class Config\n     * @property {clientId}        Identifier assigned to your app by Azure Active Directory\n     * @property {redirectUri}     Endpoint at which you expect to receive tokens\n     * @property {instance}        This is the URL path to the identity provider that authorize and logout will be called against.\n     * @property {endpoints}       Collection of {Endpoint-ResourceId} used for autmatically attaching tokens in webApi calls\n     * @property {scope}           This may be used to define the specific authorization(s) being requested from the resource owner.\n     */\n\n    /**\n     * User information from idtoken.\n     *  @class User\n     *  @property {string} userName - username assigned from upn, email, or sub (i.e. subject).\n     *  @property {object} profile - properties parsed from idtoken.\n     */\n\n    /**\n     * Creates a new AuthenticationContext object.\n     * @constructor\n     * @param {object}  config               Configuration options for AuthenticationContext\n     *\n     **/\n  AuthenticationContext = function(config) {\n        /**\n         * Enum for request type\n         * @enum {string}\n         */\n    this.REQUEST_TYPE = {\n      LOGIN: 'LOGIN',\n      RENEW_TOKEN: 'RENEW_TOKEN',\n      UNKNOWN: 'UNKNOWN'\n    };\n\n        /**\n         * Enum for storage constants\n         * @enum {string}\n         */\n    this.CONSTANTS = {\n      ACCESS_TOKEN: 'access_token',\n      EXPIRES_IN: 'expires_in',\n      ID_TOKEN: 'id_token',\n      ERROR_DESCRIPTION: 'error_description',\n      SESSION_STATE: 'session_state',\n      STORAGE: {\n        TOKEN_KEYS: 'auth.token.keys',\n        ACCESS_TOKEN_KEY: 'auth.access.token.key',\n        EXPIRATION_KEY: 'auth.expiration.key',\n        STATE_LOGIN: 'auth.state.login',\n        STATE_RENEW: 'auth.state.renew',\n        NONCE_IDTOKEN: 'auth.nonce.idtoken',\n        SESSION_STATE: 'auth.session.state',\n        USERNAME: 'auth.username',\n        IDTOKEN: 'auth.idtoken',\n        ERROR: 'auth.error',\n        ERROR_DESCRIPTION: 'auth.error.description',\n        LOGIN_REQUEST: 'auth.login.request',\n        LOGIN_ERROR: 'auth.login.error',\n        RENEW_STATUS: 'auth.token.renew.status'\n      },\n      RESOURCE_DELIMETER: '|',\n      LOADFRAME_TIMEOUT: '6000',\n      TOKEN_RENEW_STATUS_CANCELED: 'Canceled',\n      TOKEN_RENEW_STATUS_COMPLETED: 'Completed',\n      TOKEN_RENEW_STATUS_IN_PROGRESS: 'In Progress',\n      LOGGING_LEVEL: {\n        ERROR: 0,\n        WARN: 1,\n        INFO: 2,\n        VERBOSE: 3\n      },\n      LEVEL_STRING_MAP: {\n        0: 'ERROR:',\n        1: 'WARNING:',\n        2: 'INFO:',\n        3: 'VERBOSE:'\n      },\n      POPUP_WIDTH: 483,\n      POPUP_HEIGHT: 600\n    };\n\n    if (window.AuthenticationContext) {\n      return window.AuthenticationContext;\n    }\n    window.AuthenticationContext = this;\n\n    // public\n    this.config = {};\n    this.callback = null;\n    this.popUp = false;\n    this.isAngular = false;\n\n        // private\n    this._user = null;\n    this._activeRenewals = {};\n    this._loginInProgress = false;\n    this._renewStates = [];\n\n    window.callBackMappedToRenewStates = {};\n    window.callBacksMappedToRenewStates = {};\n\n        // validate before constructor assignments\n    if (config.displayCall && typeof config.displayCall !== 'function') {\n      throw new Error('displayCall is not a function');\n    }\n\n    if (!config.clientId) {\n      throw new Error('clientId is required');\n    }\n\n    this.config = this._cloneConfig(config);\n\n    if (this.config.popUp) {\n      this.popUp = true;\n    }\n\n    if (this.config.callback && typeof this.config.callback === 'function') {\n      this.callback = this.config.callback;\n    }\n\n    if (!this.config.instance || !this.config.instance.match(/^https:\\/\\/.*\\/$/)) {\n      throw new Error('instance must be a valid https endpoint that ends in a forward slash.');\n    }\n\n        // App can request idtoken for itself using clientid as resource\n    if (!this.config.loginResource) {\n      this.config.loginResource = this.config.clientId;\n    }\n\n    if (!this.config.redirectUri) {\n      this.config.redirectUri = window.location.href;\n    }\n\n    if (!this.config.anonymousEndpoints) {\n      this.config.anonymousEndpoints = [];\n    }\n\n    if (this.config.isAngular) {\n      this.isAngular = this.config.isAngular;\n    }\n\n    this.setResponseType(this.config.responseType);\n  };\n\n  AuthenticationContext.prototype.setResponseType = function(responseType) {\n    if (responseType) {\n      this.config.responseType = responseType;\n    } else {\n      this.config.responseType = this.CONSTANTS.ID_TOKEN;\n    }\n  };\n\n  window.Logging = {\n    level: 0,\n    log: function(message) { }  // jshint ignore:line\n  };\n\n  /**\n   * Gets initial Idtoken for the app backend\n   * Saves the resulting Idtoken in localStorage.\n   * @param {string} startPage the start page\n   */\n  AuthenticationContext.prototype.login = function(startPage) {\n    // Token is not present and user needs to login\n    if (this._loginInProgress) {\n      this.info('Login in progress');\n      return;\n    }\n    var expectedState = this._guid();\n    this.config.state = expectedState;\n    this._idTokenNonce = this._guid();\n    if (!startPage) {\n      startPage = window.location;\n    }\n    this.verbose('Expected state: ' + expectedState + ' startPage:' + startPage);\n    this._saveItem(this.CONSTANTS.STORAGE.LOGIN_REQUEST, startPage);\n    this._saveItem(this.CONSTANTS.STORAGE.LOGIN_ERROR, '');\n    this._saveItem(this.CONSTANTS.STORAGE.STATE_LOGIN, expectedState);\n    this._saveItem(this.CONSTANTS.STORAGE.NONCE_IDTOKEN, this._idTokenNonce);\n    this._saveItem(this.CONSTANTS.STORAGE.ERROR, '');\n    this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, '');\n    var urlNavigate = this._getNavigateUrl(this.config.responseType, null) + '&nonce=' + encodeURIComponent(this._idTokenNonce);\n    this._loginInProgress = true;\n    if (this.popUp) {\n      this._loginPopup(urlNavigate);\n      return;\n    }\n    if (this.config.displayCall) {\n            // User defined way of handling the navigation\n      this.config.displayCall(urlNavigate);\n    } else {\n      this.promptUser(urlNavigate);\n    }\n  };\n\n  AuthenticationContext.prototype._openPopup = function(urlNavigate, title, popUpWidth, popUpHeight) {\n    try {\n            /**\n            * adding winLeft and winTop to account for dual monitor\n            * using screenLeft and screenTop for IE8 and earlier\n            */\n      var winLeft = window.screenLeft ? window.screenLeft : window.screenX;\n      var winTop = window.screenTop ? window.screenTop : window.screenY;\n            /**\n            * window.innerWidth displays browser window's height and width excluding toolbars\n            * using document.documentElement.clientWidth for IE8 and earlier\n            */\n      var width = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;\n      var height = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;\n      var left = ((width / 2) - (popUpWidth / 2)) + winLeft;\n      var top = ((height / 2) - (popUpHeight / 2)) + winTop;\n\n      var popupWindow = window.open(urlNavigate, title, 'width=' + popUpWidth + ', height=' + popUpHeight + ', top=' + top + ', left=' + left);\n      if (popupWindow.focus) {\n        popupWindow.focus();\n      }\n      return popupWindow;\n    } catch (e) {\n      this.warn('Error opening popup, ' + e.message);\n      this._loginInProgress = false;\n      return null;\n    }\n  };\n\n  AuthenticationContext.prototype._loginPopup = function(urlNavigate) {\n    var popupWindow = this._openPopup(urlNavigate, 'login', this.CONSTANTS.POPUP_WIDTH, this.CONSTANTS.POPUP_HEIGHT);\n    if (popupWindow === null) {\n      this.warn('Popup Window is null. This can happen if you are using IE');\n      this._saveItem(this.CONSTANTS.STORAGE.ERROR, 'Error opening popup');\n      this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, 'Popup Window is null. This can happen if you are using IE');\n      this._saveItem(this.CONSTANTS.STORAGE.LOGIN_ERROR, 'Popup Window is null. This can happen if you are using IE');\n      if (this.callback) {\n        this.callback(this._getItem(this.CONSTANTS.STORAGE.LOGIN_ERROR), null);\n      }\n      return;\n    }\n    var registeredRedirectUri;\n    if (this.config.redirectUri.indexOf('#') === -1) {\n      registeredRedirectUri = this.config.redirectUri;\n    } else {\n      registeredRedirectUri = this.config.redirectUri.split('#')[0];\n    }\n    var that = this;\n    var pollTimer = window.setInterval(function() {\n      if (!popupWindow || popupWindow.closed || popupWindow.closed === undefined) {\n        that._loginInProgress = false;\n        window.clearInterval(pollTimer);\n      }\n      try {\n        if (popupWindow.location.href.indexOf(registeredRedirectUri) !== -1) {\n          if (that.isAngular) {\n            window.location.hash = popupWindow.location.hash;\n          } else {\n            that.handleWindowCallback(popupWindow.location.hash, popupWindow.location.search);\n          }\n          window.clearInterval(pollTimer);\n          that._loginInProgress = false;\n          that.info('Closing popup window');\n          popupWindow.close();\n        }\n      } catch (e) {\n      }\n    }, 20);\n  };\n\n  AuthenticationContext.prototype.loginInProgress = function() {\n    return this._loginInProgress;\n  };\n\n  AuthenticationContext.prototype._hasResource = function(key) {\n    var keys = this._getItem(this.CONSTANTS.STORAGE.TOKEN_KEYS);\n    return keys && !this._isEmpty(keys) && (keys.indexOf(key + this.CONSTANTS.RESOURCE_DELIMETER) > -1);\n  };\n\n    /**\n     * Gets token for the specified resource from local storage cache\n     * @param {string}   resource A URI that identifies the resource for which the token is valid.\n     * @return {string} token if exists and not expired or null\n     */\n  AuthenticationContext.prototype.getCachedToken = function(resource) {\n    if (!this._hasResource(resource)) {\n      return null;\n    }\n\n    var token = this._getItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY + resource);\n    var expired = this._getItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY + resource);\n\n        // If expiration is within offset, it will force renew\n    var offset = this.config.expireOffsetSeconds || 120;\n\n    if (expired && (expired > this._now() + offset)) {\n      return token;\n    }\n    this._saveItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY + resource, '');\n    this._saveItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY + resource, 0);\n    return null;\n  };\n\n  /**\n   * Retrieves and parse idToken from localstorage\n   * @return {User} user object\n   */\n  AuthenticationContext.prototype.getCachedUser = function() {\n    if (this._user) {\n      return this._user;\n    }\n\n    var idtoken = this._getItem(this.CONSTANTS.STORAGE.IDTOKEN);\n    this._user = this._createUser(idtoken);\n    return this._user;\n  };\n\n  AuthenticationContext.prototype.registerCallback = function(expectedState, resource, callback) {\n    this._activeRenewals[resource] = expectedState;\n    if (!window.callBacksMappedToRenewStates[expectedState]) {\n      window.callBacksMappedToRenewStates[expectedState] = [];\n    }\n    var self = this;\n    window.callBacksMappedToRenewStates[expectedState].push(callback);\n    if (!window.callBackMappedToRenewStates[expectedState]) {\n      window.callBackMappedToRenewStates[expectedState] = function(message, token) {\n        for (var i = 0; i < window.callBacksMappedToRenewStates[expectedState].length; ++i) {\n          try {\n            window.callBacksMappedToRenewStates[expectedState][i](message, token);\n          } catch (error) {\n            self.warn(error);\n          }\n        }\n        self._activeRenewals[resource] = null;\n        window.callBacksMappedToRenewStates[expectedState] = null;\n        window.callBackMappedToRenewStates[expectedState] = null;\n      };\n    }\n  };\n\n  /**\n   * Acquires access token with hidden iframe\n   * @param {string} resource  ResourceUri identifying the target resource\n   * @param {string} callback  ResourceUri identifying the target resource\n   */\n  AuthenticationContext.prototype._renewToken = function(resource, callback) {\n        // use iframe to try refresh token\n        // use given resource to create new authz url\n    this.info('renewToken is called for resource:' + resource);\n    var frameHandle = this._addAuthFrame('authRenewFrame' + resource);\n    var expectedState = this._guid() + '|' + resource;\n    this.config.state = expectedState;\n        // renew happens in iframe, so it keeps javascript context\n    this._renewStates.push(expectedState);\n\n    this.verbose('Renew token Expected state: ' + expectedState);\n    var urlNavigate = this._getNavigateUrl('token', resource) + '&prompt=none';\n    urlNavigate = this._addHintParameters(urlNavigate);\n\n    this.registerCallback(expectedState, resource, callback);\n    this.verbose('Navigate to:' + urlNavigate);\n    this._saveItem(this.CONSTANTS.STORAGE.LOGIN_REQUEST, '');\n    frameHandle.src = 'about:blank';\n    this._loadFrameTimeout(urlNavigate, 'authRenewFrame' + resource, resource);\n  };\n\n  AuthenticationContext.prototype._renewIdToken = function(callback) {\n        // use iframe to try refresh token\n    this.info('renewIdToken is called');\n    var frameHandle = this._addAuthFrame('authIdTokenFrame');\n    var expectedState = this._guid() + '|' + this.config.clientId;\n    this._idTokenNonce = this._guid();\n    this._saveItem(this.CONSTANTS.STORAGE.NONCE_IDTOKEN, this._idTokenNonce);\n    this.config.state = expectedState;\n        // renew happens in iframe, so it keeps javascript context\n    this._renewStates.push(expectedState);\n\n    this.verbose('Renew Idtoken Expected state: ' + expectedState);\n    var urlNavigate = this._getNavigateUrl(this.config.responseType, null) + '&prompt=none';\n    urlNavigate = this._addHintParameters(urlNavigate);\n\n    urlNavigate += '&nonce=' + encodeURIComponent(this._idTokenNonce);\n    this.registerCallback(expectedState, this.config.clientId, callback);\n    this.idTokenNonce = null;\n    this.verbose('Navigate to:' + urlNavigate);\n    this._saveItem(this.CONSTANTS.STORAGE.LOGIN_REQUEST, '');\n    frameHandle.src = 'about:blank';\n    this._loadFrameTimeout(urlNavigate, 'authIdTokenFrame', this.config.clientId);\n  };\n\n  AuthenticationContext.prototype._urlContainsQueryStringParameter = function(name, url) {\n        // regex to detect pattern of a ? or & followed by the name parameter and an equals character\n    var regex = new RegExp('[\\\\?&]' + name + '=');\n    return regex.test(url);\n  };\n\n    // Calling _loadFrame but with a timeout to signal failure in loadframeStatus. Callbacks are left\n    // registered when network errors occur and subsequent token requests for same resource are registered to the pending request\n  AuthenticationContext.prototype._loadFrameTimeout = function(urlNavigation, frameName, resource) {\n        // set iframe session to pending\n    this.verbose('Set loading state to pending for: ' + resource);\n    this._saveItem(this.CONSTANTS.STORAGE.RENEW_STATUS + resource, this.CONSTANTS.TOKEN_RENEW_STATUS_IN_PROGRESS);\n    this._loadFrame(urlNavigation, frameName);\n    var self = this;\n    setTimeout(function() {\n      if (self._getItem(self.CONSTANTS.STORAGE.RENEW_STATUS + resource) === self.CONSTANTS.TOKEN_RENEW_STATUS_IN_PROGRESS) {\n                // fail the iframe session if it's in pending state\n        self.verbose('Loading frame has timed out after: ' + (self.CONSTANTS.LOADFRAME_TIMEOUT / 1000) + ' seconds for resource ' + resource);\n        var expectedState = self._activeRenewals[resource];\n        if (expectedState && window.callBackMappedToRenewStates[expectedState]) {\n          window.callBackMappedToRenewStates[expectedState]('Token renewal operation failed due to timeout', null);\n        }\n\n        self._saveItem(self.CONSTANTS.STORAGE.RENEW_STATUS + resource, self.CONSTANTS.TOKEN_RENEW_STATUS_CANCELED);\n      }\n    }, self.CONSTANTS.LOADFRAME_TIMEOUT);\n  };\n\n  AuthenticationContext.prototype._loadFrame = function(urlNavigate, frameName) {\n        // This trick overcomes iframe navigation in IE\n        // IE does not load the page consistently in iframe\n    var self = this;\n    self.info('LoadFrame: ' + frameName);\n    var frameCheck = frameName;\n    setTimeout(function() {\n      var frameHandle = self._addAuthFrame(frameCheck);\n      if (frameHandle.src === '' || frameHandle.src === 'about:blank') {\n        frameHandle.src = urlNavigate;\n        self._loadFrame(urlNavigate, frameCheck);\n      }\n    }, 500);\n  };\n\n  /**\n   * Acquire token from cache if not expired and available. Acquires token from iframe if expired.\n   * @param {string} resource  ResourceUri identifying the target resource\n   * @param {function} callback The callback function\n   */\n  AuthenticationContext.prototype.acquireToken = function(resource, callback) {\n    if (this._isEmpty(resource)) {\n      this.warn('resource is required');\n      callback('resource is required', null);\n      return;\n    }\n\n    var token = this.getCachedToken(resource);\n    if (token) {\n      this.info('Token is already in cache for resource:' + resource);\n      callback(null, token);\n      return;\n    }\n\n    if (!this._user) {\n      this.warn('User login is required');\n      callback('User login is required', null);\n      return;\n    }\n\n    // refresh attept with iframe\n    // Already renewing for this resource, callback when we get the token.\n    if (this._activeRenewals[resource]) {\n      // Active renewals contains the state for each renewal.\n      this.registerCallback(this._activeRenewals[resource], resource, callback);\n    } else if (resource === this.config.clientId) {\n      // App uses idtoken to send to api endpoints\n      // Default resource is tracked as clientid to store this token\n      this.verbose('renewing idtoken');\n      this._renewIdToken(callback);\n    } else {\n      this._renewToken(resource, callback);\n    }\n  };\n\n  /**\n   * Redirect the Browser to Azure AD Authorization endpoint\n   * @param {string} urlNavigate The authorization request url\n   */\n  AuthenticationContext.prototype.promptUser = function(urlNavigate) {\n    if (urlNavigate) {\n      this.info('Navigate to:' + urlNavigate);\n      window.location.replace(urlNavigate);\n    } else {\n      this.info('Navigate url is empty');\n    }\n  };\n\n  /**\n   * Clear cache items.\n   */\n  AuthenticationContext.prototype.clearCache = function() {\n    this._saveItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY, '');\n    this._saveItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY, 0);\n    this._saveItem(this.CONSTANTS.STORAGE.SESSION_STATE, '');\n    this._saveItem(this.CONSTANTS.STORAGE.STATE_LOGIN, '');\n    this._renewStates = [];\n    this._saveItem(this.CONSTANTS.STORAGE.USERNAME, '');\n    this._saveItem(this.CONSTANTS.STORAGE.IDTOKEN, '');\n    this._saveItem(this.CONSTANTS.STORAGE.ERROR, '');\n    this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, '');\n    var keys = this._getItem(this.CONSTANTS.STORAGE.TOKEN_KEYS);\n\n    if (!this._isEmpty(keys)) {\n      keys = keys.split(this.CONSTANTS.RESOURCE_DELIMETER);\n      for (var i = 0; i < keys.length; i++) {\n        this._saveItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY + keys[i], '');\n        this._saveItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY + keys[i], 0);\n      }\n    }\n    this._saveItem(this.CONSTANTS.STORAGE.TOKEN_KEYS, '');\n  };\n\n  /**\n   * Clear cache items for a resource.\n   * @param {string} resource The resource\n   */\n  AuthenticationContext.prototype.clearCacheForResource = function(resource) {\n    this._saveItem(this.CONSTANTS.STORAGE.STATE_RENEW, '');\n    this._saveItem(this.CONSTANTS.STORAGE.ERROR, '');\n    this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, '');\n    if (this._hasResource(resource)) {\n      this._saveItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY + resource, '');\n      this._saveItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY + resource, 0);\n    }\n  };\n\n    /**\n     * Logout user will redirect page to logout endpoint.\n     * After logout, it will redirect to post_logout page if provided.\n     */\n  AuthenticationContext.prototype.logOut = function() {\n    this.clearCache();\n    var logout = '';\n    this._user = null;\n\n    if (this.config.postLogoutRedirectUri) {\n      logout = 'post_logout_redirect_uri=' + encodeURIComponent(this.config.postLogoutRedirectUri);\n    }\n\n    var urlNavigate = this.config.instance + 'logout?' + logout;\n    this.info('Logout navigate to: ' + urlNavigate);\n    this.promptUser(urlNavigate);\n  };\n\n  AuthenticationContext.prototype._isEmpty = function(str) {\n    return (typeof str === 'undefined' || !str || str.length === 0);\n  };\n\n  /**\n   * Gets a user profile\n   * @param {requestCallback} callback The callback that handles the response.\n   */\n  AuthenticationContext.prototype.getUser = function(callback) {\n    // IDToken is first call\n    if (typeof callback !== 'function') {\n      throw new Error('callback is not a function');\n    }\n\n    // user in memory\n    if (this._user) {\n      callback(null, this._user);\n      return;\n    }\n\n        // frame is used to get idtoken\n    var idtoken = this._getItem(this.CONSTANTS.STORAGE.IDTOKEN);\n    if (this._isEmpty(idtoken)) {\n      this.warn('User information is not available');\n      callback('User information is not available');\n    } else {\n      this.info('User exists in cache: ');\n      this._user = this._createUser(idtoken);\n      callback(null, this._user);\n    }\n  };\n\n  AuthenticationContext.prototype._addHintParameters = function(urlNavigate) {\n        // include hint params only if upn is present\n    if (this._user && this._user.profile && this._user.profile.hasOwnProperty('upn')) {\n            // add login_hint\n      urlNavigate += '&login_hint=' + encodeURIComponent(this._user.profile.upn);\n\n            // don't add domain_hint twice if user provided it in the extraQueryParameter value\n      if (!this._urlContainsQueryStringParameter('domain_hint', urlNavigate) && this._user.profile.upn.indexOf('@') > -1) {\n        var parts = this._user.profile.upn.split('@');\n                // local part can include @ in quotes. Sending last part handles that.\n        urlNavigate += '&domain_hint=' + encodeURIComponent(parts[parts.length - 1]);\n      }\n    }\n\n    return urlNavigate;\n  };\n\n  AuthenticationContext.prototype._createUser = function(idToken) {\n    var user = null;\n    var parsedJson = this._extractIdToken(idToken);\n    if (parsedJson && parsedJson.hasOwnProperty('aud')) {\n      var audienceMatch = false;\n\n      if (Array.isArray(parsedJson.aud)) {\n                // If the ID Token contains multiple audiences then an azp claim must be present and equal to the client id.\n        if (parsedJson.hasOwnProperty('azp') && parsedJson.azp.toLowerCase() === this.config.clientId.toLowerCase()) {\n          for (var i = 0; i < parsedJson.aud.length; i++) {\n            if (parsedJson.aud[i].toLowerCase() === this.config.clientId.toLowerCase()) {\n              audienceMatch = true;\n              break;\n            }\n          }\n        }\n      } else {\n        audienceMatch = (parsedJson.aud.toLowerCase() === this.config.clientId.toLowerCase());\n      }\n\n      if (audienceMatch) {\n        user = {\n          userName: '',\n          profile: parsedJson\n        };\n\n        if (parsedJson.hasOwnProperty('upn')) {\n          user.userName = parsedJson.upn;\n        } else if (parsedJson.hasOwnProperty('email')) {\n          user.userName = parsedJson.email;\n        } else if (parsedJson.hasOwnProperty('sub')) {\n          user.userName = parsedJson.sub;\n        }\n      } else {\n        this.warn('IdToken has invalid aud/azp field');\n      }\n    }\n\n    return user;\n  };\n\n  AuthenticationContext.prototype._getHash = function(hash) {\n    if (hash.indexOf('#/') > -1) {\n      hash = hash.substring(hash.indexOf('#/') + 2);\n    } else if (hash.indexOf('#') > -1) {\n      hash = hash.substring(1);\n    }\n\n    return hash;\n  };\n\n  AuthenticationContext.prototype._getSearch = function(search) {\n    if (search.indexOf('?') > -1) {\n      search = search.substring(1);\n    }\n\n    return search;\n  };\n\n  AuthenticationContext.prototype._getParameters = function(hash, search) {\n    var parameters = {};\n\n    if (hash) {\n      hash = this._getHash(hash);\n      parameters = this._deserialize(hash);\n    }\n\n    if (search) {\n      search = this._getSearch(search);\n      var searchParameters = this._deserialize(search);\n      parameters = this._extend(parameters, searchParameters);\n    }\n\n    return parameters;\n  };\n\n  AuthenticationContext.prototype._extend = function(obj, src) {\n    for (var key in src) {\n      if (src.hasOwnProperty(key)) {\n        obj[key] = src[key];\n      }\n    }\n    return obj;\n  };\n\n  /**\n   * Checks if hash contains access token or id token or error_description\n   * @param {string} hash  -  Hash passed from redirect page\n   * @param {string} search  -  Search passed from redirect page\n   * @return {boolean} exists if all the parameters exist\n   */\n  AuthenticationContext.prototype.isCallback = function(hash, search) {\n    var parameters = this._getParameters(hash, search);\n\n    return parameters.hasOwnProperty(this.CONSTANTS.ERROR_DESCRIPTION) ||\n      parameters.hasOwnProperty(this.CONSTANTS.ACCESS_TOKEN) ||\n      parameters.hasOwnProperty(this.CONSTANTS.ID_TOKEN);\n  };\n\n  /**\n   * Gets login error\n   * @return {string} error message related to login\n   */\n  AuthenticationContext.prototype.getLoginError = function() {\n    return this._getItem(this.CONSTANTS.STORAGE.LOGIN_ERROR);\n  };\n\n  /**\n   * Gets requestInfo from given hash.\n   * @param {string} hash  -  Hash passed from redirect page\n   * @param {string} search  -  Search passed from redirect page\n   * @return {string} error message related to login\n   */\n  AuthenticationContext.prototype.getRequestInfo = function(hash, search) {\n    var parameters = this._getParameters(hash, search);\n    var requestInfo = {\n      valid: false,\n      parameters: {},\n      stateMatch: false,\n      stateResponse: '',\n      requestType: this.REQUEST_TYPE.UNKNOWN\n    };\n\n    if (parameters) {\n      requestInfo.parameters = parameters;\n      if (parameters.hasOwnProperty(this.CONSTANTS.ERROR_DESCRIPTION) ||\n        parameters.hasOwnProperty(this.CONSTANTS.ACCESS_TOKEN) ||\n        parameters.hasOwnProperty(this.CONSTANTS.ID_TOKEN)) {\n        requestInfo.valid = true;\n\n        // which call\n        var stateResponse = '';\n        if (parameters.hasOwnProperty('state')) {\n          this.verbose('State: ' + parameters.state);\n          stateResponse = parameters.state;\n        } else {\n          this.warn('No state returned');\n          return requestInfo;\n        }\n\n        requestInfo.stateResponse = stateResponse;\n\n        // async calls can fire iframe and login request at the same time if developer does not use the API as expected\n        // incoming callback needs to be looked up to find the request type\n        if (stateResponse === this._getItem(this.CONSTANTS.STORAGE.STATE_LOGIN)) {\n          requestInfo.requestType = this.REQUEST_TYPE.LOGIN;\n          requestInfo.stateMatch = true;\n          return requestInfo;\n        }\n\n        // external api requests may have many renewtoken requests for different resource\n        if (!requestInfo.stateMatch && window.parent && window.parent.AuthenticationContext) {\n          var statesInParentContext = window.parent.AuthenticationContext._renewStates;\n          for (var i = 0; i < statesInParentContext.length; i++) {\n            if (statesInParentContext[i] === requestInfo.stateResponse) {\n              requestInfo.requestType = this.REQUEST_TYPE.RENEW_TOKEN;\n              requestInfo.stateMatch = true;\n              break;\n            }\n          }\n        }\n      }\n    }\n\n    return requestInfo;\n  };\n\n  AuthenticationContext.prototype._getResourceFromState = function(state) {\n    if (state) {\n      var splitIndex = state.indexOf('|');\n      if (splitIndex > -1 && splitIndex + 1 < state.length) {\n        return state.substring(splitIndex + 1);\n      }\n    }\n\n    return '';\n  };\n\n  /**\n   * Saves token from hash that is received from redirect.\n   * @param {string} requestInfo Hash passed from redirect page\n   */\n  AuthenticationContext.prototype.saveTokenFromHash = function(requestInfo) {\n    this.info('State status:' + requestInfo.stateMatch + '; Request type:' + requestInfo.requestType);\n    this._saveItem(this.CONSTANTS.STORAGE.ERROR, '');\n    this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, '');\n\n    var resource = this._getResourceFromState(requestInfo.stateResponse);\n\n        // Record error\n    if (requestInfo.parameters.hasOwnProperty(this.CONSTANTS.ERROR_DESCRIPTION)) {\n      this.info('Error :' + requestInfo.parameters.error + '; Error description:' + requestInfo.parameters[this.CONSTANTS.ERROR_DESCRIPTION]);\n      this._saveItem(this.CONSTANTS.STORAGE.ERROR, requestInfo.parameters.error);\n      this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, requestInfo.parameters[this.CONSTANTS.ERROR_DESCRIPTION]);\n\n      if (requestInfo.requestType === this.REQUEST_TYPE.LOGIN) {\n        this._loginInProgress = false;\n        this._saveItem(this.CONSTANTS.STORAGE.LOGIN_ERROR, requestInfo.parameters.error_description);  // jshint ignore:line\n      }\n    } else if (requestInfo.stateMatch) {\n      // record tokens to storage if exists\n      this.info('State is right');\n      if (requestInfo.parameters.hasOwnProperty(this.CONSTANTS.SESSION_STATE)) {\n        this._saveItem(this.CONSTANTS.STORAGE.SESSION_STATE, requestInfo.parameters[this.CONSTANTS.SESSION_STATE]);\n      }\n\n      var keys;\n\n      if (requestInfo.parameters.hasOwnProperty(this.CONSTANTS.ACCESS_TOKEN)) {\n        this.info('Fragment has access token');\n\n        if (!this._hasResource(resource)) {\n          keys = this._getItem(this.CONSTANTS.STORAGE.TOKEN_KEYS) || '';\n          this._saveItem(this.CONSTANTS.STORAGE.TOKEN_KEYS, keys + resource + this.CONSTANTS.RESOURCE_DELIMETER);\n        }\n                  // save token with related resource\n        this._saveItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY + resource, requestInfo.parameters[this.CONSTANTS.ACCESS_TOKEN]);\n        this._saveItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY + resource, this._expiresIn(requestInfo.parameters[this.CONSTANTS.EXPIRES_IN]));\n      }\n\n      if (requestInfo.parameters.hasOwnProperty(this.CONSTANTS.ID_TOKEN)) {\n        this.info('Fragment has id token');\n        this._loginInProgress = false;\n\n        this._user = this._createUser(requestInfo.parameters[this.CONSTANTS.ID_TOKEN]);\n\n        if (this._user && this._user.profile) {\n          if (this._user.profile.nonce === this._getItem(this.CONSTANTS.STORAGE.NONCE_IDTOKEN)) {\n            this._saveItem(this.CONSTANTS.STORAGE.IDTOKEN, requestInfo.parameters[this.CONSTANTS.ID_TOKEN]);\n\n                          // Save idtoken as access token for app itself\n            resource = this.config.loginResource ? this.config.loginResource : this.config.clientId;\n\n            if (!this._hasResource(resource)) {\n              keys = this._getItem(this.CONSTANTS.STORAGE.TOKEN_KEYS) || '';\n              this._saveItem(this.CONSTANTS.STORAGE.TOKEN_KEYS, keys + resource + this.CONSTANTS.RESOURCE_DELIMETER);\n            }\n            this._saveItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY + resource, requestInfo.parameters[this.CONSTANTS.ID_TOKEN]);\n            this._saveItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY + resource, this._user.profile.exp);\n          } else {\n            this._user = null;\n            this._saveItem(this.CONSTANTS.STORAGE.LOGIN_ERROR, 'Nonce is not same as ' + this._idTokenNonce);\n          }\n        } else {\n          this._saveItem(this.CONSTANTS.STORAGE.ERROR, 'invalid id_token');\n          this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, 'Invalid id_token. id_token: ' + requestInfo.parameters[this.CONSTANTS.ID_TOKEN]);\n        }\n      }\n    } else {\n      this._saveItem(this.CONSTANTS.STORAGE.ERROR, 'Invalid_state');\n      this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, 'Invalid_state. state: ' + requestInfo.stateResponse);\n    }\n    this._saveItem(this.CONSTANTS.STORAGE.RENEW_STATUS + resource, this.CONSTANTS.TOKEN_RENEW_STATUS_COMPLETED);\n  };\n\n  /**\n   * Gets resource for given endpoint if mapping is provided with config.\n   * @param {string} endpoint API endpoint\n   * @return {string} resource for this API endpoint\n   */\n  AuthenticationContext.prototype.getResourceForEndpoint = function(endpoint) {\n    if (this.config && this.config.endpoints) {\n      for (var configEndpoint in this.config.endpoints) {\n                // configEndpoint is like /api/Todo requested endpoint can be /api/Todo/1\n        if (endpoint.indexOf(configEndpoint) > -1) {\n          return this.config.endpoints[configEndpoint];\n        }\n      }\n    }\n\n    // default resource will be clientid if nothing specified\n    // App will use idtoken for calls to itself\n    // check if it's staring from http or https, needs to match with app host\n    if (endpoint.indexOf('http://') > -1 || endpoint.indexOf('https://') > -1) {\n      if (this._getHostFromUri(endpoint) === this._getHostFromUri(this.config.redirectUri)) {\n        return this.config.loginResource;\n      }\n    } else {\n      // in angular level, the url for $http interceptor call could be relative url,\n      // if it's relative call, we'll treat it as app backend call.\n      // if user specified list of anonymous endpoints, no need to send token to these endpoints, return null.\n      if (this.config && this.config.anonymousEndpoints) {\n        for (var i = 0; i < this.config.anonymousEndpoints.length; i++) {\n          if (endpoint.indexOf(this.config.anonymousEndpoints[i]) > -1) {\n            return null;\n          }\n        }\n      }\n            // all other app's backend calls are secured.\n      return this.config.loginResource;\n    }\n\n        // if not the app's own backend or not a domain listed in the endpoints structure\n    return null;\n  };\n\n  AuthenticationContext.prototype._getHostFromUri = function(uri) {\n        // remove http:// or https:// from uri\n    var extractedUri = String(uri).replace(/^(https?:)\\/\\//, '');\n\n    extractedUri = extractedUri.split('/')[0];\n    return extractedUri;\n  };\n\n    /* exported  oauth2Callback */\n  AuthenticationContext.prototype.handleWindowCallback = function(hash, search) {\n        // This is for regular javascript usage for redirect handling\n        // need to make sure this is for callback\n    if (!hash) {\n      hash = window.location.hash;\n    }\n\n    if (!search) {\n      search = window.location.search;\n    }\n\n    if (this.isCallback(hash, search)) {\n      var requestInfo = this.getRequestInfo(hash, search);\n      this.info('Returned from redirect url');\n      this.saveTokenFromHash(requestInfo);\n      var callback = null;\n      if ((requestInfo.requestType === this.REQUEST_TYPE.RENEW_TOKEN) && window.parent && (window.parent !== window)) {\n                // iframe call but same single page\n        this.verbose('Window is in iframe');\n        callback = window.parent.callBackMappedToRenewStates[requestInfo.stateResponse];\n        if (callback) {\n          callback(this._getItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION), requestInfo.parameters[this.CONSTANTS.ACCESS_TOKEN] || requestInfo.parameters[this.CONSTANTS.ID_TOKEN]);\n        }\n        return;\n      } else if (requestInfo.requestType === this.REQUEST_TYPE.LOGIN) {\n        callback = this.callback;\n        if (callback) {\n          callback(this._getItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION), requestInfo.parameters[this.CONSTANTS.ID_TOKEN]);\n        }\n      }\n            // No need to redirect user in case of popup\n      if (!this.popUp) {\n        window.location = this._getItem(this.CONSTANTS.STORAGE.LOGIN_REQUEST);\n      }\n    }\n  };\n\n  AuthenticationContext.prototype._getNavigateUrl = function(responseType, resource) {\n    var urlNavigate = this.config.instance + 'authorize' + this._serialize(responseType, this.config, resource) + this._addLibMetadata();\n    if (this.config.scope) {\n      urlNavigate += '&scope=' + encodeURIComponent(this.config.scope);\n    }\n    this.info('Navigate url:' + urlNavigate);\n    return urlNavigate;\n  };\n\n  AuthenticationContext.prototype._extractIdToken = function(encodedIdToken) {\n        // id token will be decoded to get the username\n    var decodedToken = this._decodeJwt(encodedIdToken);\n    if (!decodedToken) {\n      return null;\n    }\n\n    try {\n      var base64IdToken = decodedToken.JWSPayload;\n      var base64Decoded = this._base64DecodeStringUrlSafe(base64IdToken);\n      if (!base64Decoded) {\n        this.info('The returned id_token could not be base64 url safe decoded.');\n        return null;\n      }\n\n            // ECMA script has JSON built-in support\n      return JSON.parse(base64Decoded);\n    } catch (err) {\n      this.error('The returned id_token could not be decoded', err);\n    }\n\n    return null;\n  };\n\n  AuthenticationContext.prototype._base64DecodeStringUrlSafe = function(base64IdToken) {\n        // html5 should support atob function for decoding\n    base64IdToken = base64IdToken.replace(/-/g, '+').replace(/_/g, '/');\n    if (window.atob) {\n      return decodeURIComponent(escape(window.atob(base64IdToken)));\n    }\n    return decodeURIComponent(escape(this._decode(base64IdToken)));\n  };\n\n    // Take https://cdnjs.cloudflare.com/ajax/libs/Base64/0.3.0/base64.js and https://en.wikipedia.org/wiki/Base64 as reference.\n  AuthenticationContext.prototype._decode = function(base64IdToken) {\n    var codes = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n    base64IdToken = String(base64IdToken).replace(/[=]+$/, '');\n\n    var length = base64IdToken.length;\n    if (length % 4 === 1) {\n      throw new Error('The token to be decoded is not correctly encoded.');\n    }\n\n    var h1, h2, h3, h4, bits, c1, c2, c3;\n    var decoded = '';\n    for (var i = 0; i < length; i += 4) {\n            // Every 4 base64 encoded character will be converted to 3 byte string, which is 24 bits\n            // then 6 bits per base64 encoded character\n      h1 = codes.indexOf(base64IdToken.charAt(i));\n      h2 = codes.indexOf(base64IdToken.charAt(i + 1));\n      h3 = codes.indexOf(base64IdToken.charAt(i + 2));\n      h4 = codes.indexOf(base64IdToken.charAt(i + 3));\n\n            // For padding, if last two are '='\n      if (i + 2 === length - 1) {\n        bits = h1 << 18 | h2 << 12 | h3 << 6;\n        c1 = bits >> 16 & 255;\n        c2 = bits >> 8 & 255;\n        decoded += String.fromCharCode(c1, c2);\n        break;\n      } else if (i + 1 === length - 1) { // if last one is '='\n        bits = h1 << 18 | h2 << 12;\n        c1 = bits >> 16 & 255;\n        decoded += String.fromCharCode(c1);\n        break;\n      }\n\n      bits = h1 << 18 | h2 << 12 | h3 << 6 | h4;\n\n            // then convert to 3 byte chars\n      c1 = bits >> 16 & 255;\n      c2 = bits >> 8 & 255;\n      c3 = bits & 255;\n\n      decoded += String.fromCharCode(c1, c2, c3);\n    }\n\n    return decoded;\n  };\n\n    // Auth.node js crack function\n  AuthenticationContext.prototype._decodeJwt = function(jwtToken) {\n    if (this._isEmpty(jwtToken)) {\n      return null;\n    }\n\n    var idTokenPartsRegex = /^([^\\.\\s]*)\\.([^\\.\\s]+)\\.([^\\.\\s]*)$/;\n\n    var matches = idTokenPartsRegex.exec(jwtToken);\n    if (!matches || matches.length < 4) {\n      this.warn('The returned id_token is not parseable.');\n      return null;\n    }\n\n    var crackedToken = {\n      header: matches[1],\n      JWSPayload: matches[2],\n      JWSSig: matches[3]\n    };\n\n    return crackedToken;\n  };\n\n  AuthenticationContext.prototype._convertUrlSafeToRegularBase64EncodedString = function(str) {\n    return str.replace('-', '+').replace('_', '/');\n  };\n\n  AuthenticationContext.prototype._serialize = function(responseType, obj, resource) {\n    var str = [];\n    if (obj !== null) {\n      str.push('?response_type=' + encodeURIComponent(responseType));\n      str.push('client_id=' + encodeURIComponent(obj.clientId));\n      if (resource) {\n        str.push('resource=' + encodeURIComponent(resource));\n      }\n\n      str.push('redirect_uri=' + encodeURIComponent(obj.redirectUri));\n      str.push('state=' + encodeURIComponent(obj.state));\n\n      if (obj.hasOwnProperty('slice')) {\n        str.push('slice=' + encodeURIComponent(obj.slice));\n      }\n\n      if (obj.hasOwnProperty('extraQueryParameter')) {\n        str.push(obj.extraQueryParameter);\n      }\n\n      var correlationId = obj.correlationId ? obj.correlationId : this._guid();\n      str.push('client-request-id=' + encodeURIComponent(correlationId));\n    }\n\n    return str.join('&');\n  };\n\n  AuthenticationContext.prototype._deserialize = function(query) {\n    var match,\n      pl = /\\+/g,  // Regex for replacing addition symbol with a space\n      search = /([^&=]+)=([^&]*)/g,\n      decode = function(s) {\n        return decodeURIComponent(s.replace(pl, ' '));\n      },\n      obj = {};\n    match = search.exec(query);\n    while (match) {\n      obj[decode(match[1])] = decode(match[2]);\n      match = search.exec(query);\n    }\n\n    return obj;\n  };\n\n  AuthenticationContext.prototype._decimalToHex = function(number) {\n    var hex = number.toString(16);\n    while (hex.length < 2) {\n      hex = '0' + hex;\n    }\n    return hex;\n  };\n\n    /* jshint ignore:start */\n  AuthenticationContext.prototype._guid = function() {\n    // RFC4122: The version 4 UUID is meant for generating UUIDs from truly-random or\n    // pseudo-random numbers.\n    // The algorithm is as follows:\n    //     Set the two most significant bits (bits 6 and 7) of the\n    //        clock_seq_hi_and_reserved to zero and one, respectively.\n    //     Set the four most significant bits (bits 12 through 15) of the\n    //        time_hi_and_version field to the 4-bit version number from\n    //        Section 4.1.3. Version4\n    //     Set all the other bits to randomly (or pseudo-randomly) chosen\n    //     values.\n    // UUID                   = time-low \"-\" time-mid \"-\"time-high-and-version \"-\"clock-seq-reserved and low(2hexOctet)\"-\" node\n    // time-low               = 4hexOctet\n    // time-mid               = 2hexOctet\n    // time-high-and-version  = 2hexOctet\n    // clock-seq-and-reserved = hexOctet:\n    // clock-seq-low          = hexOctet\n    // node                   = 6hexOctet\n    // Format: xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\n    // y could be 1000, 1001, 1010, 1011 since most significant two bits needs to be 10\n    // y values are 8, 9, A, B\n    var cryptoObj = window.crypto || window.msCrypto; // for IE 11\n    if (cryptoObj && cryptoObj.getRandomValues) {\n      var buffer = new Uint8Array(16);\n      cryptoObj.getRandomValues(buffer);\n            // buffer[6] and buffer[7] represents the time_hi_and_version field. We will set the four most significant bits (4 through 7) of buffer[6] to represent decimal number 4 (UUID version number).\n      buffer[6] |= 0x40; // buffer[6] | 01000000 will set the 6 bit to 1.\n      buffer[6] &= 0x4f; // buffer[6] & 01001111 will set the 4, 5, and 7 bit to 0 such that bits 4-7 == 0100 = \"4\".\n            // buffer[8] represents the clock_seq_hi_and_reserved field. We will set the two most significant bits (6 and 7) of the clock_seq_hi_and_reserved to zero and one, respectively.\n      buffer[8] |= 0x80; // buffer[8] | 10000000 will set the 7 bit to 1.\n      buffer[8] &= 0xbf; // buffer[8] & 10111111 will set the 6 bit to 0.\n      return this._decimalToHex(buffer[0]) + this._decimalToHex(buffer[1]) + this._decimalToHex(buffer[2]) + this._decimalToHex(buffer[3]) + '-' + this._decimalToHex(buffer[4]) + this._decimalToHex(buffer[5]) + '-' + this._decimalToHex(buffer[6]) + this._decimalToHex(buffer[7]) + '-' +\n             this._decimalToHex(buffer[8]) + this._decimalToHex(buffer[9]) + '-' + this._decimalToHex(buffer[10]) + this._decimalToHex(buffer[11]) + this._decimalToHex(buffer[12]) + this._decimalToHex(buffer[13]) + this._decimalToHex(buffer[14]) + this._decimalToHex(buffer[15]);\n    }\n    var guidHolder = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx';\n    var hex = '0123456789abcdef';\n    var r = 0;\n    var guidResponse = \"\";\n    for (var i = 0; i < 36; i++) {\n      if (guidHolder[i] !== '-' && guidHolder[i] !== '4') {\n                  // each x and y needs to be random\n        r = Math.random() * 16 | 0;\n      }\n      if (guidHolder[i] === 'x') {\n        guidResponse += hex[r];\n      } else if (guidHolder[i] === 'y') {\n                  // clock-seq-and-reserved first hex is filtered and remaining hex values are random\n        r &= 0x3; // bit and with 0011 to set pos 2 to zero ?0??\n        r |= 0x8; // set pos 3 to 1 as 1???\n        guidResponse += hex[r];\n      } else {\n        guidResponse += guidHolder[i];\n      }\n    }\n    return guidResponse;\n  };\n\n  AuthenticationContext.prototype._expiresIn = function(expires) {\n    return this._now() + parseInt(expires, 10);\n  };\n\n  AuthenticationContext.prototype._now = function() {\n    return Math.round(new Date().getTime() / 1000.0);\n  };\n\n  AuthenticationContext.prototype._addAuthFrame = function(iframeId) {\n    if (typeof iframeId === 'undefined') {\n      return;\n    }\n\n    this.info('Add auth frame to document:' + iframeId);\n    var authFrame = document.getElementById(iframeId);\n\n    if (!authFrame) {\n      if (document.createElement && document.documentElement &&\n                (window.opera || window.navigator.userAgent.indexOf('MSIE 5.0') === -1)) {\n        var ifr = document.createElement('iframe');\n        ifr.setAttribute('id', iframeId);\n        ifr.style.visibility = 'hidden';\n        ifr.style.position = 'absolute';\n        ifr.style.width = ifr.style.height = ifr.borderWidth = '0px';\n\n        authFrame = document.getElementsByTagName('body')[0].appendChild(ifr);\n      } else if (document.body && document.body.insertAdjacentHTML) {\n        document.body.insertAdjacentHTML('beforeEnd', '<iframe name=\"' + iframeId + '\" id=\"' + iframeId + '\" style=\"display:none\"></iframe>');\n      }\n      if (window.frames && window.frames[iframeId]) {\n        authFrame = window.frames[iframeId];\n      }\n    }\n\n    return authFrame;\n  };\n\n  AuthenticationContext.prototype._saveItem = function(key, obj) {\n    if (this.config && this.config.cacheLocation && this.config.cacheLocation === 'localStorage') {\n      if (!this._supportsLocalStorage()) {\n        this.info('Local storage is not supported');\n        return false;\n      }\n\n      localStorage.setItem(key, obj);\n\n      return true;\n    }\n\n        // Default as session storage\n    if (!this._supportsSessionStorage()) {\n      this.info('Session storage is not supported');\n      return false;\n    }\n\n    sessionStorage.setItem(key, obj);\n    return true;\n  };\n\n  AuthenticationContext.prototype._getItem = function(key) {\n    if (this.config && this.config.cacheLocation && this.config.cacheLocation === 'localStorage') {\n      if (!this._supportsLocalStorage()) {\n        this.info('Local storage is not supported');\n        return null;\n      }\n\n      return localStorage.getItem(key);\n    }\n\n        // Default as session storage\n    if (!this._supportsSessionStorage()) {\n      this.info('Session storage is not supported');\n      return null;\n    }\n\n    return sessionStorage.getItem(key);\n  };\n\n  AuthenticationContext.prototype._supportsLocalStorage = function() {\n    try {\n      return 'localStorage' in window && window.localStorage;\n    } catch (e) {\n      return false;\n    }\n  };\n\n  AuthenticationContext.prototype._supportsSessionStorage = function() {\n    try {\n      return 'sessionStorage' in window && window.sessionStorage;\n    } catch (e) {\n      return false;\n    }\n  };\n\n  AuthenticationContext.prototype._cloneConfig = function(obj) {\n    if (obj === null || typeof obj !== 'object') {\n      return obj;\n    }\n\n    var copy = {};\n    for (var attr in obj) {\n      if (obj.hasOwnProperty(attr)) {\n        copy[attr] = obj[attr];\n      }\n    }\n    return copy;\n  };\n\n  AuthenticationContext.prototype._addLibMetadata = function() {\n        // x-client-SKU\n        // x-client-Ver\n    return '&x-client-SKU=Js&x-client-Ver=' + this._libVersion();\n  };\n\n  AuthenticationContext.prototype.log = function(level, message, error) {\n    if (level <= Logging.level) {\n      var timestamp = new Date().toUTCString();\n      var formattedMessage = '';\n\n      if (this.config.correlationId) {\n        formattedMessage = timestamp + ':' + this.config.correlationId + '-' + this._libVersion() + '-' + this.CONSTANTS.LEVEL_STRING_MAP[level] + ' ' + message;\n      } else {\n        formattedMessage = timestamp + ':' + this._libVersion() + '-' + this.CONSTANTS.LEVEL_STRING_MAP[level] + ' ' + message;\n      }\n\n      if (error) {\n        formattedMessage += '\\nstack:\\n' + error.stack;\n      }\n\n      Logging.log(formattedMessage);\n    }\n  };\n\n  AuthenticationContext.prototype.error = function(message, error) {\n    this.log(this.CONSTANTS.LOGGING_LEVEL.ERROR, message, error);\n  };\n\n  AuthenticationContext.prototype.warn = function(message) {\n    this.log(this.CONSTANTS.LOGGING_LEVEL.WARN, message, null);\n  };\n\n  AuthenticationContext.prototype.info = function(message) {\n    this.log(this.CONSTANTS.LOGGING_LEVEL.INFO, message, null);\n  };\n\n  AuthenticationContext.prototype.verbose = function(message) {\n    this.log(this.CONSTANTS.LOGGING_LEVEL.VERBOSE, message, null);\n  };\n\n  AuthenticationContext.prototype._libVersion = function() {\n    return '1.0.12';\n  };\n\n  if (typeof module !== 'undefined' && module.exports) {\n    module.exports = AuthenticationContext;\n    module.exports.inject = function(conf) {\n      return new AuthenticationContext(conf);\n    };\n  }\n\n  return AuthenticationContext;\n})();\n\n\n\n/** WEBPACK FOOTER **\n ** ./salte-auth.js\n **/"],"sourceRoot":""}
