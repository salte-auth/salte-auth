{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///salte-auth.js","webpack:///webpack/bootstrap 8dba8b91e5820624561f","webpack:///./salte-auth.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","global","_classCallCheck","instance","Constructor","TypeError","Object","defineProperty","value","_typeof","Symbol","iterator","obj","constructor","prototype","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","key","protoProps","staticProps","AuthenticationContext","config","REQUEST_TYPE","LOGIN","RENEW_TOKEN","UNKNOWN","CONSTANTS","ACCESS_TOKEN","EXPIRES_IN","ID_TOKEN","ERROR_DESCRIPTION","SESSION_STATE","STORAGE","TOKEN_KEYS","ACCESS_TOKEN_KEY","EXPIRATION_KEY","STATE_LOGIN","STATE_RENEW","NONCE_IDTOKEN","USERNAME","IDTOKEN","ERROR","LOGIN_REQUEST","LOGIN_ERROR","RENEW_STATUS","RESOURCE_DELIMETER","LOADFRAME_TIMEOUT","TOKEN_RENEW_STATUS_CANCELED","TOKEN_RENEW_STATUS_COMPLETED","TOKEN_RENEW_STATUS_IN_PROGRESS","LOGGING_LEVEL","WARN","INFO","VERBOSE","LEVEL_STRING_MAP","0","1","2","3","POPUP_WIDTH","POPUP_HEIGHT","window","callback","popUp","isAngular","_user","_activeRenewals","_loginInProgress","_renewStates","callBackMappedToRenewStates","callBacksMappedToRenewStates","displayCall","Error","clientId","_cloneConfig","match","loginResource","redirectUri","location","href","anonymousEndpoints","setResponseType","responseType","startPage","info","expectedState","_guid","state","_idTokenNonce","verbose","_saveItem","urlNavigate","_getNavigateUrl","encodeURIComponent","_loginPopup","promptUser","title","popUpWidth","popUpHeight","winLeft","screenLeft","screenX","winTop","screenTop","screenY","width","innerWidth","document","documentElement","clientWidth","body","height","innerHeight","clientHeight","left","top","popupWindow","open","focus","e","warn","message","_openPopup","_getItem","registeredRedirectUri","indexOf","split","that","pollTimer","setInterval","closed","undefined","clearInterval","hash","handleWindowCallback","search","close","keys","_isEmpty","resource","_hasResource","token","expired","offset","expireOffsetSeconds","_now","idtoken","_createUser","self","push","error","frameHandle","_addAuthFrame","_addHintParameters","registerCallback","src","_loadFrameTimeout","idTokenNonce","name","url","regex","RegExp","test","urlNavigation","frameName","_loadFrame","setTimeout","frameCheck","getCachedToken","_renewIdToken","_renewToken","replace","clearCache","logout","postLogoutRedirectUri","str","profile","hasOwnProperty","upn","_urlContainsQueryStringParameter","parts","idToken","user","parsedJson","_extractIdToken","audienceMatch","Array","isArray","aud","azp","toLowerCase","userName","email","sub","substring","parameters","_getHash","_deserialize","_getSearch","searchParameters","_extend","_getParameters","requestInfo","valid","stateMatch","stateResponse","requestType","parent","statesInParentContext","splitIndex","_getResourceFromState","error_description","_expiresIn","nonce","exp","endpoint","endpoints","configEndpoint","_getHostFromUri","uri","extractedUri","String","isCallback","getRequestInfo","saveTokenFromHash","_serialize","_addLibMetadata","scope","encodedIdToken","decodedToken","_decodeJwt","base64IdToken","JWSPayload","base64Decoded","_base64DecodeStringUrlSafe","JSON","parse","err","atob","decodeURIComponent","escape","_decode","codes","h1","h2","h3","h4","bits","c1","c2","c3","decoded","charAt","fromCharCode","jwtToken","idTokenPartsRegex","matches","exec","crackedToken","header","JWSSig","slice","extraQueryParameter","correlationId","join","query","pl","decode","s","number","hex","toString","cryptoObj","crypto","msCrypto","getRandomValues","buffer","Uint8Array","_decimalToHex","guidHolder","r","guidResponse","Math","random","expires","parseInt","round","Date","getTime","iframeId","authFrame","getElementById","createElement","opera","navigator","userAgent","ifr","setAttribute","style","visibility","position","borderWidth","getElementsByTagName","appendChild","insertAdjacentHTML","frames","cacheLocation","_supportsLocalStorage","localStorage","setItem","_supportsSessionStorage","sessionStorage","getItem","copy","attr","_libVersion","level","Logging","timestamp","toUTCString","formattedMessage","stack","log"],"mappings":"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","file":"salte-auth.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"salte-auth\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"salte-auth\"] = factory();\n\telse\n\t\troot[\"salte-auth\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"salte-auth\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"salte-auth\"] = factory();\n\telse\n\t\troot[\"salte-auth\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/**\n\t * @public\n\t * @class Config\n\t * @property {clientId}        Identifier assigned to your app by Azure Active Directory\n\t * @property {redirectUri}     Endpoint at which you expect to receive tokens\n\t * @property {instance}        This is the URL path to the identity provider that authorize and logout will be called against.\n\t * @property {endpoints}       Collection of {Endpoint-ResourceId} used for autmatically attaching tokens in webApi calls\n\t * @property {scope}           This may be used to define the specific authorization(s) being requested from the resource owner.\n\t */\n\t\n\t/**\n\t * User information from idtoken.\n\t *  @class User\n\t *  @property {string} userName - username assigned from upn, email, or sub (i.e. subject).\n\t *  @property {object} profile - properties parsed from idtoken.\n\t */\n\t\n\t/**\n\t * Creates a new AuthenticationContext object.\n\t * @constructor\n\t * @param {object}  config               Configuration options for AuthenticationContext\n\t */\n\tvar AuthenticationContext = function () {\n\t  function AuthenticationContext(config) {\n\t    _classCallCheck(this, AuthenticationContext);\n\t\n\t    /**\n\t    * Enum for request type\n\t    * @enum {string}\n\t    */\n\t    this.REQUEST_TYPE = {\n\t      LOGIN: 'LOGIN',\n\t      RENEW_TOKEN: 'RENEW_TOKEN',\n\t      UNKNOWN: 'UNKNOWN'\n\t    };\n\t\n\t    /**\n\t    * Enum for storage constants\n\t    * @enum {string}\n\t    */\n\t    this.CONSTANTS = {\n\t      ACCESS_TOKEN: 'access_token',\n\t      EXPIRES_IN: 'expires_in',\n\t      ID_TOKEN: 'id_token',\n\t      ERROR_DESCRIPTION: 'error_description',\n\t      SESSION_STATE: 'session_state',\n\t      STORAGE: {\n\t        TOKEN_KEYS: 'auth.token.keys',\n\t        ACCESS_TOKEN_KEY: 'auth.access.token.key',\n\t        EXPIRATION_KEY: 'auth.expiration.key',\n\t        STATE_LOGIN: 'auth.state.login',\n\t        STATE_RENEW: 'auth.state.renew',\n\t        NONCE_IDTOKEN: 'auth.nonce.idtoken',\n\t        SESSION_STATE: 'auth.session.state',\n\t        USERNAME: 'auth.username',\n\t        IDTOKEN: 'auth.idtoken',\n\t        ERROR: 'auth.error',\n\t        ERROR_DESCRIPTION: 'auth.error.description',\n\t        LOGIN_REQUEST: 'auth.login.request',\n\t        LOGIN_ERROR: 'auth.login.error',\n\t        RENEW_STATUS: 'auth.token.renew.status'\n\t      },\n\t      RESOURCE_DELIMETER: '|',\n\t      LOADFRAME_TIMEOUT: '6000',\n\t      TOKEN_RENEW_STATUS_CANCELED: 'Canceled',\n\t      TOKEN_RENEW_STATUS_COMPLETED: 'Completed',\n\t      TOKEN_RENEW_STATUS_IN_PROGRESS: 'In Progress',\n\t      LOGGING_LEVEL: {\n\t        ERROR: 0,\n\t        WARN: 1,\n\t        INFO: 2,\n\t        VERBOSE: 3\n\t      },\n\t      LEVEL_STRING_MAP: {\n\t        0: 'ERROR:',\n\t        1: 'WARNING:',\n\t        2: 'INFO:',\n\t        3: 'VERBOSE:'\n\t      },\n\t      POPUP_WIDTH: 483,\n\t      POPUP_HEIGHT: 600\n\t    };\n\t\n\t    if (window.AuthenticationContext) {\n\t      return window.AuthenticationContext;\n\t    }\n\t    window.AuthenticationContext = this;\n\t\n\t    // public\n\t    this.config = {};\n\t    this.callback = null;\n\t    this.popUp = false;\n\t    this.isAngular = false;\n\t\n\t    // private\n\t    this._user = null;\n\t    this._activeRenewals = {};\n\t    this._loginInProgress = false;\n\t    this._renewStates = [];\n\t\n\t    window.callBackMappedToRenewStates = {};\n\t    window.callBacksMappedToRenewStates = {};\n\t\n\t    // validate before constructor assignments\n\t    if (config.displayCall && typeof config.displayCall !== 'function') {\n\t      throw new Error('displayCall is not a function');\n\t    }\n\t\n\t    if (!config.clientId) {\n\t      throw new Error('clientId is required');\n\t    }\n\t\n\t    this.config = this._cloneConfig(config);\n\t\n\t    if (this.config.popUp) {\n\t      this.popUp = true;\n\t    }\n\t\n\t    if (this.config.callback && typeof this.config.callback === 'function') {\n\t      this.callback = this.config.callback;\n\t    }\n\t\n\t    if (!this.config.instance || !this.config.instance.match(/^https:\\/\\/.*\\/$/)) {\n\t      throw new Error('instance must be a valid https endpoint that ends in a forward slash.');\n\t    }\n\t\n\t    // App can request idtoken for itself using clientid as resource\n\t    if (!this.config.loginResource) {\n\t      this.config.loginResource = this.config.clientId;\n\t    }\n\t\n\t    if (!this.config.redirectUri) {\n\t      this.config.redirectUri = window.location.href;\n\t    }\n\t\n\t    if (!this.config.anonymousEndpoints) {\n\t      this.config.anonymousEndpoints = [];\n\t    }\n\t\n\t    if (this.config.isAngular) {\n\t      this.isAngular = this.config.isAngular;\n\t    }\n\t\n\t    this.setResponseType(this.config.responseType);\n\t  }\n\t\n\t  _createClass(AuthenticationContext, [{\n\t    key: 'setResponseType',\n\t    value: function setResponseType(responseType) {\n\t      this.config.responseType = responseType || this.CONSTANTS.ID_TOKEN;\n\t    }\n\t\n\t    /**\n\t     * Gets initial Idtoken for the app backend\n\t     * Saves the resulting Idtoken in localStorage.\n\t     * @param {string} startPage the start page\n\t     */\n\t\n\t  }, {\n\t    key: 'login',\n\t    value: function login(startPage) {\n\t      // Token is not present and user needs to login\n\t      if (this._loginInProgress) {\n\t        this.info('Login in progress');\n\t        return;\n\t      }\n\t      var expectedState = this._guid();\n\t      this.config.state = expectedState;\n\t      this._idTokenNonce = this._guid();\n\t      if (!startPage) {\n\t        startPage = window.location;\n\t      }\n\t      this.verbose('Expected state: ' + expectedState + ' startPage:' + startPage);\n\t      this._saveItem(this.CONSTANTS.STORAGE.LOGIN_REQUEST, startPage);\n\t      this._saveItem(this.CONSTANTS.STORAGE.LOGIN_ERROR, '');\n\t      this._saveItem(this.CONSTANTS.STORAGE.STATE_LOGIN, expectedState);\n\t      this._saveItem(this.CONSTANTS.STORAGE.NONCE_IDTOKEN, this._idTokenNonce);\n\t      this._saveItem(this.CONSTANTS.STORAGE.ERROR, '');\n\t      this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, '');\n\t      var urlNavigate = this._getNavigateUrl(this.config.responseType, null) + '&nonce=' + encodeURIComponent(this._idTokenNonce);\n\t      this._loginInProgress = true;\n\t      if (this.popUp) {\n\t        this._loginPopup(urlNavigate);\n\t        return;\n\t      }\n\t      if (this.config.displayCall) {\n\t        // User defined way of handling the navigation\n\t        this.config.displayCall(urlNavigate);\n\t      } else {\n\t        this.promptUser(urlNavigate);\n\t      }\n\t    }\n\t  }, {\n\t    key: '_openPopup',\n\t    value: function _openPopup(urlNavigate, title, popUpWidth, popUpHeight) {\n\t      try {\n\t        /**\n\t        * adding winLeft and winTop to account for dual monitor\n\t        * using screenLeft and screenTop for IE8 and earlier\n\t        */\n\t        var winLeft = window.screenLeft ? window.screenLeft : window.screenX;\n\t        var winTop = window.screenTop ? window.screenTop : window.screenY;\n\t        /**\n\t        * window.innerWidth displays browser window's height and width excluding toolbars\n\t        * using document.documentElement.clientWidth for IE8 and earlier\n\t        */\n\t        var width = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;\n\t        var height = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;\n\t        var left = width / 2 - popUpWidth / 2 + winLeft;\n\t        var top = height / 2 - popUpHeight / 2 + winTop;\n\t\n\t        var popupWindow = window.open(urlNavigate, title, 'width=' + popUpWidth + ', height=' + popUpHeight + ', top=' + top + ', left=' + left);\n\t        if (popupWindow.focus) {\n\t          popupWindow.focus();\n\t        }\n\t        return popupWindow;\n\t      } catch (e) {\n\t        this.warn('Error opening popup, ' + e.message);\n\t        this._loginInProgress = false;\n\t        return null;\n\t      }\n\t    }\n\t  }, {\n\t    key: '_loginPopup',\n\t    value: function _loginPopup(urlNavigate) {\n\t      var popupWindow = this._openPopup(urlNavigate, 'login', this.CONSTANTS.POPUP_WIDTH, this.CONSTANTS.POPUP_HEIGHT);\n\t      if (popupWindow === null) {\n\t        this.warn('Popup Window is null. This can happen if you are using IE');\n\t        this._saveItem(this.CONSTANTS.STORAGE.ERROR, 'Error opening popup');\n\t        this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, 'Popup Window is null. This can happen if you are using IE');\n\t        this._saveItem(this.CONSTANTS.STORAGE.LOGIN_ERROR, 'Popup Window is null. This can happen if you are using IE');\n\t        if (this.callback) {\n\t          this.callback(this._getItem(this.CONSTANTS.STORAGE.LOGIN_ERROR), null);\n\t        }\n\t        return;\n\t      }\n\t      var registeredRedirectUri = void 0;\n\t      if (this.config.redirectUri.indexOf('#') === -1) {\n\t        registeredRedirectUri = this.config.redirectUri;\n\t      } else {\n\t        registeredRedirectUri = this.config.redirectUri.split('#')[0];\n\t      }\n\t      var that = this;\n\t      var pollTimer = window.setInterval(function () {\n\t        if (!popupWindow || popupWindow.closed || popupWindow.closed === undefined) {\n\t          that._loginInProgress = false;\n\t          window.clearInterval(pollTimer);\n\t        }\n\t        try {\n\t          if (popupWindow.location.href.indexOf(registeredRedirectUri) !== -1) {\n\t            if (that.isAngular) {\n\t              window.location.hash = popupWindow.location.hash;\n\t            } else {\n\t              that.handleWindowCallback(popupWindow.location.hash, popupWindow.location.search);\n\t            }\n\t            window.clearInterval(pollTimer);\n\t            that._loginInProgress = false;\n\t            that.info('Closing popup window');\n\t            popupWindow.close();\n\t          }\n\t        } catch (e) {}\n\t      }, 20);\n\t    }\n\t  }, {\n\t    key: 'loginInProgress',\n\t    value: function loginInProgress() {\n\t      return this._loginInProgress;\n\t    }\n\t  }, {\n\t    key: '_hasResource',\n\t    value: function _hasResource(key) {\n\t      var keys = this._getItem(this.CONSTANTS.STORAGE.TOKEN_KEYS);\n\t      return keys && !this._isEmpty(keys) && keys.indexOf(key + this.CONSTANTS.RESOURCE_DELIMETER) > -1;\n\t    }\n\t\n\t    /**\n\t     * Gets token for the specified resource from local storage cache\n\t     * @param {string}   resource A URI that identifies the resource for which the token is valid.\n\t     * @return {string} token if exists and not expired or null\n\t     */\n\t\n\t  }, {\n\t    key: 'getCachedToken',\n\t    value: function getCachedToken(resource) {\n\t      if (!this._hasResource(resource)) {\n\t        return null;\n\t      }\n\t\n\t      var token = this._getItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY + resource);\n\t      var expired = this._getItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY + resource);\n\t\n\t      // If expiration is within offset, it will force renew\n\t      var offset = this.config.expireOffsetSeconds || 120;\n\t\n\t      if (expired && expired > this._now() + offset) {\n\t        return token;\n\t      }\n\t      this._saveItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY + resource, '');\n\t      this._saveItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY + resource, 0);\n\t      return null;\n\t    }\n\t\n\t    /**\n\t     * Retrieves and parse idToken from localstorage\n\t     * @return {User} user object\n\t     */\n\t\n\t  }, {\n\t    key: 'getCachedUser',\n\t    value: function getCachedUser() {\n\t      if (this._user) {\n\t        return this._user;\n\t      }\n\t\n\t      var idtoken = this._getItem(this.CONSTANTS.STORAGE.IDTOKEN);\n\t      this._user = this._createUser(idtoken);\n\t      return this._user;\n\t    }\n\t  }, {\n\t    key: 'registerCallback',\n\t    value: function registerCallback(expectedState, resource, callback) {\n\t      this._activeRenewals[resource] = expectedState;\n\t      if (!window.callBacksMappedToRenewStates[expectedState]) {\n\t        window.callBacksMappedToRenewStates[expectedState] = [];\n\t      }\n\t      var self = this;\n\t      window.callBacksMappedToRenewStates[expectedState].push(callback);\n\t      if (!window.callBackMappedToRenewStates[expectedState]) {\n\t        window.callBackMappedToRenewStates[expectedState] = function (message, token) {\n\t          for (var i = 0; i < window.callBacksMappedToRenewStates[expectedState].length; ++i) {\n\t            try {\n\t              window.callBacksMappedToRenewStates[expectedState][i](message, token);\n\t            } catch (error) {\n\t              self.warn(error);\n\t            }\n\t          }\n\t          self._activeRenewals[resource] = null;\n\t          window.callBacksMappedToRenewStates[expectedState] = null;\n\t          window.callBackMappedToRenewStates[expectedState] = null;\n\t        };\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Acquires access token with hidden iframe\n\t     * @param {string} resource  ResourceUri identifying the target resource\n\t     * @param {string} callback  ResourceUri identifying the target resource\n\t     */\n\t\n\t  }, {\n\t    key: '_renewToken',\n\t    value: function _renewToken(resource, callback) {\n\t      // use iframe to try refresh token\n\t      // use given resource to create new authz url\n\t      this.info('renewToken is called for resource:' + resource);\n\t      var frameHandle = this._addAuthFrame('authRenewFrame' + resource);\n\t      var expectedState = this._guid() + '|' + resource;\n\t      this.config.state = expectedState;\n\t      // renew happens in iframe, so it keeps javascript context\n\t      this._renewStates.push(expectedState);\n\t\n\t      this.verbose('Renew token Expected state: ' + expectedState);\n\t      var urlNavigate = this._getNavigateUrl('token', resource) + '&prompt=none';\n\t      urlNavigate = this._addHintParameters(urlNavigate);\n\t\n\t      this.registerCallback(expectedState, resource, callback);\n\t      this.verbose('Navigate to:' + urlNavigate);\n\t      this._saveItem(this.CONSTANTS.STORAGE.LOGIN_REQUEST, '');\n\t      frameHandle.src = 'about:blank';\n\t      this._loadFrameTimeout(urlNavigate, 'authRenewFrame' + resource, resource);\n\t    }\n\t  }, {\n\t    key: '_renewIdToken',\n\t    value: function _renewIdToken(callback) {\n\t      // use iframe to try refresh token\n\t      this.info('renewIdToken is called');\n\t      var frameHandle = this._addAuthFrame('authIdTokenFrame');\n\t      var expectedState = this._guid() + '|' + this.config.clientId;\n\t      this._idTokenNonce = this._guid();\n\t      this._saveItem(this.CONSTANTS.STORAGE.NONCE_IDTOKEN, this._idTokenNonce);\n\t      this.config.state = expectedState;\n\t      // renew happens in iframe, so it keeps javascript context\n\t      this._renewStates.push(expectedState);\n\t\n\t      this.verbose('Renew Idtoken Expected state: ' + expectedState);\n\t      var urlNavigate = this._getNavigateUrl(this.config.responseType, null) + '&prompt=none';\n\t      urlNavigate = this._addHintParameters(urlNavigate);\n\t\n\t      urlNavigate += '&nonce=' + encodeURIComponent(this._idTokenNonce);\n\t      this.registerCallback(expectedState, this.config.clientId, callback);\n\t      this.idTokenNonce = null;\n\t      this.verbose('Navigate to:' + urlNavigate);\n\t      this._saveItem(this.CONSTANTS.STORAGE.LOGIN_REQUEST, '');\n\t      frameHandle.src = 'about:blank';\n\t      this._loadFrameTimeout(urlNavigate, 'authIdTokenFrame', this.config.clientId);\n\t    }\n\t  }, {\n\t    key: '_urlContainsQueryStringParameter',\n\t    value: function _urlContainsQueryStringParameter(name, url) {\n\t      // regex to detect pattern of a ? or & followed by the name parameter and an equals character\n\t      var regex = new RegExp('[\\\\?&]' + name + '=');\n\t      return regex.test(url);\n\t    }\n\t\n\t    // Calling _loadFrame but with a timeout to signal failure in loadframeStatus. Callbacks are left\n\t    // registered when network errors occur and subsequent token requests for same resource are registered to the pending request\n\t\n\t  }, {\n\t    key: '_loadFrameTimeout',\n\t    value: function _loadFrameTimeout(urlNavigation, frameName, resource) {\n\t      // set iframe session to pending\n\t      this.verbose('Set loading state to pending for: ' + resource);\n\t      this._saveItem(this.CONSTANTS.STORAGE.RENEW_STATUS + resource, this.CONSTANTS.TOKEN_RENEW_STATUS_IN_PROGRESS);\n\t      this._loadFrame(urlNavigation, frameName);\n\t      var self = this;\n\t      setTimeout(function () {\n\t        if (self._getItem(self.CONSTANTS.STORAGE.RENEW_STATUS + resource) === self.CONSTANTS.TOKEN_RENEW_STATUS_IN_PROGRESS) {\n\t          // fail the iframe session if it's in pending state\n\t          self.verbose('Loading frame has timed out after: ' + self.CONSTANTS.LOADFRAME_TIMEOUT / 1000 + ' seconds for resource ' + resource);\n\t          var expectedState = self._activeRenewals[resource];\n\t          if (expectedState && window.callBackMappedToRenewStates[expectedState]) {\n\t            window.callBackMappedToRenewStates[expectedState]('Token renewal operation failed due to timeout', null);\n\t          }\n\t\n\t          self._saveItem(self.CONSTANTS.STORAGE.RENEW_STATUS + resource, self.CONSTANTS.TOKEN_RENEW_STATUS_CANCELED);\n\t        }\n\t      }, self.CONSTANTS.LOADFRAME_TIMEOUT);\n\t    }\n\t  }, {\n\t    key: '_loadFrame',\n\t    value: function _loadFrame(urlNavigate, frameName) {\n\t      // This trick overcomes iframe navigation in IE\n\t      // IE does not load the page consistently in iframe\n\t      var self = this;\n\t      self.info('LoadFrame: ' + frameName);\n\t      var frameCheck = frameName;\n\t      setTimeout(function () {\n\t        var frameHandle = self._addAuthFrame(frameCheck);\n\t        if (frameHandle.src === '' || frameHandle.src === 'about:blank') {\n\t          frameHandle.src = urlNavigate;\n\t          self._loadFrame(urlNavigate, frameCheck);\n\t        }\n\t      }, 500);\n\t    }\n\t\n\t    /**\n\t     * Acquire token from cache if not expired and available. Acquires token from iframe if expired.\n\t     * @param {string} resource  ResourceUri identifying the target resource\n\t     * @param {function} callback The callback function\n\t     */\n\t\n\t  }, {\n\t    key: 'acquireToken',\n\t    value: function acquireToken(resource, callback) {\n\t      if (this._isEmpty(resource)) {\n\t        this.warn('resource is required');\n\t        callback('resource is required', null);\n\t        return;\n\t      }\n\t\n\t      var token = this.getCachedToken(resource);\n\t      if (token) {\n\t        this.info('Token is already in cache for resource:' + resource);\n\t        callback(null, token);\n\t        return;\n\t      }\n\t\n\t      if (!this._user) {\n\t        this.warn('User login is required');\n\t        callback('User login is required', null);\n\t        return;\n\t      }\n\t\n\t      // refresh attept with iframe\n\t      // Already renewing for this resource, callback when we get the token.\n\t      if (this._activeRenewals[resource]) {\n\t        // Active renewals contains the state for each renewal.\n\t        this.registerCallback(this._activeRenewals[resource], resource, callback);\n\t      } else if (resource === this.config.clientId) {\n\t        // App uses idtoken to send to api endpoints\n\t        // Default resource is tracked as clientid to store this token\n\t        this.verbose('renewing idtoken');\n\t        this._renewIdToken(callback);\n\t      } else {\n\t        this._renewToken(resource, callback);\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Redirect the Browser to Azure AD Authorization endpoint\n\t     * @param {string} urlNavigate The authorization request url\n\t     */\n\t\n\t  }, {\n\t    key: 'promptUser',\n\t    value: function promptUser(urlNavigate) {\n\t      if (urlNavigate) {\n\t        this.info('Navigate to:' + urlNavigate);\n\t        window.location.replace(urlNavigate);\n\t      } else {\n\t        this.info('Navigate url is empty');\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Clear cache items.\n\t     */\n\t\n\t  }, {\n\t    key: 'clearCache',\n\t    value: function clearCache() {\n\t      this._saveItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY, '');\n\t      this._saveItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY, 0);\n\t      this._saveItem(this.CONSTANTS.STORAGE.SESSION_STATE, '');\n\t      this._saveItem(this.CONSTANTS.STORAGE.STATE_LOGIN, '');\n\t      this._renewStates = [];\n\t      this._saveItem(this.CONSTANTS.STORAGE.USERNAME, '');\n\t      this._saveItem(this.CONSTANTS.STORAGE.IDTOKEN, '');\n\t      this._saveItem(this.CONSTANTS.STORAGE.ERROR, '');\n\t      this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, '');\n\t      var keys = this._getItem(this.CONSTANTS.STORAGE.TOKEN_KEYS);\n\t\n\t      if (!this._isEmpty(keys)) {\n\t        keys = keys.split(this.CONSTANTS.RESOURCE_DELIMETER);\n\t        for (var i = 0; i < keys.length; i++) {\n\t          this._saveItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY + keys[i], '');\n\t          this._saveItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY + keys[i], 0);\n\t        }\n\t      }\n\t      this._saveItem(this.CONSTANTS.STORAGE.TOKEN_KEYS, '');\n\t    }\n\t\n\t    /**\n\t     * Clear cache items for a resource.\n\t     * @param {string} resource The resource\n\t     */\n\t\n\t  }, {\n\t    key: 'clearCacheForResource',\n\t    value: function clearCacheForResource(resource) {\n\t      this._saveItem(this.CONSTANTS.STORAGE.STATE_RENEW, '');\n\t      this._saveItem(this.CONSTANTS.STORAGE.ERROR, '');\n\t      this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, '');\n\t      if (this._hasResource(resource)) {\n\t        this._saveItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY + resource, '');\n\t        this._saveItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY + resource, 0);\n\t      }\n\t    }\n\t\n\t    /**\n\t     * Logout user will redirect page to logout endpoint.\n\t     * After logout, it will redirect to post_logout page if provided.\n\t     */\n\t\n\t  }, {\n\t    key: 'logOut',\n\t    value: function logOut() {\n\t      this.clearCache();\n\t      var logout = '';\n\t      this._user = null;\n\t\n\t      if (this.config.postLogoutRedirectUri) {\n\t        logout = 'post_logout_redirect_uri=' + encodeURIComponent(this.config.postLogoutRedirectUri);\n\t      }\n\t\n\t      var urlNavigate = this.config.instance + 'logout?' + logout;\n\t      this.info('Logout navigate to: ' + urlNavigate);\n\t      this.promptUser(urlNavigate);\n\t    }\n\t  }, {\n\t    key: '_isEmpty',\n\t    value: function _isEmpty(str) {\n\t      return typeof str === 'undefined' || !str || str.length === 0;\n\t    }\n\t\n\t    /**\n\t     * Gets a user profile\n\t     * @param {requestCallback} callback The callback that handles the response.\n\t     */\n\t\n\t  }, {\n\t    key: 'getUser',\n\t    value: function getUser(callback) {\n\t      // IDToken is first call\n\t      if (typeof callback !== 'function') {\n\t        throw new Error('callback is not a function');\n\t      }\n\t\n\t      // user in memory\n\t      if (this._user) {\n\t        callback(null, this._user);\n\t        return;\n\t      }\n\t\n\t      // frame is used to get idtoken\n\t      var idtoken = this._getItem(this.CONSTANTS.STORAGE.IDTOKEN);\n\t      if (this._isEmpty(idtoken)) {\n\t        this.warn('User information is not available');\n\t        callback('User information is not available');\n\t      } else {\n\t        this.info('User exists in cache: ');\n\t        this._user = this._createUser(idtoken);\n\t        callback(null, this._user);\n\t      }\n\t    }\n\t  }, {\n\t    key: '_addHintParameters',\n\t    value: function _addHintParameters(urlNavigate) {\n\t      // include hint params only if upn is present\n\t      if (this._user && this._user.profile && this._user.profile.hasOwnProperty('upn')) {\n\t        // add login_hint\n\t        urlNavigate += '&login_hint=' + encodeURIComponent(this._user.profile.upn);\n\t\n\t        // don't add domain_hint twice if user provided it in the extraQueryParameter value\n\t        if (!this._urlContainsQueryStringParameter('domain_hint', urlNavigate) && this._user.profile.upn.indexOf('@') > -1) {\n\t          var parts = this._user.profile.upn.split('@');\n\t          // local part can include @ in quotes. Sending last part handles that.\n\t          urlNavigate += '&domain_hint=' + encodeURIComponent(parts[parts.length - 1]);\n\t        }\n\t      }\n\t\n\t      return urlNavigate;\n\t    }\n\t  }, {\n\t    key: '_createUser',\n\t    value: function _createUser(idToken) {\n\t      var user = null;\n\t      var parsedJson = this._extractIdToken(idToken);\n\t      if (parsedJson && parsedJson.hasOwnProperty('aud')) {\n\t        var audienceMatch = false;\n\t\n\t        if (Array.isArray(parsedJson.aud)) {\n\t          // If the ID Token contains multiple audiences then an azp claim must be present and equal to the client id.\n\t          if (parsedJson.hasOwnProperty('azp') && parsedJson.azp.toLowerCase() === this.config.clientId.toLowerCase()) {\n\t            for (var i = 0; i < parsedJson.aud.length; i++) {\n\t              if (parsedJson.aud[i].toLowerCase() === this.config.clientId.toLowerCase()) {\n\t                audienceMatch = true;\n\t                break;\n\t              }\n\t            }\n\t          }\n\t        } else {\n\t          audienceMatch = parsedJson.aud.toLowerCase() === this.config.clientId.toLowerCase();\n\t        }\n\t\n\t        if (audienceMatch) {\n\t          user = {\n\t            userName: '',\n\t            profile: parsedJson\n\t          };\n\t\n\t          if (parsedJson.hasOwnProperty('upn')) {\n\t            user.userName = parsedJson.upn;\n\t          } else if (parsedJson.hasOwnProperty('email')) {\n\t            user.userName = parsedJson.email;\n\t          } else if (parsedJson.hasOwnProperty('sub')) {\n\t            user.userName = parsedJson.sub;\n\t          }\n\t        } else {\n\t          this.warn('IdToken has invalid aud/azp field');\n\t        }\n\t      }\n\t\n\t      return user;\n\t    }\n\t  }, {\n\t    key: '_getHash',\n\t    value: function _getHash(hash) {\n\t      if (hash.indexOf('#/') > -1) {\n\t        hash = hash.substring(hash.indexOf('#/') + 2);\n\t      } else if (hash.indexOf('#') > -1) {\n\t        hash = hash.substring(1);\n\t      }\n\t\n\t      return hash;\n\t    }\n\t  }, {\n\t    key: '_getSearch',\n\t    value: function _getSearch(search) {\n\t      if (search.indexOf('?') > -1) {\n\t        search = search.substring(1);\n\t      }\n\t\n\t      return search;\n\t    }\n\t  }, {\n\t    key: '_getParameters',\n\t    value: function _getParameters(hash, search) {\n\t      var parameters = {};\n\t\n\t      if (hash) {\n\t        hash = this._getHash(hash);\n\t        parameters = this._deserialize(hash);\n\t      }\n\t\n\t      if (search) {\n\t        search = this._getSearch(search);\n\t        var searchParameters = this._deserialize(search);\n\t        parameters = this._extend(parameters, searchParameters);\n\t      }\n\t\n\t      return parameters;\n\t    }\n\t  }, {\n\t    key: '_extend',\n\t    value: function _extend(obj, src) {\n\t      for (var key in src) {\n\t        if (src.hasOwnProperty(key)) {\n\t          obj[key] = src[key];\n\t        }\n\t      }\n\t      return obj;\n\t    }\n\t\n\t    /**\n\t     * Checks if hash contains access token or id token or error_description\n\t     * @param {string} hash  -  Hash passed from redirect page\n\t     * @param {string} search  -  Search passed from redirect page\n\t     * @return {boolean} exists if all the parameters exist\n\t     */\n\t\n\t  }, {\n\t    key: 'isCallback',\n\t    value: function isCallback(hash, search) {\n\t      var parameters = this._getParameters(hash, search);\n\t\n\t      return parameters.hasOwnProperty(this.CONSTANTS.ERROR_DESCRIPTION) || parameters.hasOwnProperty(this.CONSTANTS.ACCESS_TOKEN) || parameters.hasOwnProperty(this.CONSTANTS.ID_TOKEN);\n\t    }\n\t\n\t    /**\n\t     * Gets login error\n\t     * @return {string} error message related to login\n\t     */\n\t\n\t  }, {\n\t    key: 'getLoginError',\n\t    value: function getLoginError() {\n\t      return this._getItem(this.CONSTANTS.STORAGE.LOGIN_ERROR);\n\t    }\n\t\n\t    /**\n\t     * Gets requestInfo from given hash.\n\t     * @param {string} hash  -  Hash passed from redirect page\n\t     * @param {string} search  -  Search passed from redirect page\n\t     * @return {string} error message related to login\n\t     */\n\t\n\t  }, {\n\t    key: 'getRequestInfo',\n\t    value: function getRequestInfo(hash, search) {\n\t      var parameters = this._getParameters(hash, search);\n\t      var requestInfo = {\n\t        valid: false,\n\t        parameters: {},\n\t        stateMatch: false,\n\t        stateResponse: '',\n\t        requestType: this.REQUEST_TYPE.UNKNOWN\n\t      };\n\t\n\t      if (parameters) {\n\t        requestInfo.parameters = parameters;\n\t        if (parameters.hasOwnProperty(this.CONSTANTS.ERROR_DESCRIPTION) || parameters.hasOwnProperty(this.CONSTANTS.ACCESS_TOKEN) || parameters.hasOwnProperty(this.CONSTANTS.ID_TOKEN)) {\n\t          requestInfo.valid = true;\n\t\n\t          // which call\n\t          var stateResponse = '';\n\t          if (parameters.hasOwnProperty('state')) {\n\t            this.verbose('State: ' + parameters.state);\n\t            stateResponse = parameters.state;\n\t          } else {\n\t            this.warn('No state returned');\n\t            return requestInfo;\n\t          }\n\t\n\t          requestInfo.stateResponse = stateResponse;\n\t\n\t          // async calls can fire iframe and login request at the same time if developer does not use the API as expected\n\t          // incoming callback needs to be looked up to find the request type\n\t          if (stateResponse === this._getItem(this.CONSTANTS.STORAGE.STATE_LOGIN)) {\n\t            requestInfo.requestType = this.REQUEST_TYPE.LOGIN;\n\t            requestInfo.stateMatch = true;\n\t            return requestInfo;\n\t          }\n\t\n\t          // external api requests may have many renewtoken requests for different resource\n\t          if (!requestInfo.stateMatch && window.parent && window.parent.AuthenticationContext) {\n\t            var statesInParentContext = window.parent.AuthenticationContext._renewStates;\n\t            for (var i = 0; i < statesInParentContext.length; i++) {\n\t              if (statesInParentContext[i] === requestInfo.stateResponse) {\n\t                requestInfo.requestType = this.REQUEST_TYPE.RENEW_TOKEN;\n\t                requestInfo.stateMatch = true;\n\t                break;\n\t              }\n\t            }\n\t          }\n\t        }\n\t      }\n\t\n\t      return requestInfo;\n\t    }\n\t  }, {\n\t    key: '_getResourceFromState',\n\t    value: function _getResourceFromState(state) {\n\t      if (state) {\n\t        var splitIndex = state.indexOf('|');\n\t        if (splitIndex > -1 && splitIndex + 1 < state.length) {\n\t          return state.substring(splitIndex + 1);\n\t        }\n\t      }\n\t\n\t      return '';\n\t    }\n\t\n\t    /**\n\t     * Saves token from hash that is received from redirect.\n\t     * @param {string} requestInfo Hash passed from redirect page\n\t     */\n\t\n\t  }, {\n\t    key: 'saveTokenFromHash',\n\t    value: function saveTokenFromHash(requestInfo) {\n\t      this.info('State status:' + requestInfo.stateMatch + '; Request type:' + requestInfo.requestType);\n\t      this._saveItem(this.CONSTANTS.STORAGE.ERROR, '');\n\t      this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, '');\n\t\n\t      var resource = this._getResourceFromState(requestInfo.stateResponse);\n\t\n\t      // Record error\n\t      if (requestInfo.parameters.hasOwnProperty(this.CONSTANTS.ERROR_DESCRIPTION)) {\n\t        this.info('Error :' + requestInfo.parameters.error + '; Error description:' + requestInfo.parameters[this.CONSTANTS.ERROR_DESCRIPTION]);\n\t        this._saveItem(this.CONSTANTS.STORAGE.ERROR, requestInfo.parameters.error);\n\t        this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, requestInfo.parameters[this.CONSTANTS.ERROR_DESCRIPTION]);\n\t\n\t        if (requestInfo.requestType === this.REQUEST_TYPE.LOGIN) {\n\t          this._loginInProgress = false;\n\t          this._saveItem(this.CONSTANTS.STORAGE.LOGIN_ERROR, requestInfo.parameters.error_description);\n\t        }\n\t      } else if (requestInfo.stateMatch) {\n\t        // record tokens to storage if exists\n\t        this.info('State is right');\n\t        if (requestInfo.parameters.hasOwnProperty(this.CONSTANTS.SESSION_STATE)) {\n\t          this._saveItem(this.CONSTANTS.STORAGE.SESSION_STATE, requestInfo.parameters[this.CONSTANTS.SESSION_STATE]);\n\t        }\n\t\n\t        var keys = void 0;\n\t\n\t        if (requestInfo.parameters.hasOwnProperty(this.CONSTANTS.ACCESS_TOKEN)) {\n\t          this.info('Fragment has access token');\n\t\n\t          if (!this._hasResource(resource)) {\n\t            keys = this._getItem(this.CONSTANTS.STORAGE.TOKEN_KEYS) || '';\n\t            this._saveItem(this.CONSTANTS.STORAGE.TOKEN_KEYS, keys + resource + this.CONSTANTS.RESOURCE_DELIMETER);\n\t          }\n\t          // save token with related resource\n\t          this._saveItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY + resource, requestInfo.parameters[this.CONSTANTS.ACCESS_TOKEN]);\n\t          this._saveItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY + resource, this._expiresIn(requestInfo.parameters[this.CONSTANTS.EXPIRES_IN]));\n\t        }\n\t\n\t        if (requestInfo.parameters.hasOwnProperty(this.CONSTANTS.ID_TOKEN)) {\n\t          this.info('Fragment has id token');\n\t          this._loginInProgress = false;\n\t\n\t          this._user = this._createUser(requestInfo.parameters[this.CONSTANTS.ID_TOKEN]);\n\t\n\t          if (this._user && this._user.profile) {\n\t            if (this._user.profile.nonce === this._getItem(this.CONSTANTS.STORAGE.NONCE_IDTOKEN)) {\n\t              this._saveItem(this.CONSTANTS.STORAGE.IDTOKEN, requestInfo.parameters[this.CONSTANTS.ID_TOKEN]);\n\t\n\t              // Save idtoken as access token for app itself\n\t              resource = this.config.loginResource ? this.config.loginResource : this.config.clientId;\n\t\n\t              if (!this._hasResource(resource)) {\n\t                keys = this._getItem(this.CONSTANTS.STORAGE.TOKEN_KEYS) || '';\n\t                this._saveItem(this.CONSTANTS.STORAGE.TOKEN_KEYS, keys + resource + this.CONSTANTS.RESOURCE_DELIMETER);\n\t              }\n\t              this._saveItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY + resource, requestInfo.parameters[this.CONSTANTS.ID_TOKEN]);\n\t              this._saveItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY + resource, this._user.profile.exp);\n\t            } else {\n\t              this._user = null;\n\t              this._saveItem(this.CONSTANTS.STORAGE.LOGIN_ERROR, 'Nonce is not same as ' + this._idTokenNonce);\n\t            }\n\t          } else {\n\t            this._saveItem(this.CONSTANTS.STORAGE.ERROR, 'invalid id_token');\n\t            this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, 'Invalid id_token. id_token: ' + requestInfo.parameters[this.CONSTANTS.ID_TOKEN]);\n\t          }\n\t        }\n\t      } else {\n\t        this._saveItem(this.CONSTANTS.STORAGE.ERROR, 'Invalid_state');\n\t        this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, 'Invalid_state. state: ' + requestInfo.stateResponse);\n\t      }\n\t      this._saveItem(this.CONSTANTS.STORAGE.RENEW_STATUS + resource, this.CONSTANTS.TOKEN_RENEW_STATUS_COMPLETED);\n\t    }\n\t\n\t    /**\n\t     * Gets resource for given endpoint if mapping is provided with config.\n\t     * @param {string} endpoint API endpoint\n\t     * @return {string} resource for this API endpoint\n\t     */\n\t\n\t  }, {\n\t    key: 'getResourceForEndpoint',\n\t    value: function getResourceForEndpoint(endpoint) {\n\t      if (this.config && this.config.endpoints) {\n\t        for (var configEndpoint in this.config.endpoints) {\n\t          // configEndpoint is like /api/Todo requested endpoint can be /api/Todo/1\n\t          if (endpoint.indexOf(configEndpoint) > -1) {\n\t            return this.config.endpoints[configEndpoint];\n\t          }\n\t        }\n\t      }\n\t\n\t      // default resource will be clientid if nothing specified\n\t      // App will use idtoken for calls to itself\n\t      // check if it's staring from http or https, needs to match with app host\n\t      if (endpoint.indexOf('http://') > -1 || endpoint.indexOf('https://') > -1) {\n\t        if (this._getHostFromUri(endpoint) === this._getHostFromUri(this.config.redirectUri)) {\n\t          return this.config.loginResource;\n\t        }\n\t      } else {\n\t        // in angular level, the url for $http interceptor call could be relative url,\n\t        // if it's relative call, we'll treat it as app backend call.\n\t        // if user specified list of anonymous endpoints, no need to send token to these endpoints, return null.\n\t        if (this.config && this.config.anonymousEndpoints) {\n\t          for (var i = 0; i < this.config.anonymousEndpoints.length; i++) {\n\t            if (endpoint.indexOf(this.config.anonymousEndpoints[i]) > -1) {\n\t              return null;\n\t            }\n\t          }\n\t        }\n\t        // all other app's backend calls are secured.\n\t        return this.config.loginResource;\n\t      }\n\t\n\t      // if not the app's own backend or not a domain listed in the endpoints structure\n\t      return null;\n\t    }\n\t  }, {\n\t    key: '_getHostFromUri',\n\t    value: function _getHostFromUri(uri) {\n\t      // remove http:// or https:// from uri\n\t      var extractedUri = String(uri).replace(/^(https?:)\\/\\//, '');\n\t\n\t      extractedUri = extractedUri.split('/')[0];\n\t      return extractedUri;\n\t    }\n\t\n\t    /* exported  oauth2Callback */\n\t\n\t  }, {\n\t    key: 'handleWindowCallback',\n\t    value: function handleWindowCallback(hash, search) {\n\t      // This is for regular javascript usage for redirect handling\n\t      // need to make sure this is for callback\n\t      if (!hash) {\n\t        hash = window.location.hash;\n\t      }\n\t\n\t      if (!search) {\n\t        search = window.location.search;\n\t      }\n\t\n\t      if (this.isCallback(hash, search)) {\n\t        var requestInfo = this.getRequestInfo(hash, search);\n\t        this.info('Returned from redirect url');\n\t        this.saveTokenFromHash(requestInfo);\n\t        var callback = null;\n\t        if (requestInfo.requestType === this.REQUEST_TYPE.RENEW_TOKEN && window.parent && window.parent !== window) {\n\t          // iframe call but same single page\n\t          this.verbose('Window is in iframe');\n\t          callback = window.parent.callBackMappedToRenewStates[requestInfo.stateResponse];\n\t          if (callback) {\n\t            callback(this._getItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION), requestInfo.parameters[this.CONSTANTS.ACCESS_TOKEN] || requestInfo.parameters[this.CONSTANTS.ID_TOKEN]);\n\t          }\n\t          return;\n\t        } else if (requestInfo.requestType === this.REQUEST_TYPE.LOGIN) {\n\t          callback = this.callback;\n\t          if (callback) {\n\t            callback(this._getItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION), requestInfo.parameters[this.CONSTANTS.ID_TOKEN]);\n\t          }\n\t        }\n\t        // No need to redirect user in case of popup\n\t        if (!this.popUp) {\n\t          window.location = this._getItem(this.CONSTANTS.STORAGE.LOGIN_REQUEST);\n\t        }\n\t      }\n\t    }\n\t  }, {\n\t    key: '_getNavigateUrl',\n\t    value: function _getNavigateUrl(responseType, resource) {\n\t      var urlNavigate = this.config.instance + 'authorize' + this._serialize(responseType, this.config, resource) + this._addLibMetadata();\n\t      if (this.config.scope) {\n\t        urlNavigate += '&scope=' + encodeURIComponent(this.config.scope);\n\t      }\n\t      this.info('Navigate url:' + urlNavigate);\n\t      return urlNavigate;\n\t    }\n\t  }, {\n\t    key: '_extractIdToken',\n\t    value: function _extractIdToken(encodedIdToken) {\n\t      // id token will be decoded to get the username\n\t      var decodedToken = this._decodeJwt(encodedIdToken);\n\t      if (!decodedToken) {\n\t        return null;\n\t      }\n\t\n\t      try {\n\t        var base64IdToken = decodedToken.JWSPayload;\n\t        var base64Decoded = this._base64DecodeStringUrlSafe(base64IdToken);\n\t        if (!base64Decoded) {\n\t          this.info('The returned id_token could not be base64 url safe decoded.');\n\t          return null;\n\t        }\n\t\n\t        return JSON.parse(base64Decoded);\n\t      } catch (err) {\n\t        this.error('The returned id_token could not be decoded', err);\n\t      }\n\t\n\t      return null;\n\t    }\n\t  }, {\n\t    key: '_base64DecodeStringUrlSafe',\n\t    value: function _base64DecodeStringUrlSafe(base64IdToken) {\n\t      // html5 should support atob function for decoding\n\t      base64IdToken = base64IdToken.replace(/-/g, '+').replace(/_/g, '/');\n\t      if (window.atob) {\n\t        return decodeURIComponent(escape(window.atob(base64IdToken)));\n\t      }\n\t      return decodeURIComponent(escape(this._decode(base64IdToken)));\n\t    }\n\t\n\t    // Take https://cdnjs.cloudflare.com/ajax/libs/Base64/0.3.0/base64.js and https://en.wikipedia.org/wiki/Base64 as reference.\n\t\n\t  }, {\n\t    key: '_decode',\n\t    value: function _decode(base64IdToken) {\n\t      var codes = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\t      base64IdToken = String(base64IdToken).replace(/[=]+$/, '');\n\t\n\t      var length = base64IdToken.length;\n\t      if (length % 4 === 1) {\n\t        throw new Error('The token to be decoded is not correctly encoded.');\n\t      }\n\t\n\t      var h1 = void 0,\n\t          h2 = void 0,\n\t          h3 = void 0,\n\t          h4 = void 0,\n\t          bits = void 0,\n\t          c1 = void 0,\n\t          c2 = void 0,\n\t          c3 = void 0;\n\t      var decoded = '';\n\t      for (var i = 0; i < length; i += 4) {\n\t        // Every 4 base64 encoded character will be converted to 3 byte string, which is 24 bits\n\t        // then 6 bits per base64 encoded character\n\t        h1 = codes.indexOf(base64IdToken.charAt(i));\n\t        h2 = codes.indexOf(base64IdToken.charAt(i + 1));\n\t        h3 = codes.indexOf(base64IdToken.charAt(i + 2));\n\t        h4 = codes.indexOf(base64IdToken.charAt(i + 3));\n\t\n\t        // For padding, if last two are '='\n\t        if (i + 2 === length - 1) {\n\t          bits = h1 << 18 | h2 << 12 | h3 << 6;\n\t          c1 = bits >> 16 & 255;\n\t          c2 = bits >> 8 & 255;\n\t          decoded += String.fromCharCode(c1, c2);\n\t          break;\n\t        } else if (i + 1 === length - 1) {\n\t          // if last one is '='\n\t          bits = h1 << 18 | h2 << 12;\n\t          c1 = bits >> 16 & 255;\n\t          decoded += String.fromCharCode(c1);\n\t          break;\n\t        }\n\t\n\t        bits = h1 << 18 | h2 << 12 | h3 << 6 | h4;\n\t\n\t        // then convert to 3 byte chars\n\t        c1 = bits >> 16 & 255;\n\t        c2 = bits >> 8 & 255;\n\t        c3 = bits & 255;\n\t\n\t        decoded += String.fromCharCode(c1, c2, c3);\n\t      }\n\t\n\t      return decoded;\n\t    }\n\t\n\t    // Auth.node js crack function\n\t\n\t  }, {\n\t    key: '_decodeJwt',\n\t    value: function _decodeJwt(jwtToken) {\n\t      if (this._isEmpty(jwtToken)) {\n\t        return null;\n\t      }\n\t\n\t      var idTokenPartsRegex = /^([^\\.\\s]*)\\.([^\\.\\s]+)\\.([^\\.\\s]*)$/;\n\t\n\t      var matches = idTokenPartsRegex.exec(jwtToken);\n\t      if (!matches || matches.length < 4) {\n\t        this.warn('The returned id_token is not parseable.');\n\t        return null;\n\t      }\n\t\n\t      var crackedToken = {\n\t        header: matches[1],\n\t        JWSPayload: matches[2],\n\t        JWSSig: matches[3]\n\t      };\n\t\n\t      return crackedToken;\n\t    }\n\t  }, {\n\t    key: '_convertUrlSafeToRegularBase64EncodedString',\n\t    value: function _convertUrlSafeToRegularBase64EncodedString(str) {\n\t      return str.replace('-', '+').replace('_', '/');\n\t    }\n\t  }, {\n\t    key: '_serialize',\n\t    value: function _serialize(responseType, obj, resource) {\n\t      var str = [];\n\t      if (obj !== null) {\n\t        str.push('?response_type=' + encodeURIComponent(responseType));\n\t        str.push('client_id=' + encodeURIComponent(obj.clientId));\n\t        if (resource) {\n\t          str.push('resource=' + encodeURIComponent(resource));\n\t        }\n\t\n\t        str.push('redirect_uri=' + encodeURIComponent(obj.redirectUri));\n\t        str.push('state=' + encodeURIComponent(obj.state));\n\t\n\t        if (obj.hasOwnProperty('slice')) {\n\t          str.push('slice=' + encodeURIComponent(obj.slice));\n\t        }\n\t\n\t        if (obj.hasOwnProperty('extraQueryParameter')) {\n\t          str.push(obj.extraQueryParameter);\n\t        }\n\t\n\t        var correlationId = obj.correlationId ? obj.correlationId : this._guid();\n\t        str.push('client-request-id=' + encodeURIComponent(correlationId));\n\t      }\n\t\n\t      return str.join('&');\n\t    }\n\t  }, {\n\t    key: '_deserialize',\n\t    value: function _deserialize(query) {\n\t      var pl = /\\+/g; // Regex for replacing addition symbol with a space\n\t      var search = /([^&=]+)=([^&]*)/g;\n\t      var decode = function decode(s) {\n\t        return decodeURIComponent(s.replace(pl, ' '));\n\t      };\n\t      var obj = {};\n\t      var match = search.exec(query);\n\t      while (match) {\n\t        obj[decode(match[1])] = decode(match[2]);\n\t        match = search.exec(query);\n\t      }\n\t\n\t      return obj;\n\t    }\n\t  }, {\n\t    key: '_decimalToHex',\n\t    value: function _decimalToHex(number) {\n\t      var hex = number.toString(16);\n\t      while (hex.length < 2) {\n\t        hex = '0' + hex;\n\t      }\n\t      return hex;\n\t    }\n\t  }, {\n\t    key: '_guid',\n\t    value: function _guid() {\n\t      // RFC4122: The version 4 UUID is meant for generating UUIDs from truly-random or\n\t      // pseudo-random numbers.\n\t      // The algorithm is as follows:\n\t      //     Set the two most significant bits (bits 6 and 7) of the\n\t      //        clock_seq_hi_and_reserved to zero and one, respectively.\n\t      //     Set the four most significant bits (bits 12 through 15) of the\n\t      //        time_hi_and_version field to the 4-bit version number from\n\t      //        Section 4.1.3. Version4\n\t      //     Set all the other bits to randomly (or pseudo-randomly) chosen\n\t      //     values.\n\t      // UUID                   = time-low \"-\" time-mid \"-\"time-high-and-version \"-\"clock-seq-reserved and low(2hexOctet)\"-\" node\n\t      // time-low               = 4hexOctet\n\t      // time-mid               = 2hexOctet\n\t      // time-high-and-version  = 2hexOctet\n\t      // clock-seq-and-reserved = hexOctet:\n\t      // clock-seq-low          = hexOctet\n\t      // node                   = 6hexOctet\n\t      // Format: xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\n\t      // y could be 1000, 1001, 1010, 1011 since most significant two bits needs to be 10\n\t      // y values are 8, 9, A, B\n\t      var cryptoObj = window.crypto || window.msCrypto; // for IE 11\n\t      if (cryptoObj && cryptoObj.getRandomValues) {\n\t        var buffer = new Uint8Array(16);\n\t        cryptoObj.getRandomValues(buffer);\n\t        // buffer[6] and buffer[7] represents the time_hi_and_version field. We will set the four most significant bits (4 through 7) of buffer[6] to represent decimal number 4 (UUID version number).\n\t        buffer[6] |= 0x40; // buffer[6] | 01000000 will set the 6 bit to 1.\n\t        buffer[6] &= 0x4f; // buffer[6] & 01001111 will set the 4, 5, and 7 bit to 0 such that bits 4-7 == 0100 = \"4\".\n\t        // buffer[8] represents the clock_seq_hi_and_reserved field. We will set the two most significant bits (6 and 7) of the clock_seq_hi_and_reserved to zero and one, respectively.\n\t        buffer[8] |= 0x80; // buffer[8] | 10000000 will set the 7 bit to 1.\n\t        buffer[8] &= 0xbf; // buffer[8] & 10111111 will set the 6 bit to 0.\n\t        return this._decimalToHex(buffer[0]) + this._decimalToHex(buffer[1]) + this._decimalToHex(buffer[2]) + this._decimalToHex(buffer[3]) + '-' + this._decimalToHex(buffer[4]) + this._decimalToHex(buffer[5]) + '-' + this._decimalToHex(buffer[6]) + this._decimalToHex(buffer[7]) + '-' + this._decimalToHex(buffer[8]) + this._decimalToHex(buffer[9]) + '-' + this._decimalToHex(buffer[10]) + this._decimalToHex(buffer[11]) + this._decimalToHex(buffer[12]) + this._decimalToHex(buffer[13]) + this._decimalToHex(buffer[14]) + this._decimalToHex(buffer[15]);\n\t      }\n\t      var guidHolder = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx';\n\t      var hex = '0123456789abcdef';\n\t      var r = 0;\n\t      var guidResponse = \"\";\n\t      for (var i = 0; i < 36; i++) {\n\t        if (guidHolder[i] !== '-' && guidHolder[i] !== '4') {\n\t          // each x and y needs to be random\n\t          r = Math.random() * 16 | 0;\n\t        }\n\t        if (guidHolder[i] === 'x') {\n\t          guidResponse += hex[r];\n\t        } else if (guidHolder[i] === 'y') {\n\t          // clock-seq-and-reserved first hex is filtered and remaining hex values are random\n\t          r &= 0x3; // bit and with 0011 to set pos 2 to zero ?0??\n\t          r |= 0x8; // set pos 3 to 1 as 1???\n\t          guidResponse += hex[r];\n\t        } else {\n\t          guidResponse += guidHolder[i];\n\t        }\n\t      }\n\t      return guidResponse;\n\t    }\n\t  }, {\n\t    key: '_expiresIn',\n\t    value: function _expiresIn(expires) {\n\t      return this._now() + parseInt(expires, 10);\n\t    }\n\t  }, {\n\t    key: '_now',\n\t    value: function _now() {\n\t      return Math.round(new Date().getTime() / 1000.0);\n\t    }\n\t  }, {\n\t    key: '_addAuthFrame',\n\t    value: function _addAuthFrame(iframeId) {\n\t      if (typeof iframeId === 'undefined') {\n\t        return;\n\t      }\n\t\n\t      this.info('Add auth frame to document:' + iframeId);\n\t      var authFrame = document.getElementById(iframeId);\n\t\n\t      if (!authFrame) {\n\t        if (document.createElement && document.documentElement && (window.opera || window.navigator.userAgent.indexOf('MSIE 5.0') === -1)) {\n\t          var ifr = document.createElement('iframe');\n\t          ifr.setAttribute('id', iframeId);\n\t          ifr.style.visibility = 'hidden';\n\t          ifr.style.position = 'absolute';\n\t          ifr.style.width = ifr.style.height = ifr.borderWidth = '0px';\n\t\n\t          authFrame = document.getElementsByTagName('body')[0].appendChild(ifr);\n\t        } else if (document.body && document.body.insertAdjacentHTML) {\n\t          document.body.insertAdjacentHTML('beforeEnd', '<iframe name=\"' + iframeId + '\" id=\"' + iframeId + '\" style=\"display:none\"></iframe>');\n\t        }\n\t        if (window.frames && window.frames[iframeId]) {\n\t          authFrame = window.frames[iframeId];\n\t        }\n\t      }\n\t\n\t      return authFrame;\n\t    }\n\t  }, {\n\t    key: '_saveItem',\n\t    value: function _saveItem(key, obj) {\n\t      if (this.config && this.config.cacheLocation && this.config.cacheLocation === 'localStorage') {\n\t        if (!this._supportsLocalStorage()) {\n\t          this.info('Local storage is not supported');\n\t          return false;\n\t        }\n\t\n\t        localStorage.setItem(key, obj);\n\t\n\t        return true;\n\t      }\n\t\n\t      // Default as session storage\n\t      if (!this._supportsSessionStorage()) {\n\t        this.info('Session storage is not supported');\n\t        return false;\n\t      }\n\t\n\t      sessionStorage.setItem(key, obj);\n\t      return true;\n\t    }\n\t  }, {\n\t    key: '_getItem',\n\t    value: function _getItem(key) {\n\t      if (this.config && this.config.cacheLocation && this.config.cacheLocation === 'localStorage') {\n\t        if (!this._supportsLocalStorage()) {\n\t          this.info('Local storage is not supported');\n\t          return null;\n\t        }\n\t\n\t        return localStorage.getItem(key);\n\t      }\n\t\n\t      // Default as session storage\n\t      if (!this._supportsSessionStorage()) {\n\t        this.info('Session storage is not supported');\n\t        return null;\n\t      }\n\t\n\t      return sessionStorage.getItem(key);\n\t    }\n\t  }, {\n\t    key: '_supportsLocalStorage',\n\t    value: function _supportsLocalStorage() {\n\t      try {\n\t        return 'localStorage' in window && window.localStorage;\n\t      } catch (e) {\n\t        return false;\n\t      }\n\t    }\n\t  }, {\n\t    key: '_supportsSessionStorage',\n\t    value: function _supportsSessionStorage() {\n\t      try {\n\t        return 'sessionStorage' in window && window.sessionStorage;\n\t      } catch (e) {\n\t        return false;\n\t      }\n\t    }\n\t  }, {\n\t    key: '_cloneConfig',\n\t    value: function _cloneConfig(obj) {\n\t      if (obj === null || (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object') {\n\t        return obj;\n\t      }\n\t\n\t      var copy = {};\n\t      for (var attr in obj) {\n\t        if (obj.hasOwnProperty(attr)) {\n\t          copy[attr] = obj[attr];\n\t        }\n\t      }\n\t      return copy;\n\t    }\n\t  }, {\n\t    key: '_addLibMetadata',\n\t    value: function _addLibMetadata() {\n\t      // x-client-SKU\n\t      // x-client-Ver\n\t      return '&x-client-SKU=Js&x-client-Ver=' + this._libVersion();\n\t    }\n\t  }, {\n\t    key: 'log',\n\t    value: function log(level, message, error) {\n\t      if (level <= Logging.level) {\n\t        var timestamp = new Date().toUTCString();\n\t        var formattedMessage = '';\n\t\n\t        if (this.config.correlationId) {\n\t          formattedMessage = timestamp + ':' + this.config.correlationId + '-' + this._libVersion() + '-' + this.CONSTANTS.LEVEL_STRING_MAP[level] + ' ' + message;\n\t        } else {\n\t          formattedMessage = timestamp + ':' + this._libVersion() + '-' + this.CONSTANTS.LEVEL_STRING_MAP[level] + ' ' + message;\n\t        }\n\t\n\t        if (error) {\n\t          formattedMessage += '\\nstack:\\n' + error.stack;\n\t        }\n\t\n\t        Logging.log(formattedMessage);\n\t      }\n\t    }\n\t  }, {\n\t    key: 'error',\n\t    value: function error(message, _error) {\n\t      this.log(this.CONSTANTS.LOGGING_LEVEL.ERROR, message, _error);\n\t    }\n\t  }, {\n\t    key: 'warn',\n\t    value: function warn(message) {\n\t      this.log(this.CONSTANTS.LOGGING_LEVEL.WARN, message, null);\n\t    }\n\t  }, {\n\t    key: 'info',\n\t    value: function info(message) {\n\t      this.log(this.CONSTANTS.LOGGING_LEVEL.INFO, message, null);\n\t    }\n\t  }, {\n\t    key: 'verbose',\n\t    value: function verbose(message) {\n\t      this.log(this.CONSTANTS.LOGGING_LEVEL.VERBOSE, message, null);\n\t    }\n\t  }, {\n\t    key: '_libVersion',\n\t    value: function _libVersion() {\n\t      return '1.0.12';\n\t    }\n\t  }]);\n\t\n\t  return AuthenticationContext;\n\t}();\n\t\n\texports.default = AuthenticationContext;\n\t\n\t\n\tglobal.Logging = {\n\t  level: 0,\n\t  log: function log(message) {}\n\t};\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** salte-auth.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 8dba8b91e5820624561f\n **/","/**\n * @public\n * @class Config\n * @property {clientId}        Identifier assigned to your app by Azure Active Directory\n * @property {redirectUri}     Endpoint at which you expect to receive tokens\n * @property {instance}        This is the URL path to the identity provider that authorize and logout will be called against.\n * @property {endpoints}       Collection of {Endpoint-ResourceId} used for autmatically attaching tokens in webApi calls\n * @property {scope}           This may be used to define the specific authorization(s) being requested from the resource owner.\n */\n\n/**\n * User information from idtoken.\n *  @class User\n *  @property {string} userName - username assigned from upn, email, or sub (i.e. subject).\n *  @property {object} profile - properties parsed from idtoken.\n */\n\n/**\n * Creates a new AuthenticationContext object.\n * @constructor\n * @param {object}  config               Configuration options for AuthenticationContext\n */\nexport default class AuthenticationContext {\n  constructor(config) {\n    /**\n    * Enum for request type\n    * @enum {string}\n    */\n    this.REQUEST_TYPE = {\n      LOGIN: 'LOGIN',\n      RENEW_TOKEN: 'RENEW_TOKEN',\n      UNKNOWN: 'UNKNOWN'\n    };\n\n    /**\n    * Enum for storage constants\n    * @enum {string}\n    */\n    this.CONSTANTS = {\n      ACCESS_TOKEN: 'access_token',\n      EXPIRES_IN: 'expires_in',\n      ID_TOKEN: 'id_token',\n      ERROR_DESCRIPTION: 'error_description',\n      SESSION_STATE: 'session_state',\n      STORAGE: {\n        TOKEN_KEYS: 'auth.token.keys',\n        ACCESS_TOKEN_KEY: 'auth.access.token.key',\n        EXPIRATION_KEY: 'auth.expiration.key',\n        STATE_LOGIN: 'auth.state.login',\n        STATE_RENEW: 'auth.state.renew',\n        NONCE_IDTOKEN: 'auth.nonce.idtoken',\n        SESSION_STATE: 'auth.session.state',\n        USERNAME: 'auth.username',\n        IDTOKEN: 'auth.idtoken',\n        ERROR: 'auth.error',\n        ERROR_DESCRIPTION: 'auth.error.description',\n        LOGIN_REQUEST: 'auth.login.request',\n        LOGIN_ERROR: 'auth.login.error',\n        RENEW_STATUS: 'auth.token.renew.status'\n      },\n      RESOURCE_DELIMETER: '|',\n      LOADFRAME_TIMEOUT: '6000',\n      TOKEN_RENEW_STATUS_CANCELED: 'Canceled',\n      TOKEN_RENEW_STATUS_COMPLETED: 'Completed',\n      TOKEN_RENEW_STATUS_IN_PROGRESS: 'In Progress',\n      LOGGING_LEVEL: {\n        ERROR: 0,\n        WARN: 1,\n        INFO: 2,\n        VERBOSE: 3\n      },\n      LEVEL_STRING_MAP: {\n        0: 'ERROR:',\n        1: 'WARNING:',\n        2: 'INFO:',\n        3: 'VERBOSE:'\n      },\n      POPUP_WIDTH: 483,\n      POPUP_HEIGHT: 600\n    };\n\n    if (window.AuthenticationContext) {\n      return window.AuthenticationContext;\n    }\n    window.AuthenticationContext = this;\n\n    // public\n    this.config = {};\n    this.callback = null;\n    this.popUp = false;\n    this.isAngular = false;\n\n    // private\n    this._user = null;\n    this._activeRenewals = {};\n    this._loginInProgress = false;\n    this._renewStates = [];\n\n    window.callBackMappedToRenewStates = {};\n    window.callBacksMappedToRenewStates = {};\n\n    // validate before constructor assignments\n    if (config.displayCall && typeof config.displayCall !== 'function') {\n      throw new Error('displayCall is not a function');\n    }\n\n    if (!config.clientId) {\n      throw new Error('clientId is required');\n    }\n\n    this.config = this._cloneConfig(config);\n\n    if (this.config.popUp) {\n      this.popUp = true;\n    }\n\n    if (this.config.callback && typeof this.config.callback === 'function') {\n      this.callback = this.config.callback;\n    }\n\n    if (!this.config.instance || !this.config.instance.match(/^https:\\/\\/.*\\/$/)) {\n      throw new Error('instance must be a valid https endpoint that ends in a forward slash.');\n    }\n\n    // App can request idtoken for itself using clientid as resource\n    if (!this.config.loginResource) {\n      this.config.loginResource = this.config.clientId;\n    }\n\n    if (!this.config.redirectUri) {\n      this.config.redirectUri = window.location.href;\n    }\n\n    if (!this.config.anonymousEndpoints) {\n      this.config.anonymousEndpoints = [];\n    }\n\n    if (this.config.isAngular) {\n      this.isAngular = this.config.isAngular;\n    }\n\n    this.setResponseType(this.config.responseType);\n  }\n\n  setResponseType(responseType) {\n    this.config.responseType = responseType || this.CONSTANTS.ID_TOKEN;\n  }\n\n  /**\n   * Gets initial Idtoken for the app backend\n   * Saves the resulting Idtoken in localStorage.\n   * @param {string} startPage the start page\n   */\n  login(startPage) {\n    // Token is not present and user needs to login\n    if (this._loginInProgress) {\n      this.info('Login in progress');\n      return;\n    }\n    const expectedState = this._guid();\n    this.config.state = expectedState;\n    this._idTokenNonce = this._guid();\n    if (!startPage) {\n      startPage = window.location;\n    }\n    this.verbose('Expected state: ' + expectedState + ' startPage:' + startPage);\n    this._saveItem(this.CONSTANTS.STORAGE.LOGIN_REQUEST, startPage);\n    this._saveItem(this.CONSTANTS.STORAGE.LOGIN_ERROR, '');\n    this._saveItem(this.CONSTANTS.STORAGE.STATE_LOGIN, expectedState);\n    this._saveItem(this.CONSTANTS.STORAGE.NONCE_IDTOKEN, this._idTokenNonce);\n    this._saveItem(this.CONSTANTS.STORAGE.ERROR, '');\n    this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, '');\n    const urlNavigate = this._getNavigateUrl(this.config.responseType, null) + '&nonce=' + encodeURIComponent(this._idTokenNonce);\n    this._loginInProgress = true;\n    if (this.popUp) {\n      this._loginPopup(urlNavigate);\n      return;\n    }\n    if (this.config.displayCall) {\n            // User defined way of handling the navigation\n      this.config.displayCall(urlNavigate);\n    } else {\n      this.promptUser(urlNavigate);\n    }\n  }\n\n  _openPopup(urlNavigate, title, popUpWidth, popUpHeight) {\n    try {\n      /**\n      * adding winLeft and winTop to account for dual monitor\n      * using screenLeft and screenTop for IE8 and earlier\n      */\n      const winLeft = window.screenLeft ? window.screenLeft : window.screenX;\n      const winTop = window.screenTop ? window.screenTop : window.screenY;\n      /**\n      * window.innerWidth displays browser window's height and width excluding toolbars\n      * using document.documentElement.clientWidth for IE8 and earlier\n      */\n      const width = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;\n      const height = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;\n      const left = ((width / 2) - (popUpWidth / 2)) + winLeft;\n      const top = ((height / 2) - (popUpHeight / 2)) + winTop;\n\n      const popupWindow = window.open(urlNavigate, title, 'width=' + popUpWidth + ', height=' + popUpHeight + ', top=' + top + ', left=' + left);\n      if (popupWindow.focus) {\n        popupWindow.focus();\n      }\n      return popupWindow;\n    } catch (e) {\n      this.warn('Error opening popup, ' + e.message);\n      this._loginInProgress = false;\n      return null;\n    }\n  }\n\n  _loginPopup(urlNavigate) {\n    const popupWindow = this._openPopup(urlNavigate, 'login', this.CONSTANTS.POPUP_WIDTH, this.CONSTANTS.POPUP_HEIGHT);\n    if (popupWindow === null) {\n      this.warn('Popup Window is null. This can happen if you are using IE');\n      this._saveItem(this.CONSTANTS.STORAGE.ERROR, 'Error opening popup');\n      this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, 'Popup Window is null. This can happen if you are using IE');\n      this._saveItem(this.CONSTANTS.STORAGE.LOGIN_ERROR, 'Popup Window is null. This can happen if you are using IE');\n      if (this.callback) {\n        this.callback(this._getItem(this.CONSTANTS.STORAGE.LOGIN_ERROR), null);\n      }\n      return;\n    }\n    let registeredRedirectUri;\n    if (this.config.redirectUri.indexOf('#') === -1) {\n      registeredRedirectUri = this.config.redirectUri;\n    } else {\n      registeredRedirectUri = this.config.redirectUri.split('#')[0];\n    }\n    const that = this;\n    const pollTimer = window.setInterval(() => {\n      if (!popupWindow || popupWindow.closed || popupWindow.closed === undefined) {\n        that._loginInProgress = false;\n        window.clearInterval(pollTimer);\n      }\n      try {\n        if (popupWindow.location.href.indexOf(registeredRedirectUri) !== -1) {\n          if (that.isAngular) {\n            window.location.hash = popupWindow.location.hash;\n          } else {\n            that.handleWindowCallback(popupWindow.location.hash, popupWindow.location.search);\n          }\n          window.clearInterval(pollTimer);\n          that._loginInProgress = false;\n          that.info('Closing popup window');\n          popupWindow.close();\n        }\n      } catch (e) {\n      }\n    }, 20);\n  }\n\n  loginInProgress() {\n    return this._loginInProgress;\n  }\n\n  _hasResource(key) {\n    const keys = this._getItem(this.CONSTANTS.STORAGE.TOKEN_KEYS);\n    return keys && !this._isEmpty(keys) && (keys.indexOf(key + this.CONSTANTS.RESOURCE_DELIMETER) > -1);\n  }\n\n  /**\n   * Gets token for the specified resource from local storage cache\n   * @param {string}   resource A URI that identifies the resource for which the token is valid.\n   * @return {string} token if exists and not expired or null\n   */\n  getCachedToken(resource) {\n    if (!this._hasResource(resource)) {\n      return null;\n    }\n\n    const token = this._getItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY + resource);\n    const expired = this._getItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY + resource);\n\n    // If expiration is within offset, it will force renew\n    const offset = this.config.expireOffsetSeconds || 120;\n\n    if (expired && (expired > this._now() + offset)) {\n      return token;\n    }\n    this._saveItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY + resource, '');\n    this._saveItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY + resource, 0);\n    return null;\n  }\n\n  /**\n   * Retrieves and parse idToken from localstorage\n   * @return {User} user object\n   */\n  getCachedUser() {\n    if (this._user) {\n      return this._user;\n    }\n\n    const idtoken = this._getItem(this.CONSTANTS.STORAGE.IDTOKEN);\n    this._user = this._createUser(idtoken);\n    return this._user;\n  }\n\n  registerCallback(expectedState, resource, callback) {\n    this._activeRenewals[resource] = expectedState;\n    if (!window.callBacksMappedToRenewStates[expectedState]) {\n      window.callBacksMappedToRenewStates[expectedState] = [];\n    }\n    const self = this;\n    window.callBacksMappedToRenewStates[expectedState].push(callback);\n    if (!window.callBackMappedToRenewStates[expectedState]) {\n      window.callBackMappedToRenewStates[expectedState] = (message, token) => {\n        for (let i = 0; i < window.callBacksMappedToRenewStates[expectedState].length; ++i) {\n          try {\n            window.callBacksMappedToRenewStates[expectedState][i](message, token);\n          } catch (error) {\n            self.warn(error);\n          }\n        }\n        self._activeRenewals[resource] = null;\n        window.callBacksMappedToRenewStates[expectedState] = null;\n        window.callBackMappedToRenewStates[expectedState] = null;\n      };\n    }\n  }\n\n  /**\n   * Acquires access token with hidden iframe\n   * @param {string} resource  ResourceUri identifying the target resource\n   * @param {string} callback  ResourceUri identifying the target resource\n   */\n  _renewToken(resource, callback) {\n    // use iframe to try refresh token\n    // use given resource to create new authz url\n    this.info('renewToken is called for resource:' + resource);\n    const frameHandle = this._addAuthFrame('authRenewFrame' + resource);\n    const expectedState = this._guid() + '|' + resource;\n    this.config.state = expectedState;\n    // renew happens in iframe, so it keeps javascript context\n    this._renewStates.push(expectedState);\n\n    this.verbose('Renew token Expected state: ' + expectedState);\n    let urlNavigate = this._getNavigateUrl('token', resource) + '&prompt=none';\n    urlNavigate = this._addHintParameters(urlNavigate);\n\n    this.registerCallback(expectedState, resource, callback);\n    this.verbose('Navigate to:' + urlNavigate);\n    this._saveItem(this.CONSTANTS.STORAGE.LOGIN_REQUEST, '');\n    frameHandle.src = 'about:blank';\n    this._loadFrameTimeout(urlNavigate, 'authRenewFrame' + resource, resource);\n  }\n\n  _renewIdToken(callback) {\n    // use iframe to try refresh token\n    this.info('renewIdToken is called');\n    const frameHandle = this._addAuthFrame('authIdTokenFrame');\n    const expectedState = this._guid() + '|' + this.config.clientId;\n    this._idTokenNonce = this._guid();\n    this._saveItem(this.CONSTANTS.STORAGE.NONCE_IDTOKEN, this._idTokenNonce);\n    this.config.state = expectedState;\n    // renew happens in iframe, so it keeps javascript context\n    this._renewStates.push(expectedState);\n\n    this.verbose('Renew Idtoken Expected state: ' + expectedState);\n    let urlNavigate = this._getNavigateUrl(this.config.responseType, null) + '&prompt=none';\n    urlNavigate = this._addHintParameters(urlNavigate);\n\n    urlNavigate += '&nonce=' + encodeURIComponent(this._idTokenNonce);\n    this.registerCallback(expectedState, this.config.clientId, callback);\n    this.idTokenNonce = null;\n    this.verbose('Navigate to:' + urlNavigate);\n    this._saveItem(this.CONSTANTS.STORAGE.LOGIN_REQUEST, '');\n    frameHandle.src = 'about:blank';\n    this._loadFrameTimeout(urlNavigate, 'authIdTokenFrame', this.config.clientId);\n  }\n\n  _urlContainsQueryStringParameter(name, url) {\n    // regex to detect pattern of a ? or & followed by the name parameter and an equals character\n    const regex = new RegExp('[\\\\?&]' + name + '=');\n    return regex.test(url);\n  }\n\n  // Calling _loadFrame but with a timeout to signal failure in loadframeStatus. Callbacks are left\n  // registered when network errors occur and subsequent token requests for same resource are registered to the pending request\n  _loadFrameTimeout(urlNavigation, frameName, resource) {\n    // set iframe session to pending\n    this.verbose('Set loading state to pending for: ' + resource);\n    this._saveItem(this.CONSTANTS.STORAGE.RENEW_STATUS + resource, this.CONSTANTS.TOKEN_RENEW_STATUS_IN_PROGRESS);\n    this._loadFrame(urlNavigation, frameName);\n    const self = this;\n    setTimeout(() => {\n      if (self._getItem(self.CONSTANTS.STORAGE.RENEW_STATUS + resource) === self.CONSTANTS.TOKEN_RENEW_STATUS_IN_PROGRESS) {\n        // fail the iframe session if it's in pending state\n        self.verbose('Loading frame has timed out after: ' + (self.CONSTANTS.LOADFRAME_TIMEOUT / 1000) + ' seconds for resource ' + resource);\n        const expectedState = self._activeRenewals[resource];\n        if (expectedState && window.callBackMappedToRenewStates[expectedState]) {\n          window.callBackMappedToRenewStates[expectedState]('Token renewal operation failed due to timeout', null);\n        }\n\n        self._saveItem(self.CONSTANTS.STORAGE.RENEW_STATUS + resource, self.CONSTANTS.TOKEN_RENEW_STATUS_CANCELED);\n      }\n    }, self.CONSTANTS.LOADFRAME_TIMEOUT);\n  }\n\n  _loadFrame(urlNavigate, frameName) {\n    // This trick overcomes iframe navigation in IE\n    // IE does not load the page consistently in iframe\n    const self = this;\n    self.info('LoadFrame: ' + frameName);\n    const frameCheck = frameName;\n    setTimeout(() => {\n      const frameHandle = self._addAuthFrame(frameCheck);\n      if (frameHandle.src === '' || frameHandle.src === 'about:blank') {\n        frameHandle.src = urlNavigate;\n        self._loadFrame(urlNavigate, frameCheck);\n      }\n    }, 500);\n  }\n\n  /**\n   * Acquire token from cache if not expired and available. Acquires token from iframe if expired.\n   * @param {string} resource  ResourceUri identifying the target resource\n   * @param {function} callback The callback function\n   */\n  acquireToken(resource, callback) {\n    if (this._isEmpty(resource)) {\n      this.warn('resource is required');\n      callback('resource is required', null);\n      return;\n    }\n\n    const token = this.getCachedToken(resource);\n    if (token) {\n      this.info('Token is already in cache for resource:' + resource);\n      callback(null, token);\n      return;\n    }\n\n    if (!this._user) {\n      this.warn('User login is required');\n      callback('User login is required', null);\n      return;\n    }\n\n    // refresh attept with iframe\n    // Already renewing for this resource, callback when we get the token.\n    if (this._activeRenewals[resource]) {\n      // Active renewals contains the state for each renewal.\n      this.registerCallback(this._activeRenewals[resource], resource, callback);\n    } else if (resource === this.config.clientId) {\n      // App uses idtoken to send to api endpoints\n      // Default resource is tracked as clientid to store this token\n      this.verbose('renewing idtoken');\n      this._renewIdToken(callback);\n    } else {\n      this._renewToken(resource, callback);\n    }\n  }\n\n  /**\n   * Redirect the Browser to Azure AD Authorization endpoint\n   * @param {string} urlNavigate The authorization request url\n   */\n  promptUser(urlNavigate) {\n    if (urlNavigate) {\n      this.info('Navigate to:' + urlNavigate);\n      window.location.replace(urlNavigate);\n    } else {\n      this.info('Navigate url is empty');\n    }\n  }\n\n  /**\n   * Clear cache items.\n   */\n  clearCache() {\n    this._saveItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY, '');\n    this._saveItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY, 0);\n    this._saveItem(this.CONSTANTS.STORAGE.SESSION_STATE, '');\n    this._saveItem(this.CONSTANTS.STORAGE.STATE_LOGIN, '');\n    this._renewStates = [];\n    this._saveItem(this.CONSTANTS.STORAGE.USERNAME, '');\n    this._saveItem(this.CONSTANTS.STORAGE.IDTOKEN, '');\n    this._saveItem(this.CONSTANTS.STORAGE.ERROR, '');\n    this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, '');\n    let keys = this._getItem(this.CONSTANTS.STORAGE.TOKEN_KEYS);\n\n    if (!this._isEmpty(keys)) {\n      keys = keys.split(this.CONSTANTS.RESOURCE_DELIMETER);\n      for (let i = 0; i < keys.length; i++) {\n        this._saveItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY + keys[i], '');\n        this._saveItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY + keys[i], 0);\n      }\n    }\n    this._saveItem(this.CONSTANTS.STORAGE.TOKEN_KEYS, '');\n  }\n\n  /**\n   * Clear cache items for a resource.\n   * @param {string} resource The resource\n   */\n  clearCacheForResource(resource) {\n    this._saveItem(this.CONSTANTS.STORAGE.STATE_RENEW, '');\n    this._saveItem(this.CONSTANTS.STORAGE.ERROR, '');\n    this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, '');\n    if (this._hasResource(resource)) {\n      this._saveItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY + resource, '');\n      this._saveItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY + resource, 0);\n    }\n  }\n\n  /**\n   * Logout user will redirect page to logout endpoint.\n   * After logout, it will redirect to post_logout page if provided.\n   */\n  logOut() {\n    this.clearCache();\n    let logout = '';\n    this._user = null;\n\n    if (this.config.postLogoutRedirectUri) {\n      logout = 'post_logout_redirect_uri=' + encodeURIComponent(this.config.postLogoutRedirectUri);\n    }\n\n    const urlNavigate = this.config.instance + 'logout?' + logout;\n    this.info('Logout navigate to: ' + urlNavigate);\n    this.promptUser(urlNavigate);\n  }\n\n  _isEmpty(str) {\n    return (typeof str === 'undefined' || !str || str.length === 0);\n  }\n\n  /**\n   * Gets a user profile\n   * @param {requestCallback} callback The callback that handles the response.\n   */\n  getUser(callback) {\n    // IDToken is first call\n    if (typeof callback !== 'function') {\n      throw new Error('callback is not a function');\n    }\n\n    // user in memory\n    if (this._user) {\n      callback(null, this._user);\n      return;\n    }\n\n    // frame is used to get idtoken\n    const idtoken = this._getItem(this.CONSTANTS.STORAGE.IDTOKEN);\n    if (this._isEmpty(idtoken)) {\n      this.warn('User information is not available');\n      callback('User information is not available');\n    } else {\n      this.info('User exists in cache: ');\n      this._user = this._createUser(idtoken);\n      callback(null, this._user);\n    }\n  }\n\n  _addHintParameters(urlNavigate) {\n    // include hint params only if upn is present\n    if (this._user && this._user.profile && this._user.profile.hasOwnProperty('upn')) {\n      // add login_hint\n      urlNavigate += '&login_hint=' + encodeURIComponent(this._user.profile.upn);\n\n      // don't add domain_hint twice if user provided it in the extraQueryParameter value\n      if (!this._urlContainsQueryStringParameter('domain_hint', urlNavigate) && this._user.profile.upn.indexOf('@') > -1) {\n        const parts = this._user.profile.upn.split('@');\n        // local part can include @ in quotes. Sending last part handles that.\n        urlNavigate += '&domain_hint=' + encodeURIComponent(parts[parts.length - 1]);\n      }\n    }\n\n    return urlNavigate;\n  }\n\n  _createUser(idToken) {\n    let user = null;\n    const parsedJson = this._extractIdToken(idToken);\n    if (parsedJson && parsedJson.hasOwnProperty('aud')) {\n      let audienceMatch = false;\n\n      if (Array.isArray(parsedJson.aud)) {\n        // If the ID Token contains multiple audiences then an azp claim must be present and equal to the client id.\n        if (parsedJson.hasOwnProperty('azp') && parsedJson.azp.toLowerCase() === this.config.clientId.toLowerCase()) {\n          for (let i = 0; i < parsedJson.aud.length; i++) {\n            if (parsedJson.aud[i].toLowerCase() === this.config.clientId.toLowerCase()) {\n              audienceMatch = true;\n              break;\n            }\n          }\n        }\n      } else {\n        audienceMatch = (parsedJson.aud.toLowerCase() === this.config.clientId.toLowerCase());\n      }\n\n      if (audienceMatch) {\n        user = {\n          userName: '',\n          profile: parsedJson\n        };\n\n        if (parsedJson.hasOwnProperty('upn')) {\n          user.userName = parsedJson.upn;\n        } else if (parsedJson.hasOwnProperty('email')) {\n          user.userName = parsedJson.email;\n        } else if (parsedJson.hasOwnProperty('sub')) {\n          user.userName = parsedJson.sub;\n        }\n      } else {\n        this.warn('IdToken has invalid aud/azp field');\n      }\n    }\n\n    return user;\n  }\n\n  _getHash(hash) {\n    if (hash.indexOf('#/') > -1) {\n      hash = hash.substring(hash.indexOf('#/') + 2);\n    } else if (hash.indexOf('#') > -1) {\n      hash = hash.substring(1);\n    }\n\n    return hash;\n  }\n\n  _getSearch(search) {\n    if (search.indexOf('?') > -1) {\n      search = search.substring(1);\n    }\n\n    return search;\n  }\n\n  _getParameters(hash, search) {\n    let parameters = {};\n\n    if (hash) {\n      hash = this._getHash(hash);\n      parameters = this._deserialize(hash);\n    }\n\n    if (search) {\n      search = this._getSearch(search);\n      const searchParameters = this._deserialize(search);\n      parameters = this._extend(parameters, searchParameters);\n    }\n\n    return parameters;\n  }\n\n  _extend(obj, src) {\n    for (const key in src) {\n      if (src.hasOwnProperty(key)) {\n        obj[key] = src[key];\n      }\n    }\n    return obj;\n  }\n\n  /**\n   * Checks if hash contains access token or id token or error_description\n   * @param {string} hash  -  Hash passed from redirect page\n   * @param {string} search  -  Search passed from redirect page\n   * @return {boolean} exists if all the parameters exist\n   */\n  isCallback(hash, search) {\n    const parameters = this._getParameters(hash, search);\n\n    return parameters.hasOwnProperty(this.CONSTANTS.ERROR_DESCRIPTION) ||\n      parameters.hasOwnProperty(this.CONSTANTS.ACCESS_TOKEN) ||\n      parameters.hasOwnProperty(this.CONSTANTS.ID_TOKEN);\n  }\n\n  /**\n   * Gets login error\n   * @return {string} error message related to login\n   */\n  getLoginError() {\n    return this._getItem(this.CONSTANTS.STORAGE.LOGIN_ERROR);\n  }\n\n  /**\n   * Gets requestInfo from given hash.\n   * @param {string} hash  -  Hash passed from redirect page\n   * @param {string} search  -  Search passed from redirect page\n   * @return {string} error message related to login\n   */\n  getRequestInfo(hash, search) {\n    const parameters = this._getParameters(hash, search);\n    const requestInfo = {\n      valid: false,\n      parameters: {},\n      stateMatch: false,\n      stateResponse: '',\n      requestType: this.REQUEST_TYPE.UNKNOWN\n    };\n\n    if (parameters) {\n      requestInfo.parameters = parameters;\n      if (parameters.hasOwnProperty(this.CONSTANTS.ERROR_DESCRIPTION) ||\n        parameters.hasOwnProperty(this.CONSTANTS.ACCESS_TOKEN) ||\n        parameters.hasOwnProperty(this.CONSTANTS.ID_TOKEN)) {\n        requestInfo.valid = true;\n\n        // which call\n        let stateResponse = '';\n        if (parameters.hasOwnProperty('state')) {\n          this.verbose('State: ' + parameters.state);\n          stateResponse = parameters.state;\n        } else {\n          this.warn('No state returned');\n          return requestInfo;\n        }\n\n        requestInfo.stateResponse = stateResponse;\n\n        // async calls can fire iframe and login request at the same time if developer does not use the API as expected\n        // incoming callback needs to be looked up to find the request type\n        if (stateResponse === this._getItem(this.CONSTANTS.STORAGE.STATE_LOGIN)) {\n          requestInfo.requestType = this.REQUEST_TYPE.LOGIN;\n          requestInfo.stateMatch = true;\n          return requestInfo;\n        }\n\n        // external api requests may have many renewtoken requests for different resource\n        if (!requestInfo.stateMatch && window.parent && window.parent.AuthenticationContext) {\n          const statesInParentContext = window.parent.AuthenticationContext._renewStates;\n          for (let i = 0; i < statesInParentContext.length; i++) {\n            if (statesInParentContext[i] === requestInfo.stateResponse) {\n              requestInfo.requestType = this.REQUEST_TYPE.RENEW_TOKEN;\n              requestInfo.stateMatch = true;\n              break;\n            }\n          }\n        }\n      }\n    }\n\n    return requestInfo;\n  }\n\n  _getResourceFromState(state) {\n    if (state) {\n      const splitIndex = state.indexOf('|');\n      if (splitIndex > -1 && splitIndex + 1 < state.length) {\n        return state.substring(splitIndex + 1);\n      }\n    }\n\n    return '';\n  }\n\n  /**\n   * Saves token from hash that is received from redirect.\n   * @param {string} requestInfo Hash passed from redirect page\n   */\n  saveTokenFromHash(requestInfo) {\n    this.info('State status:' + requestInfo.stateMatch + '; Request type:' + requestInfo.requestType);\n    this._saveItem(this.CONSTANTS.STORAGE.ERROR, '');\n    this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, '');\n\n    let resource = this._getResourceFromState(requestInfo.stateResponse);\n\n    // Record error\n    if (requestInfo.parameters.hasOwnProperty(this.CONSTANTS.ERROR_DESCRIPTION)) {\n      this.info('Error :' + requestInfo.parameters.error + '; Error description:' + requestInfo.parameters[this.CONSTANTS.ERROR_DESCRIPTION]);\n      this._saveItem(this.CONSTANTS.STORAGE.ERROR, requestInfo.parameters.error);\n      this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, requestInfo.parameters[this.CONSTANTS.ERROR_DESCRIPTION]);\n\n      if (requestInfo.requestType === this.REQUEST_TYPE.LOGIN) {\n        this._loginInProgress = false;\n        this._saveItem(this.CONSTANTS.STORAGE.LOGIN_ERROR, requestInfo.parameters.error_description);\n      }\n    } else if (requestInfo.stateMatch) {\n      // record tokens to storage if exists\n      this.info('State is right');\n      if (requestInfo.parameters.hasOwnProperty(this.CONSTANTS.SESSION_STATE)) {\n        this._saveItem(this.CONSTANTS.STORAGE.SESSION_STATE, requestInfo.parameters[this.CONSTANTS.SESSION_STATE]);\n      }\n\n      let keys;\n\n      if (requestInfo.parameters.hasOwnProperty(this.CONSTANTS.ACCESS_TOKEN)) {\n        this.info('Fragment has access token');\n\n        if (!this._hasResource(resource)) {\n          keys = this._getItem(this.CONSTANTS.STORAGE.TOKEN_KEYS) || '';\n          this._saveItem(this.CONSTANTS.STORAGE.TOKEN_KEYS, keys + resource + this.CONSTANTS.RESOURCE_DELIMETER);\n        }\n        // save token with related resource\n        this._saveItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY + resource, requestInfo.parameters[this.CONSTANTS.ACCESS_TOKEN]);\n        this._saveItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY + resource, this._expiresIn(requestInfo.parameters[this.CONSTANTS.EXPIRES_IN]));\n      }\n\n      if (requestInfo.parameters.hasOwnProperty(this.CONSTANTS.ID_TOKEN)) {\n        this.info('Fragment has id token');\n        this._loginInProgress = false;\n\n        this._user = this._createUser(requestInfo.parameters[this.CONSTANTS.ID_TOKEN]);\n\n        if (this._user && this._user.profile) {\n          if (this._user.profile.nonce === this._getItem(this.CONSTANTS.STORAGE.NONCE_IDTOKEN)) {\n            this._saveItem(this.CONSTANTS.STORAGE.IDTOKEN, requestInfo.parameters[this.CONSTANTS.ID_TOKEN]);\n\n            // Save idtoken as access token for app itself\n            resource = this.config.loginResource ? this.config.loginResource : this.config.clientId;\n\n            if (!this._hasResource(resource)) {\n              keys = this._getItem(this.CONSTANTS.STORAGE.TOKEN_KEYS) || '';\n              this._saveItem(this.CONSTANTS.STORAGE.TOKEN_KEYS, keys + resource + this.CONSTANTS.RESOURCE_DELIMETER);\n            }\n            this._saveItem(this.CONSTANTS.STORAGE.ACCESS_TOKEN_KEY + resource, requestInfo.parameters[this.CONSTANTS.ID_TOKEN]);\n            this._saveItem(this.CONSTANTS.STORAGE.EXPIRATION_KEY + resource, this._user.profile.exp);\n          } else {\n            this._user = null;\n            this._saveItem(this.CONSTANTS.STORAGE.LOGIN_ERROR, 'Nonce is not same as ' + this._idTokenNonce);\n          }\n        } else {\n          this._saveItem(this.CONSTANTS.STORAGE.ERROR, 'invalid id_token');\n          this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, 'Invalid id_token. id_token: ' + requestInfo.parameters[this.CONSTANTS.ID_TOKEN]);\n        }\n      }\n    } else {\n      this._saveItem(this.CONSTANTS.STORAGE.ERROR, 'Invalid_state');\n      this._saveItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION, 'Invalid_state. state: ' + requestInfo.stateResponse);\n    }\n    this._saveItem(this.CONSTANTS.STORAGE.RENEW_STATUS + resource, this.CONSTANTS.TOKEN_RENEW_STATUS_COMPLETED);\n  }\n\n  /**\n   * Gets resource for given endpoint if mapping is provided with config.\n   * @param {string} endpoint API endpoint\n   * @return {string} resource for this API endpoint\n   */\n  getResourceForEndpoint(endpoint) {\n    if (this.config && this.config.endpoints) {\n      for (const configEndpoint in this.config.endpoints) {\n        // configEndpoint is like /api/Todo requested endpoint can be /api/Todo/1\n        if (endpoint.indexOf(configEndpoint) > -1) {\n          return this.config.endpoints[configEndpoint];\n        }\n      }\n    }\n\n    // default resource will be clientid if nothing specified\n    // App will use idtoken for calls to itself\n    // check if it's staring from http or https, needs to match with app host\n    if (endpoint.indexOf('http://') > -1 || endpoint.indexOf('https://') > -1) {\n      if (this._getHostFromUri(endpoint) === this._getHostFromUri(this.config.redirectUri)) {\n        return this.config.loginResource;\n      }\n    } else {\n      // in angular level, the url for $http interceptor call could be relative url,\n      // if it's relative call, we'll treat it as app backend call.\n      // if user specified list of anonymous endpoints, no need to send token to these endpoints, return null.\n      if (this.config && this.config.anonymousEndpoints) {\n        for (let i = 0; i < this.config.anonymousEndpoints.length; i++) {\n          if (endpoint.indexOf(this.config.anonymousEndpoints[i]) > -1) {\n            return null;\n          }\n        }\n      }\n      // all other app's backend calls are secured.\n      return this.config.loginResource;\n    }\n\n    // if not the app's own backend or not a domain listed in the endpoints structure\n    return null;\n  }\n\n  _getHostFromUri(uri) {\n    // remove http:// or https:// from uri\n    let extractedUri = String(uri).replace(/^(https?:)\\/\\//, '');\n\n    extractedUri = extractedUri.split('/')[0];\n    return extractedUri;\n  }\n\n  /* exported  oauth2Callback */\n  handleWindowCallback(hash, search) {\n    // This is for regular javascript usage for redirect handling\n    // need to make sure this is for callback\n    if (!hash) {\n      hash = window.location.hash;\n    }\n\n    if (!search) {\n      search = window.location.search;\n    }\n\n    if (this.isCallback(hash, search)) {\n      const requestInfo = this.getRequestInfo(hash, search);\n      this.info('Returned from redirect url');\n      this.saveTokenFromHash(requestInfo);\n      let callback = null;\n      if ((requestInfo.requestType === this.REQUEST_TYPE.RENEW_TOKEN) && window.parent && (window.parent !== window)) {\n        // iframe call but same single page\n        this.verbose('Window is in iframe');\n        callback = window.parent.callBackMappedToRenewStates[requestInfo.stateResponse];\n        if (callback) {\n          callback(this._getItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION), requestInfo.parameters[this.CONSTANTS.ACCESS_TOKEN] || requestInfo.parameters[this.CONSTANTS.ID_TOKEN]);\n        }\n        return;\n      } else if (requestInfo.requestType === this.REQUEST_TYPE.LOGIN) {\n        callback = this.callback;\n        if (callback) {\n          callback(this._getItem(this.CONSTANTS.STORAGE.ERROR_DESCRIPTION), requestInfo.parameters[this.CONSTANTS.ID_TOKEN]);\n        }\n      }\n      // No need to redirect user in case of popup\n      if (!this.popUp) {\n        window.location = this._getItem(this.CONSTANTS.STORAGE.LOGIN_REQUEST);\n      }\n    }\n  }\n\n  _getNavigateUrl(responseType, resource) {\n    let urlNavigate = this.config.instance + 'authorize' + this._serialize(responseType, this.config, resource) + this._addLibMetadata();\n    if (this.config.scope) {\n      urlNavigate += '&scope=' + encodeURIComponent(this.config.scope);\n    }\n    this.info('Navigate url:' + urlNavigate);\n    return urlNavigate;\n  }\n\n  _extractIdToken(encodedIdToken) {\n    // id token will be decoded to get the username\n    const decodedToken = this._decodeJwt(encodedIdToken);\n    if (!decodedToken) {\n      return null;\n    }\n\n    try {\n      const base64IdToken = decodedToken.JWSPayload;\n      const base64Decoded = this._base64DecodeStringUrlSafe(base64IdToken);\n      if (!base64Decoded) {\n        this.info('The returned id_token could not be base64 url safe decoded.');\n        return null;\n      }\n\n      return JSON.parse(base64Decoded);\n    } catch (err) {\n      this.error('The returned id_token could not be decoded', err);\n    }\n\n    return null;\n  }\n\n  _base64DecodeStringUrlSafe(base64IdToken) {\n    // html5 should support atob function for decoding\n    base64IdToken = base64IdToken.replace(/-/g, '+').replace(/_/g, '/');\n    if (window.atob) {\n      return decodeURIComponent(escape(window.atob(base64IdToken)));\n    }\n    return decodeURIComponent(escape(this._decode(base64IdToken)));\n  }\n\n  // Take https://cdnjs.cloudflare.com/ajax/libs/Base64/0.3.0/base64.js and https://en.wikipedia.org/wiki/Base64 as reference.\n  _decode(base64IdToken) {\n    const codes = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n    base64IdToken = String(base64IdToken).replace(/[=]+$/, '');\n\n    const length = base64IdToken.length;\n    if (length % 4 === 1) {\n      throw new Error('The token to be decoded is not correctly encoded.');\n    }\n\n    let h1, h2, h3, h4, bits, c1, c2, c3;\n    let decoded = '';\n    for (let i = 0; i < length; i += 4) {\n      // Every 4 base64 encoded character will be converted to 3 byte string, which is 24 bits\n      // then 6 bits per base64 encoded character\n      h1 = codes.indexOf(base64IdToken.charAt(i));\n      h2 = codes.indexOf(base64IdToken.charAt(i + 1));\n      h3 = codes.indexOf(base64IdToken.charAt(i + 2));\n      h4 = codes.indexOf(base64IdToken.charAt(i + 3));\n\n      // For padding, if last two are '='\n      if (i + 2 === length - 1) {\n        bits = h1 << 18 | h2 << 12 | h3 << 6;\n        c1 = bits >> 16 & 255;\n        c2 = bits >> 8 & 255;\n        decoded += String.fromCharCode(c1, c2);\n        break;\n      } else if (i + 1 === length - 1) { // if last one is '='\n        bits = h1 << 18 | h2 << 12;\n        c1 = bits >> 16 & 255;\n        decoded += String.fromCharCode(c1);\n        break;\n      }\n\n      bits = h1 << 18 | h2 << 12 | h3 << 6 | h4;\n\n      // then convert to 3 byte chars\n      c1 = bits >> 16 & 255;\n      c2 = bits >> 8 & 255;\n      c3 = bits & 255;\n\n      decoded += String.fromCharCode(c1, c2, c3);\n    }\n\n    return decoded;\n  }\n\n    // Auth.node js crack function\n  _decodeJwt(jwtToken) {\n    if (this._isEmpty(jwtToken)) {\n      return null;\n    }\n\n    const idTokenPartsRegex = /^([^\\.\\s]*)\\.([^\\.\\s]+)\\.([^\\.\\s]*)$/;\n\n    const matches = idTokenPartsRegex.exec(jwtToken);\n    if (!matches || matches.length < 4) {\n      this.warn('The returned id_token is not parseable.');\n      return null;\n    }\n\n    const crackedToken = {\n      header: matches[1],\n      JWSPayload: matches[2],\n      JWSSig: matches[3]\n    };\n\n    return crackedToken;\n  }\n\n  _convertUrlSafeToRegularBase64EncodedString(str) {\n    return str.replace('-', '+').replace('_', '/');\n  }\n\n  _serialize(responseType, obj, resource) {\n    const str = [];\n    if (obj !== null) {\n      str.push('?response_type=' + encodeURIComponent(responseType));\n      str.push('client_id=' + encodeURIComponent(obj.clientId));\n      if (resource) {\n        str.push('resource=' + encodeURIComponent(resource));\n      }\n\n      str.push('redirect_uri=' + encodeURIComponent(obj.redirectUri));\n      str.push('state=' + encodeURIComponent(obj.state));\n\n      if (obj.hasOwnProperty('slice')) {\n        str.push('slice=' + encodeURIComponent(obj.slice));\n      }\n\n      if (obj.hasOwnProperty('extraQueryParameter')) {\n        str.push(obj.extraQueryParameter);\n      }\n\n      const correlationId = obj.correlationId ? obj.correlationId : this._guid();\n      str.push('client-request-id=' + encodeURIComponent(correlationId));\n    }\n\n    return str.join('&');\n  }\n\n  _deserialize(query) {\n    const pl = /\\+/g; // Regex for replacing addition symbol with a space\n    const search = /([^&=]+)=([^&]*)/g;\n    const decode = (s) => {\n      return decodeURIComponent(s.replace(pl, ' '));\n    };\n    const obj = {};\n    let match = search.exec(query);\n    while (match) {\n      obj[decode(match[1])] = decode(match[2]);\n      match = search.exec(query);\n    }\n\n    return obj;\n  }\n\n  _decimalToHex(number) {\n    let hex = number.toString(16);\n    while (hex.length < 2) {\n      hex = '0' + hex;\n    }\n    return hex;\n  }\n\n  _guid() {\n    // RFC4122: The version 4 UUID is meant for generating UUIDs from truly-random or\n    // pseudo-random numbers.\n    // The algorithm is as follows:\n    //     Set the two most significant bits (bits 6 and 7) of the\n    //        clock_seq_hi_and_reserved to zero and one, respectively.\n    //     Set the four most significant bits (bits 12 through 15) of the\n    //        time_hi_and_version field to the 4-bit version number from\n    //        Section 4.1.3. Version4\n    //     Set all the other bits to randomly (or pseudo-randomly) chosen\n    //     values.\n    // UUID                   = time-low \"-\" time-mid \"-\"time-high-and-version \"-\"clock-seq-reserved and low(2hexOctet)\"-\" node\n    // time-low               = 4hexOctet\n    // time-mid               = 2hexOctet\n    // time-high-and-version  = 2hexOctet\n    // clock-seq-and-reserved = hexOctet:\n    // clock-seq-low          = hexOctet\n    // node                   = 6hexOctet\n    // Format: xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\n    // y could be 1000, 1001, 1010, 1011 since most significant two bits needs to be 10\n    // y values are 8, 9, A, B\n    const cryptoObj = window.crypto || window.msCrypto; // for IE 11\n    if (cryptoObj && cryptoObj.getRandomValues) {\n      const buffer = new Uint8Array(16);\n      cryptoObj.getRandomValues(buffer);\n      // buffer[6] and buffer[7] represents the time_hi_and_version field. We will set the four most significant bits (4 through 7) of buffer[6] to represent decimal number 4 (UUID version number).\n      buffer[6] |= 0x40; // buffer[6] | 01000000 will set the 6 bit to 1.\n      buffer[6] &= 0x4f; // buffer[6] & 01001111 will set the 4, 5, and 7 bit to 0 such that bits 4-7 == 0100 = \"4\".\n      // buffer[8] represents the clock_seq_hi_and_reserved field. We will set the two most significant bits (6 and 7) of the clock_seq_hi_and_reserved to zero and one, respectively.\n      buffer[8] |= 0x80; // buffer[8] | 10000000 will set the 7 bit to 1.\n      buffer[8] &= 0xbf; // buffer[8] & 10111111 will set the 6 bit to 0.\n      return this._decimalToHex(buffer[0]) + this._decimalToHex(buffer[1]) + this._decimalToHex(buffer[2]) + this._decimalToHex(buffer[3]) + '-' + this._decimalToHex(buffer[4]) + this._decimalToHex(buffer[5]) + '-' + this._decimalToHex(buffer[6]) + this._decimalToHex(buffer[7]) + '-' +\n             this._decimalToHex(buffer[8]) + this._decimalToHex(buffer[9]) + '-' + this._decimalToHex(buffer[10]) + this._decimalToHex(buffer[11]) + this._decimalToHex(buffer[12]) + this._decimalToHex(buffer[13]) + this._decimalToHex(buffer[14]) + this._decimalToHex(buffer[15]);\n    }\n    const guidHolder = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx';\n    const hex = '0123456789abcdef';\n    let r = 0;\n    let guidResponse = \"\";\n    for (let i = 0; i < 36; i++) {\n      if (guidHolder[i] !== '-' && guidHolder[i] !== '4') {\n                  // each x and y needs to be random\n        r = Math.random() * 16 | 0;\n      }\n      if (guidHolder[i] === 'x') {\n        guidResponse += hex[r];\n      } else if (guidHolder[i] === 'y') {\n                  // clock-seq-and-reserved first hex is filtered and remaining hex values are random\n        r &= 0x3; // bit and with 0011 to set pos 2 to zero ?0??\n        r |= 0x8; // set pos 3 to 1 as 1???\n        guidResponse += hex[r];\n      } else {\n        guidResponse += guidHolder[i];\n      }\n    }\n    return guidResponse;\n  }\n\n  _expiresIn(expires) {\n    return this._now() + parseInt(expires, 10);\n  }\n\n  _now() {\n    return Math.round(new Date().getTime() / 1000.0);\n  }\n\n  _addAuthFrame(iframeId) {\n    if (typeof iframeId === 'undefined') {\n      return;\n    }\n\n    this.info('Add auth frame to document:' + iframeId);\n    let authFrame = document.getElementById(iframeId);\n\n    if (!authFrame) {\n      if (document.createElement && document.documentElement &&\n                (window.opera || window.navigator.userAgent.indexOf('MSIE 5.0') === -1)) {\n        const ifr = document.createElement('iframe');\n        ifr.setAttribute('id', iframeId);\n        ifr.style.visibility = 'hidden';\n        ifr.style.position = 'absolute';\n        ifr.style.width = ifr.style.height = ifr.borderWidth = '0px';\n\n        authFrame = document.getElementsByTagName('body')[0].appendChild(ifr);\n      } else if (document.body && document.body.insertAdjacentHTML) {\n        document.body.insertAdjacentHTML('beforeEnd', '<iframe name=\"' + iframeId + '\" id=\"' + iframeId + '\" style=\"display:none\"></iframe>');\n      }\n      if (window.frames && window.frames[iframeId]) {\n        authFrame = window.frames[iframeId];\n      }\n    }\n\n    return authFrame;\n  }\n\n  _saveItem(key, obj) {\n    if (this.config && this.config.cacheLocation && this.config.cacheLocation === 'localStorage') {\n      if (!this._supportsLocalStorage()) {\n        this.info('Local storage is not supported');\n        return false;\n      }\n\n      localStorage.setItem(key, obj);\n\n      return true;\n    }\n\n    // Default as session storage\n    if (!this._supportsSessionStorage()) {\n      this.info('Session storage is not supported');\n      return false;\n    }\n\n    sessionStorage.setItem(key, obj);\n    return true;\n  }\n\n  _getItem(key) {\n    if (this.config && this.config.cacheLocation && this.config.cacheLocation === 'localStorage') {\n      if (!this._supportsLocalStorage()) {\n        this.info('Local storage is not supported');\n        return null;\n      }\n\n      return localStorage.getItem(key);\n    }\n\n    // Default as session storage\n    if (!this._supportsSessionStorage()) {\n      this.info('Session storage is not supported');\n      return null;\n    }\n\n    return sessionStorage.getItem(key);\n  }\n\n  _supportsLocalStorage() {\n    try {\n      return 'localStorage' in window && window.localStorage;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  _supportsSessionStorage() {\n    try {\n      return 'sessionStorage' in window && window.sessionStorage;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  _cloneConfig(obj) {\n    if (obj === null || typeof obj !== 'object') {\n      return obj;\n    }\n\n    const copy = {};\n    for (const attr in obj) {\n      if (obj.hasOwnProperty(attr)) {\n        copy[attr] = obj[attr];\n      }\n    }\n    return copy;\n  }\n\n  _addLibMetadata() {\n    // x-client-SKU\n    // x-client-Ver\n    return '&x-client-SKU=Js&x-client-Ver=' + this._libVersion();\n  }\n\n  log(level, message, error) {\n    if (level <= Logging.level) {\n      const timestamp = new Date().toUTCString();\n      let formattedMessage = '';\n\n      if (this.config.correlationId) {\n        formattedMessage = timestamp + ':' + this.config.correlationId + '-' + this._libVersion() + '-' + this.CONSTANTS.LEVEL_STRING_MAP[level] + ' ' + message;\n      } else {\n        formattedMessage = timestamp + ':' + this._libVersion() + '-' + this.CONSTANTS.LEVEL_STRING_MAP[level] + ' ' + message;\n      }\n\n      if (error) {\n        formattedMessage += '\\nstack:\\n' + error.stack;\n      }\n\n      Logging.log(formattedMessage);\n    }\n  }\n\n  error(message, error) {\n    this.log(this.CONSTANTS.LOGGING_LEVEL.ERROR, message, error);\n  }\n\n  warn(message) {\n    this.log(this.CONSTANTS.LOGGING_LEVEL.WARN, message, null);\n  }\n\n  info(message) {\n    this.log(this.CONSTANTS.LOGGING_LEVEL.INFO, message, null);\n  }\n\n  verbose(message) {\n    this.log(this.CONSTANTS.LOGGING_LEVEL.VERBOSE, message, null);\n  }\n\n  _libVersion() {\n    return '1.0.12';\n  }\n}\n\nglobal.Logging = {\n  level: 0,\n  log: (message) => {}\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./salte-auth.js\n **/"],"sourceRoot":""}
